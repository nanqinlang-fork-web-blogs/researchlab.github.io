<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朴实的一线攻城狮</title>
  <subtitle>十年磨一剑，一步一步脚踏实地的耕种</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.grdtechs.com/"/>
  <updated>2016-12-18T09:17:06.061Z</updated>
  <id>http://www.grdtechs.com/</id>
  
  <author>
    <name>Lee Hong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go实现缓存组件</title>
    <link href="http://www.grdtechs.com/2016/12/17/go-cache-component/"/>
    <id>http://www.grdtechs.com/2016/12/17/go-cache-component/</id>
    <published>2016-12-17T11:32:51.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>总结用golang从分析，设计到实现一个可用的缓存组件。<br><a id="more"></a></p>
<h2 id="u7F13_u5B58"><a href="#u7F13_u5B58" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li><p>为什么要设计缓存<br>  电脑的内存是以系统总线的时钟频率工作的，这个频率通常也就是CPU的外频(对于雷鸟、毒龙系列的处理器，由于在设计采用了DDR技术，CPU工作的外频为系统总线频率的两倍)。但是，CPU的工作频率(主频)是外频与倍频因子的乘积。这样一来，内存的工作频率就远低于CPU的工作频率了,造成的直接结果是：CPU在执行完一条指令后，常常需要”等待”一些时间才能再次访问内存，极大降了CPU工作效率。在这样一种情况下，Cache就应运而生,Cache是一种特殊的存储器，它由Cache 存储部件和Cache控制部件组成。Cache 存储部件一般采用与CPU同类型的半导体存储器件，存取速度比内存快几倍甚至十几倍。<br>  缓存(Cache)在计算机硬件中普遍存在。比如在CPU中就有一级缓存，二级缓存，甚至三级缓存。缓存的工作原理一般是CPU需要读取数据时，会首先从缓存中查找需要的数据，如果找到了就直接进行处理，如果没有找到则从内存中读取数据。缓存不仅仅存在于硬件中，在各种软件系统中也处处可见。比如在Web系统中，缓存存在于服务器端，客户端或者代理服务器中。广泛使用的CDN网络，也可以看作一个巨大的缓存系统。缓存在Web系统中的使用有很多好处，不仅可以减少网络流量，降低客户访问延迟，还可以减轻服务器负载。</p>
</li>
<li><p>缓存如何工作<br> 单颗CPU运行程序是一条指令一条指令地执行的，而且指令地址往往是连续的，意思就是说CPU在访问内存时，在较短的一段时间内往往集中于某个局部，这时候可能会碰到一些需要反复调用的子程序。电脑在工作时，把这些活跃的子程序存入比内存快得多的Cache中。CPU在访问内存时，首先判断所要访问的内容是否在Cache中，如果在，就称为<code>命中</code>，此时CPU直接从Cache中调用该内容；否则，就称为<code>不命中</code>，CPU只好去内存中调用所需的子程序或指令了。CPU不但可以直接从Cache中读出内容，也可以直接往其中写入内容。由于Cache的存取速率相当快，使得CPU的利用率大大提高，进而使整个系统的性能得以提升。<br> CPU通过地址映射Cache和主存关联起来，从而确定将要访问的主存的内容是否在缓存中，所谓映象问题是指如何确定Cache中的内容是主存中的哪一部分的拷贝，即必须应用某种函数把主存地址映象到Cache中定位，也称地址映象。当信息按这种方式装入Cache中后，执行程序时，应将主存地址变换为Cache地址，这个变换过程叫作地址变换。</p>
<ul>
<li>地址映象方式通常采用<code>直接映象</code>、<code>全相联映象</code>、<code>组相联映象</code>三种<ol>
<li><code>直接映像</code><br>是指每个主存页只能复制到某一固定的Cache页中。直接映像的规律是：将主存的2048页分为128组，每组有16页，分别与Cache的16页直接对应，即主存的第0页、第16页、第32页……只能映像到Cache的第0页。</li>
<li><code>全相联映像</code><br>全相联映像是指主存的每一页可以映像可以映像到Cache的任意一页。</li>
<li><code>组相联映像</code><br>组相联映像是直接映像与全相联映像的折中方案，它将Cache分为若干组，如8组；每组若干页，如2页；同时将主存分为若干组，如255组；每组内的页数与Cache的组数相同，如8页。组相联映像的规律是主存中的各页与Cache的组号有固定的映像关系，但可自由映像到对应的Cache组中的任意一页。即组间采用直接映像，而组内的页为全相联映像。</li>
</ol>
</li>
</ul>
</li>
<li><p>缓存更新机制<br>  当CPU访问Cache未命中时，应从主存中读取信息，同时写入Cache。若Cache未满，则直接写入；若Cache已满，则需要进行替换。替换机构由硬件组成，并按替换算法进行设计，其作用是指出替换的页号。常用的替换算法有<code>先进先出算法(FIFO)</code>和<code>近期最少使用算法(LRU)</code>。</p>
</li>
<li><p>缓存读/写操作</p>
</li>
</ul>
<ol>
<li><code>读操作</code><br>访存时，将主存地址同时送主存和Cache，一则启动对主存的读操作，二则在Cache中按映像方式从中获取Cache地址，并将主存标记与Cache标记比较：若相同，则访问命中，从Cache中读取数据。因为Cache速度比主存速度快，所以不等主存读操作结束，即可继续下一次访存操作；若不相同，则访问未命中，则从主存中读取数据，并考虑是否按某种替换算法更新Cache某页的内容。</li>
<li><code>写操作</code><br> 将数据写入主存有两种方法，<code>写回法</code>和<code>写直达法</code>。<br> <code>写回法</code>: 信息暂时只写入Cache，并用标志加以注明，直到该页内容需从Cache中替换出来时，才一次写入主存。优点是操作速度快，缺点是写回主存前，主存中没有这些内容，与Cache不一致，易造成错误。<br> <code>写直达法</code>: 信息在写入Cahce时也同时写入主存。优点是主存与Cache始终保持一致，但速度慢。</li>
</ol>
<p>目前已经存在很多高性能的缓存系统，比如Memcache，Redis等，尤其是Redis，现已经广泛用于各种Web服务中。既然有了这些功能完善的缓存系统，那为什么我们还需要自己实现一个缓存系统呢？这么做主要有两个原因，第一，通过动手实现我们可以了解缓存系统的工作原理，这也是老掉牙的理由了。第二，Redis 之类的缓存系统都是独立存在的，如果只是开发一个简单的应用还需要单独使用Redis服务器，难免会过于复杂。这时候如果有一个功能完善的软件包实现了这些功能，只需要引入这个软件包就能实现缓存功能，而不需要单独使用 Redis 服务器，就最好不过了。</p>
<h2 id="u7F13_u5B58_u7EC4_u4EF6_u8BBE_u8BA1"><a href="#u7F13_u5B58_u7EC4_u4EF6_u8BBE_u8BA1" class="headerlink" title="缓存组件设计"></a>缓存组件设计</h2><ul>
<li><p>缓存系统中，缓存的数据一般都存储在内存中，所以我们设计的缓存系统要以某一种方式管理内存中的数据。既然缓存数据是存储在内存中的，那如果系统停机，那数据岂不就丢失了吗？其实一般情况下，缓存系统还支持将内存中的数据写入到文件中，在系统再次启动时，再将文件中的数据加载到内存中，这样一来就算系统停机，缓存数据也不会丢失。</p>
</li>
<li><p>同时缓存系统还提供过期数据清理机制，也就是说缓存的数据项是有生存时间的，如果数据项过期，则数据项会从内存中被删除，这样一来热数据会一直存在，而冷数据则会被删除，也没有必要进行缓存。</p>
</li>
<li><p>缓存系统还需要对外提供操作的接口，这样系统的其他组件才能使用缓存。一般情况下，缓存系统需要支持<code>CRUD操作</code>，即创建(添加)，读取，更新和删除操作。</p>
<p>通过以上分析，可以总结出缓存系统需要有以下功能：</p>
<ol>
<li>缓存数据的存储;</li>
<li>过期数据项管理;</li>
<li>内存数据导出/导入;</li>
<li>提供CRUD接口. </li>
</ol>
</li>
</ul>
<h2 id="u7F13_u5B58_u7EC4_u4EF6_u5B9E_u73B0"><a href="#u7F13_u5B58_u7EC4_u4EF6_u5B9E_u73B0" class="headerlink" title="缓存组件实现"></a>缓存组件实现</h2><p>缓存数据需要存储在内存中，这样才可以被快速访问。那使用什么数据结构来存储数据项呢？一般情况下，我们使用哈希表来存储数据项，这样访问数据项将获得更好的性能。在golang语言中内建类型map已经实现了哈希表，所以可以直接将缓存数据项存储在map中。同时由于缓存系统需要支持过期数据清理，所以缓存数据项应该带有生存时间，这说明需要将缓存数据进行封装后，保存到缓存系统中。这样我们就需要先实现缓存数据项，其实现的代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    Object     <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 真正的数据项</span></span><br><span class="line">    Expiration <span class="typename">int64</span>       <span class="comment">// 生存时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数据项是否已经过期</span></span><br><span class="line"><span class="keyword">func</span> (item Item) Expired() <span class="typename">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> item.Expiration == <span class="number">0</span> &#123;</span><br><span class="line">	   <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Now().UnixNano() &gt; item.Expiration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>Item</code>结构中， <ul>
<li><code>Object</code>: 用于存储任意类型的数据对象;</li>
<li><code>Expiration</code>: 字段则存储了该数据项的过期时间;</li>
<li><code>Expired()</code>方法: 用于检测当前缓存数据项是否过期，返回<code>false</code>表示过期, 其中数据项的过期时间，是<code>Unix时间戳</code>，单位是纳秒; 用<code>time</code>包实现一个<code>ticker</code>定期检查每一项数据项，如果发现数据项的过期时间小于当前时间，则调用删除方法将数据项从缓存系统中删除.</li>
</ul>
</li>
</ul>
<p>现在来设计实现缓存组件的结构， 代码如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 没有过期时间标志</span></span><br><span class="line">    NoExpiration time.Duration = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的过期时间</span></span><br><span class="line">    DefaultExpiration time.Duration = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    defaultExpiration time.Duration</span><br><span class="line">    items             <span class="keyword">map</span>[<span class="typename">string</span>]Item <span class="comment">// 缓存数据项存储在 map 中</span></span><br><span class="line">    mu                sync.RWMutex    <span class="comment">// 读写锁</span></span><br><span class="line">    gcInterval        time.Duration   <span class="comment">// 过期数据项清理周期</span></span><br><span class="line">    stopGc            <span class="keyword">chan</span> <span class="typename">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过期缓存数据项清理</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) gcLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(c.gcInterval)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            c.DeleteExpired()</span><br><span class="line">        <span class="keyword">case</span> &lt;-c.stopGc:</span><br><span class="line">            ticker.Stop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ 删除缓存数据项</span><br><span class="line"><span class="keyword">func</span> (c *Cache) del(k <span class="typename">string</span>) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(c.items, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除过期数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) DeleteExpired() &#123;</span><br><span class="line">    now := time.Now().UnixNano()</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> c.items &#123;</span><br><span class="line">        <span class="keyword">if</span> v.Expiration &gt; <span class="number">0</span> &amp;&amp; now &gt; v.Expiration &#123;</span><br><span class="line">            c.del(k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>缓存组件结构<code>Cache</code>，<ul>
<li><code>NoExpiration</code>: 表示数据项永远不过期;</li>
<li><code>DefaultExpiration</code>: 后者表示数据项默认过期时间;</li>
<li><code>items</code>: 是一个<code>map</code>，用于存储缓存数据项;</li>
<li><code>mu</code>: 读写锁， 为保证缓存读写数据一致性，在相应操作前应加锁;</li>
<li><code>gcInterval</code>: 表示隔多久清理一次过期缓存数据;</li>
<li><code>gcLoop()方法</code>: 该方通过time.Ticker 定期执行<code>DeleteExpired()</code>方法，从而清理过期的数据项;通过监听c.stopGc通道，在必要的时候安全结束<code>gcLoop()</code>; </li>
</ul>
</li>
</ul>
<p>通过实现<code>Set</code>和<code>Add</code>方法向缓存系统中添加数据， 通过实现<code>Get</code>方法获取缓存数据,实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置缓存数据项，如果数据项存在则覆盖</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Set(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) &#123;</span><br><span class="line">	<span class="comment">//已省略添加过期时间逻辑</span></span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    c.items[k] = Item&#123;</span><br><span class="line">        Object:     v,</span><br><span class="line">        Expiration: e,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据项, 没有锁操作</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) set(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) &#123;</span><br><span class="line">	<span class="comment">// to-do    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据项，如果找到数据项，还需要判断数据项是否已经过期</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) get(k <span class="typename">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="typename">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// to-do</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据项，如果数据项已经存在，则返回错误</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Add(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) error &#123;</span><br><span class="line">	<span class="comment">// to-do</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Get(k <span class="typename">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="typename">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// to-do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Set()与Add()的主要区别在于Set()方法将数据添加到缓存系统中时，如果数据项已经存在则会覆盖，而后者如果发现数据项已经存在则会发生报错，这样能避免缓存被错误的覆盖;</li>
<li>通过Set(), Add()和Get()来写入/读取缓存数据时，应注意加锁保证数据操作的一致性。</li>
</ul>
<p>除了向缓存系统中写入/读取缓存数据以外，还需要实现更新和删除缓存数据， 实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换一个存在的数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Replace(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) error &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    _, found := c.get(k)</span><br><span class="line">    <span class="keyword">if</span> !found &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Item %s doesn't exist"</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line">    c.set(k, v, d)</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Delete(k <span class="typename">string</span>) &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.del(k)</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了是缓存数据在重启程序或系统后依然存在，则应将缓存数据持久化处理，本文方案提供将缓存数据写入本地文件的持久化操作，具体实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将缓存数据项写入到 io.Writer 中</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Save(w io.Writer) (err error) &#123;</span><br><span class="line">    enc := gob.NewEncoder(w)</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"Error registering item types with Gob library"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> c.items &#123;</span><br><span class="line">        gob.Register(v.Object)</span><br><span class="line">    &#125;</span><br><span class="line">    err = enc.Encode(&amp;c.items)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据项到文件中</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) SaveToFile(file <span class="typename">string</span>) error &#123;</span><br><span class="line">    f, err := os.Create(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = c.Save(f); err != <span class="constant">nil</span> &#123;</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 io.Reader 中读取数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Load(r io.Reader) error &#123;</span><br><span class="line">    dec := gob.NewDecoder(r)</span><br><span class="line">    items := <span class="keyword">map</span>[<span class="typename">string</span>]Item&#123;&#125;</span><br><span class="line">    err := dec.Decode(&amp;items)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="constant">nil</span> &#123;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> items &#123;</span><br><span class="line">            ov, found := c.items[k]</span><br><span class="line">            <span class="keyword">if</span> !found || ov.Expired() &#123;</span><br><span class="line">                c.items[k] = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中加载缓存数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) LoadFile(file <span class="typename">string</span>) error &#123;</span><br><span class="line">    f, err := os.Open(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = c.Load(f); err != <span class="constant">nil</span> &#123;</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Save()</code>通过<code>gob</code>模块将二进制缓存数据转码写入到实现了io.Writer 接口的对象中;</li>
<li><code>Load()</code>则从<code>io.Reader</code>中读取二进制数据，然后通过<code>gob</code>模块将数据进行反序列化;</li>
<li><code>SaveToFile</code>和<code>LoadFile</code>则向指定的文件中写入和读取缓存数据.</li>
</ul>
<p>至此整个缓存系统基本实现，支持数据对象添加，删除，替换，和查询操作，同时还支持过期数据的删除。<br><a href="/">github-完整代码示例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;总结用golang从分析，设计到实现一个可用的缓存组件。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="cache" scheme="http://www.grdtechs.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>UML类图中符号定义,作用及区别总结</title>
    <link href="http://www.grdtechs.com/2016/11/23/uml-symbol-desc/"/>
    <id>http://www.grdtechs.com/2016/11/23/uml-symbol-desc/</id>
    <published>2016-11-23T11:47:43.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在UML的定义中，描述类和对象之间的关系，包括以下几种方式：依赖（<code>Dependency</code>）、关联（<code>Association</code>）、聚合（<code>Aggregation</code>）、组合（<code>Composition</code>）、泛化（<code>Generalization</code>）和实现（<code>Realization</code>）。现分别说明如下：<br><a id="more"></a></p>
<h2 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h2><p>类图基本符号可拆分为四类:<code>线</code>(<code>虚线</code>和<code>实线</code>)，<code>箭头</code>，<code>三角</code>(<code>空心右三角</code>和<code>实心右三角</code>)，<code>菱形</code>(<code>空心菱形</code>和<code>实心菱形</code>); 由这些基本的图形进行组合构成了类图的基本符号。这里要注意这几个符号的顺序，代表了类与类之间关系的耦合程度, 越向右耦合度越高。</p>
<p>由上述四类图形（<code>线</code>，<code>箭头</code>,<code>三角</code>,<code>菱形</code>)可构成以下类图中六类常用关系,</p>
<ol>
<li><code>虚线+箭头</code>是表示即<code>依赖</code>的关系;</li>
<li><code>实线+箭头</code>表示<code>关联</code>的关系;</li>
<li><code>虚线+空心右三角</code>表示<code>实现</code>接口;</li>
<li><code>实线+空心右三角</code>表示的是<code>泛化</code>，即<code>类的继承关系</code>;</li>
<li><code>实线+空心菱形</code>表示的是<code>聚合</code>的关系;</li>
<li><code>实线+实心菱形</code>则表示<code>组合</code>的关系。</li>
</ol>
<p>看类图的时候要注意, 类图的思想其实也还没有脱离面向对象的思想，以某个类为中心，有些线是射入的而有些线是射出的。射入的线表示的是这个类被哪些类所调用而射出的线则表示该类调用了哪些类，包括泛化，关联，依赖，聚合和组合四种关系。这类似于离散数学中有关图部分的描述。</p>
<ul>
<li>类(Class):使用三层矩形框表示<ol>
<li>第一层显示类的名称，如果是抽象类，则就用斜体显示;</li>
<li>第二层是字段和属性;</li>
<li>第三层是类的方法。 </li>
</ol>
</li>
</ul>
<blockquote>
<p>注意前面的符号，<code>+</code>表示public，<code>-</code>表示private，<code>#</code>表示protected, <code>~</code>表示package</p>
</blockquote>
<ul>
<li><p>接口:使用两层矩形框表示，与类图的区别主要是顶端有<code>&lt;&lt;interface&gt;&gt;</code>显示 </p>
<ol>
<li>第一行是接口名称; </li>
<li>第二行是接口方法。 </li>
</ol>
</li>
<li><p>继承类(extends):用空心三角形+实线来表示 </p>
</li>
<li><p>实现接口(implements):用空心三角形+虚线来表示 </p>
</li>
<li><p>关联(Association):用实线箭头来表示，例如:燕子与气候 </p>
</li>
<li><p>聚合(Aggregation):用空心的菱形+实线箭头来表示 </p>
<ol>
<li>聚合:表示一种弱的<code>拥有</code>关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，例如:公司和员工</li>
</ol>
</li>
<li><p>组合(Composition):用实心的菱形+实线箭头来表示 </p>
<ol>
<li>组合:部分和整体的关系，并且生命周期是相同的。例如:人与手 </li>
</ol>
</li>
<li><p>依赖(Dependency):用虚线箭头来表示，例如:动物与氧气 </p>
</li>
<li><p>基数:连线两端的数字表明这一端的类可以有几个实例，比如:一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用<code>n</code>来表示。关联、聚合、组合是有基数的</p>
</li>
</ul>
<p>下面详细阐述类图中六类常用关系,</p>
<h2 id="u4F9D_u8D56_uFF08Dependency_uFF09"><a href="#u4F9D_u8D56_uFF08Dependency_uFF09" class="headerlink" title="依赖（Dependency）"></a>依赖（<code>Dependency</code>）</h2><p>在uml中，<code>依赖</code>表示为<code>带箭头的虚线</code>，<code>箭头指向被依赖的元素</code>。是类与类之间的连接，表示为一个类依赖于另一个类的定义，其中一个类的变化将影响另一个类。依赖总是单向的，不应该存在双向依赖，这一点要特别注意。更具体的说，依赖可以理解为：<code>一个类（A）对不在其实例作用域内的另一个类或对象（B）的任何类型的引用</code>。大致包含以下几种情况：<br>（1）局部变量；<br>（2）方法的参数；<br>（3）静态方法的调用；</p>
<p>下面是依赖关系的uml示意图：<br><img src="/imgs/uml_dependency.png" alt="uml-dependency"></p>
<blockquote>
<p>1.综合上图，Class-A类的实现依赖Class-B类，即Class-A类可能要用到Class-B类的一些方法，即，要完成Class-A里的所有功能，一定要有Class-B类的某些方法协助才行.</p>
</blockquote>
<h2 id="u5173_u8054_uFF08Association_uFF09"><a href="#u5173_u8054_uFF08Association_uFF09" class="headerlink" title="关联（Association）"></a>关联（<code>Association</code>）</h2><p>在uml中，<code>关联</code>表示为<code>带箭头的实线</code>。关联可以是单向的，也可以是双向的, 还有自身关联是指拥有一个自身的引用。如果是双向关联，则可以表示为双向箭头，或者没有箭头,双向关联是指双方都拥有对方的引用, 都可以调用对方的公共属性和方法。一般来说，系统设计应表现为单向关联，这样利于维护。一个关联可以附加<code>多重性</code>的修饰符，表示两个类之间的数量关系。关联可以理解为：<code>一个类（A）持有另一个类或对象（B）</code>。具体表现为：</p>
<p>下面是关联关系的uml示例图：<br><img src="/imgs/uml_association.png" alt="uml-association"></p>
<blockquote>
<p>1.上面的关联表示，一个Employee持有(has)0个或多个TimeCard，从而可以调用其中的属性或方法，但Employee与TimeCard之间没有生命期的依赖。</p>
</blockquote>
<h2 id="u805A_u5408_uFF08Aggregation_uFF09"><a href="#u805A_u5408_uFF08Aggregation_uFF09" class="headerlink" title="聚合（Aggregation）"></a>聚合（<code>Aggregation</code>）</h2><p>在uml中，<code>聚合</code>表示为<code>空心的菱形箭头线</code>。<code>聚合关系</code>是关联关系的一种，表示一种<code>强</code>关联关系。对比<code>关联关系</code>，两个类是处于同一个层次的。而聚合关系，两个类处于不同的层次，强调了一个整体/局部的关系。例如一辆汽车有一个引擎，4个轮胎。在聚合关系中，体现了一种<code>弱拥有</code>的概念。也就是说，对象A拥有对象B，但B并不是A的组成部分。更具体的表现为，如果A由B聚合而成，则A包含B的全局对象，但B对象可以不在A对象创建时创建。回到前面的例子，汽车对象由轮胎对象聚合而成，但是轮胎对象的生命期并不受汽车对象的左右。当汽车对象销毁时，轮胎对象也可以单独存在！</p>
<p>下面是聚合关系的uml示意图：</p>
<p><img src="/imgs/uml_aggregation.png" alt="uml-aggregation"></p>
<blockquote>
<p>从代码上看，聚合和关联没有任何区别。这里仅仅体现一种概念上的含义。在创建ClassA的时候，不一定需要同时创建ClassB的实例。 表示ClassA由ClassB聚合而成，但ClassB可以独立存在。</p>
</blockquote>
<h2 id="u7EC4_u5408_uFF08Composition_uFF09"><a href="#u7EC4_u5408_uFF08Composition_uFF09" class="headerlink" title="组合（Composition）"></a>组合（<code>Composition</code>）</h2><p>在uml中，<code>组合</code>表示为<code>实心菱形箭头线</code>。组合也叫合成。合成关系强调了比聚合关系更加强的整体/部分的关联，例如人和四肢。和聚合关系所不同的是，在组合关系中，虽然局部不一定随着整体的销毁而销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。也就是说，组合关系中，局部的存活期一定是小于，最多是等于整体的存活期的。</p>
<p>下面是组合关系的uml示例图：</p>
<p><img src="/imgs/uml_composition.png" alt="uml-composition"> </p>
<h2 id="u6CDB_u5316_uFF08Generalization_uFF09"><a href="#u6CDB_u5316_uFF08Generalization_uFF09" class="headerlink" title="泛化（Generalization）"></a>泛化（<code>Generalization</code>）</h2><p><code>泛化也就是通常所谓的继承关系</code>，在uml中表示为一个<code>带空心三角的实线</code>。表示为is-a的关系，是对象间耦合度最大的一种关系，子类继承父类的所有细节，并可以在此基础上添加自己的特性。</p>
<p>下面是泛化关系的uml图：</p>
<p><img src="/imgs/uml_generalization.png" alt="uml-generalization"></p>
<h2 id="u5B9E_u73B0_uFF08Realization_uFF09"><a href="#u5B9E_u73B0_uFF08Realization_uFF09" class="headerlink" title="实现（Realization）"></a>实现（<code>Realization</code>）</h2><p>所谓<code>实现</code>就是<code>类对接口的定义实现</code>，表示类是接口所有特征和行为的实现。表现为<code>带箭头的虚线</code>。</p>
<p>下面的实现的uml图：</p>
<p><img src="/imgs/uml_realization.png" alt="uml-realization"></p>
<p>下面通过一副类图包含上述六类常用关系,</p>
<p><img src="/imgs/uml_all_class.png" alt="uml-all-class"></p>
<blockquote>
<ol>
<li>依赖: 动物依赖氧气，水.</li>
<li>关联: 当一个类知道另一个类时，可以用关联关系。现在企鹅需要知道气候的变化，了解气候的变化规律. </li>
<li>聚合: 雅群由单只大雅聚合而成，但是单只大雁可独立存在. </li>
<li>组合: 一只鸟包含两支翅膀,但是翅膀无法单独存活,即生命期在鸟的生命期内.</li>
<li>泛化: 泛化即继承,子类继承父类属性及方法,如大雁从鸟类继承而来.</li>
<li>实现: 类对接口的实现，如大雁类实现了飞翔接口的所有方法(飞),所以大雁类实现了飞翔这个接口.</li>
</ol>
<p>说明: 关联又可以分为聚合，组合，他们的主要区别体现在类和类之间关联的强度,聚合是一种较弱拥有的关联关系, 如雁群由单只大雁聚合而成，但不能强制要求单只大雁飞离雁群; 而组合是一种强拥有的聚合关系，如鸟有两支翅膀，但是单独把翅膀从鸟身上砍下来，它本身无法存活无法飞.</p>
</blockquote>
<h2 id="u5173_u8054_u53CA_u533A_u522B"><a href="#u5173_u8054_u53CA_u533A_u522B" class="headerlink" title="关联及区别"></a>关联及区别</h2><p>面向对象建模依赖、关联、聚合以及组合关系区别,</p>
<ol>
<li>语义<ul>
<li>依赖表达 <code>use a</code></li>
<li>关联表达 <code>has a</code></li>
<li>聚合表达 <code>owns a</code></li>
<li>组合表达 <code>is a part of</code></li>
</ul>
</li>
<li>四种联系是递进的，表示对象之间的联系越来越紧密</li>
<li>代码实现形式<ul>
<li><code>依赖</code>：一般对应局部变量，方法形参，静态方法调用表达</li>
<li><code>关联</code>：一般对应成员变量，有时也用方法形参的形式</li>
<li><code>聚合</code>：一般对应成员变量，聚合关系一般使用setter方法给成员变量赋值</li>
<li><code>组合</code>：一般来说，为了表示组合关系，常常会使用构造方法来达到初始化的目的</li>
</ul>
</li>
</ol>
<p>另一篇值得参考的文章:  <a href="http://www.jasongj.com/uml/class_diagram/" target="_blank" rel="external">UML(一) 类图详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在UML的定义中，描述类和对象之间的关系，包括以下几种方式：依赖（&lt;code&gt;Dependency&lt;/code&gt;）、关联（&lt;code&gt;Association&lt;/code&gt;）、聚合（&lt;code&gt;Aggregation&lt;/code&gt;）、组合（&lt;code&gt;Composition&lt;/code&gt;）、泛化（&lt;code&gt;Generalization&lt;/code&gt;）和实现（&lt;code&gt;Realization&lt;/code&gt;）。现分别说明如下：&lt;br&gt;
    
    </summary>
    
      <category term="go-pattern" scheme="http://www.grdtechs.com/categories/go-pattern/"/>
    
    
      <category term="uml" scheme="http://www.grdtechs.com/tags/uml/"/>
    
  </entry>
  
  <entry>
    <title>golang处理数据表中字段为空或NULL的情况</title>
    <link href="http://www.grdtechs.com/2016/11/23/go-dealwith-database-nullvalue/"/>
    <id>http://www.grdtechs.com/2016/11/23/go-dealwith-database-nullvalue/</id>
    <published>2016-11-23T11:40:54.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang是强类型语言，在赋值和解析过程中需要先定义好数据类型，否在会报类型错误，下面总结在处理数据库表时遇到字段为空或零值的情况<br><a id="more"></a></p>
<h2 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h2><p>假如存在如下没有指定<code>not null</code>的场合<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"users"</span> (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">serial</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="string">"name"</span> <span class="built_in">text</span>,</span><br><span class="line">    <span class="string">"age"</span> <span class="built_in">integer</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<p>在<a href="https://github.com/researchlab/gorp" target="_blank" rel="external">gorp</a>中<code>insert</code>插入场合，可以直接赋零值即可，很方便.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbmap.Insert(</span><br><span class="line"> &amp;User&#123;Name: <span class="string">"John"</span>, Age: <span class="number">0</span>&#125;,　<span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"John" 2:0]</span></span><br><span class="line"> &amp;User&#123;Name: <span class="string">"John"</span>&#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"John" 2:0]</span></span><br><span class="line"> &amp;User&#123;Name: <span class="string">""</span>, Age: <span class="number">8</span>&#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"" 2:8]</span></span><br><span class="line"> &amp;User&#123;Age: <span class="number">30</span>&#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"" 2:30]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>在使用golang中零值与空值和NULL是不同的数据类型和值，需要加以判断，在数据库表中的NULL值字段可以用<code>database/sql</code>数据包中提供的<code>sql.NullString</code>，<code>sql.NullBool</code>等值类型进行判断后加以使用.</p>
<h2 id="u5982_u4F55_u4F7F_u7528"><a href="#u5982_u4F55_u4F7F_u7528" class="headerlink" title="如何使用"></a>如何使用</h2><p>可能存在NULL值的数据类型可以使用<code>sql.NullString</code>或<code>sql.NullBool</code>等来指定其类型.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Id <span class="typename">int</span> <span class="string">`db:id`</span></span><br><span class="line">    Name sql.NullString <span class="string">`db:name`</span></span><br><span class="line">    Age sql.NullInt64 <span class="string">`db:age`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>sql.NullString</code>，它的结构如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NullString <span class="keyword">struct</span> &#123;</span><br><span class="line">    String <span class="typename">string</span> </span><br><span class="line">    Valid  <span class="typename">bool</span> <span class="comment">// Valid is true if String is not NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>借助<code>.sql.NullString</code>这样的结构体就可以在<code>insert</code>时，通过设置<code>Valid</code>的值为<code>fasle</code>就可以表示此值为<code>null</code>值，这样在读取时如果为<code>false</code>就可以肯定此值为默认的空值了，具体操作如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbmap.Insert(</span><br><span class="line">    &amp;User&#123;</span><br><span class="line">      Name: sql.NullString&#123;<span class="string">"Mike"</span>, <span class="constant">true</span>&#125;,</span><br><span class="line">      Age: sql.NullInt64&#123;<span class="number">0</span>, <span class="constant">true</span>&#125;,</span><br><span class="line">    &#125;, <span class="comment">//  insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"Mike" 2:0]</span></span><br><span class="line">    &amp;User&#123;</span><br><span class="line">      Name: sql.NullString&#123;<span class="string">""</span>, <span class="constant">false</span>&#125;,</span><br><span class="line">      Age: sql.NullInt64&#123;<span class="number">30</span>, <span class="constant">true</span>&#125;,</span><br><span class="line">    &#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:&lt;nil&gt; 2:30]</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>读取数据时，可以根据<code>valid</code>的值判断是否为设置的零值还是未被赋值操作.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">dbmap.Insert(</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">"Mike"</span>, <span class="constant">true</span>&#125;, Age: sql.NullInt64&#123;<span class="number">0</span>, <span class="constant">true</span>&#125;&#125;,</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">"John"</span>, <span class="constant">true</span>&#125;, Age: sql.NullInt64&#123;<span class="number">0</span>, <span class="constant">false</span>&#125;&#125;,</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">"John"</span>, <span class="constant">true</span>&#125;, Age: sql.NullInt64&#123;<span class="number">8</span>, <span class="constant">true</span>&#125;&#125;,</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">""</span>, <span class="constant">false</span>&#125;, Age: sql.NullInt64&#123;<span class="number">30</span>, <span class="constant">true</span>&#125;&#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  users := []User&#123;&#125;</span><br><span class="line">  _, err := dbmap.Select(&amp;users, <span class="string">"select * from users"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">    spew.Dump(user)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 1,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) (len=4) "Mike",</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 0,</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 2,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) (len=4) "John",</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 0,</span><br><span class="line">  Valid: (bool) false</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 3,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) (len=4) "John",</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 8,</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 4,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) "",</span><br><span class="line">  Valid: (bool) false</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 30,</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>在单次查询中根据<code>valid</code>的值作相应的零值判断处理, 方法如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s NullString</span><br><span class="line">err := db.QueryRow(<span class="string">"SELECT name FROM foo WHERE id=?"</span>, id).Scan(&amp;s)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> s.Valid &#123;</span><br><span class="line">   <span class="comment">// use s.String</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// NULL value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang是强类型语言，在赋值和解析过程中需要先定义好数据类型，否在会报类型错误，下面总结在处理数据库表时遇到字段为空或零值的情况&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang操作mysql使用总结</title>
    <link href="http://www.grdtechs.com/2016/11/11/go-use-mysql/"/>
    <id>http://www.grdtechs.com/2016/11/11/go-use-mysql/</id>
    <published>2016-11-11T13:21:16.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Golang 提供了<code>database/sql</code>包用于对<code>SQL数据库</code>的访问, 作为操作数据库的入口对象<code>sql.DB</code>, 主要为我们提供了两个重要的功能:<br><a id="more"></a></p>
<ul>
<li>sql.DB 通过数据库驱动为我们提供管理底层数据库连接的打开和关闭操作.</li>
<li>sql.DB 为我们管理数据库连接池</li>
</ul>
<p>需要注意的是，sql.DB表示操作数据库的抽象访问接口,而非一个数据库连接对象;正因为 sql.DB 是以连接池的方式管理数据库连接, 每次进行数据库操作时, 都需要从连接池中取出一个连接, 当操作任务完成时就需要将此连接返回到连接池中, 如果没有正确地将连接返回给连接池, 那么会造成<code>db.SQL</code>打开过多的数据库连接, 使数据库连接资源耗尽.</p>
<h2 id="u64CD_u4F5Cmysql"><a href="#u64CD_u4F5Cmysql" class="headerlink" title="操作mysql"></a>操作mysql</h2><p><strong>1.导入mysql数据库驱动</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通常来说, 不应该直接使用驱动所提供的方法, 而是应该使用 sql.DB, 因此在导入 mysql 驱动时, 这里使用了匿名导入的方式(在包路径前添加 _), 当导入了一个数据库驱动后, 此驱动会自行初始化并注册自己到Golang的database/sql上下文中, 因此我们就可以通过 database/sql 包提供的方法访问数据库了.</p>
</blockquote>
<p><strong>2.连接数据库</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> DbWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//mysql data source name</span></span><br><span class="line">    Dsn <span class="typename">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    dbw := DbWorker&#123;</span><br><span class="line">        Dsn: <span class="string">"user:password@tcp(127.0.0.1:3306)/test"</span>,</span><br><span class="line">    &#125;	</span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>,</span><br><span class="line">        dbw.Dsn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过sql.Open函数创建一个数据库抽象操作接口, 创建成功则返回一个<code>sql.DB指针</code>; sql.Open函数原型如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> Open(driverName, dataSourceName <span class="typename">string</span>) (*DB, error)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>driverName</code>: 使用的驱动名. 这个名字其实就是数据库驱动注册到 database/sql 时所使用的名字.</li>
<li><code>dataSourceName</code>:  数据库连接信息，这个连接包含了数据库的用户名, 密码, 数据库主机以及需要连接的数据库名等信息.</li>
</ul>
<blockquote>
<ol>
<li>sql.Open并不会立即建立一个数据库的网络连接, 也不会对数据库链接参数的合法性做检验, 它仅仅是初始化一个sql.DB对象. 当真正进行第一次数据库查询操作时, 此时才会真正建立网络连接; </li>
<li>如果想立即检查数据库连接是否可用, 那么可以利用sql.DB的Ping方法; </li>
<li>sql.Open返回的sql.DB对象是协程并发安全的.</li>
</ol>
</blockquote>
<p><strong>3.数据库查询</strong></p>
<p>数据库查询的一般步骤如下:</p>
<ol>
<li>调用 db.Query 执行 SQL 语句, 此方法会返回一个 Rows 作为查询的结果</li>
<li>通过 rows.Next() 迭代查询数据.</li>
<li>通过 rows.Scan() 读取每一行的值</li>
<li>调用 db.Close() 关闭查询</li>
</ol>
<p>现有<code>user</code>数据库表如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<font color="red">MySQL 5.5 之前， UTF8 编码只支持1-3个字节,从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，utf8mb4兼容utf8，所以能支持更多的字符集;关于emoji表情的话mysql的utf8是不支持，需要修改设置为utf8mb4，才能支持。</font>

</blockquote>
</blockquote>
<p>插入数据<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (dbw *DbWorker) insertData() &#123;</span><br><span class="line">	ret, err := dbw.Db.Exec(<span class="string">`INSERT INTO user (name, age) VALUES ("xys", 23)`</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> LastInsertId, err := ret.LastInsertId(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"LastInsertId:"</span>, LastInsertId)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> RowsAffected, err := ret.RowsAffected(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"RowsAffected:"</span>, RowsAffected)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>db.Exec()</code>插入数据，通过返回的<code>err</code>可知插入失败的原因，通过返回的<code>ret</code>可以进一步查询本次插入数据影响的行数<code>RowsAffected</code>和最后插入的Id(如果数据库支持查询最后插入Id).</p>
<p>读取数据<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (dbw *DbWorker) QueryData() &#123;</span><br><span class="line">	dbw.QueryDataPre()</span><br><span class="line">	rows, err := dbw.Db.Query(<span class="string">`SELECT * From user where age &gt;= 20 AND age &lt; 30`</span>)</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			fmt.Printf(err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Name.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Name.String = <span class="string">""</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Age.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Age.Int64 = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"get data, id: "</span>, dbw.UserInfo.Id, <span class="string">" name: "</span>, dbw.UserInfo.Name.String, <span class="string">" age: "</span>, <span class="typename">int</span>(dbw.UserInfo.Age.Int64))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rows.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>rows.Scan 参数的顺序很重要, 需要和查询的结果的column对应. 例如 “SELECT * From user where age &gt;=20 AND age &lt; 30” 查询的行的 column 顺序是 “id, name, age” 和插入操作顺序相同, 因此 rows.Scan 也需要按照此顺序 rows.Scan(&amp;id, &amp;name, &amp;age), 不然会造成数据读取的错位.</li>
<li>因为golang是强类型语言，所以查询数据时先定义数据类型，但是查询数据库中的数据存在三种可能:存在值，存在零值，未赋值NULL 三种状态, 因为可以将待查询的数据类型定义为sql.Nullxxx类型，可以通过判断Valid值来判断查询到的值是否为赋值状态还是未赋值NULL状态.</li>
<li>每次db.Query操作后, 都建议调用rows.Close(). 因为 db.Query() 会从数据库连接池中获取一个连接, 如果我们没有调用 rows.Close(), 则此连接会一直被占用. 因此通常我们使用 defer rows.Close() 来确保数据库连接可以正确放回到连接池中; 不过阅读源码发现当rows.Next()没有数据返回时会自动调用Close()方法关闭rows, 不过rows.Close()操作是幂等操作，即一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同.</li>
</ol>
</blockquote>
<p><a href="https://github.com/researchlab/golearning/blob/master/sql/sql.go" target="_blank" rel="external">github完整代码示例</a></p>
<p><strong>4.预编译语句(Prepared Statement)</strong><br>预编译语句(PreparedStatement)提供了诸多好处, 因此我们在开发中尽量使用它. 下面列出了使用预编译语句所提供的功能:</p>
<ul>
<li>PreparedStatement 可以实现自定义参数的查询</li>
<li>PreparedStatement 通常来说, 比手动拼接字符串 SQL 语句高效.</li>
<li>PreparedStatement 可以防止SQL注入攻击</li>
</ul>
<p>下面是将上述案例用Prepared Statement 修改之后的完整代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DbWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">	Dsn      <span class="typename">string</span></span><br><span class="line">	Db       *sql.DB</span><br><span class="line">	UserInfo userTB</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> userTB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="typename">int</span></span><br><span class="line">	Name sql.NullString</span><br><span class="line">	Age  sql.NullInt64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	dbw := DbWorker&#123;</span><br><span class="line">		Dsn: <span class="string">"root:123456@tcp(localhost:3306)/sqlx_db?charset=utf8mb4"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	dbw.Db, err = sql.Open(<span class="string">"mysql"</span>, dbw.Dsn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dbw.Db.Close()</span><br><span class="line"></span><br><span class="line">	dbw.insertData()</span><br><span class="line">	dbw.queryData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (dbw *DbWorker) insertData() &#123;</span><br><span class="line">	stmt, _ := dbw.Db.Prepare(<span class="string">`INSERT INTO user (name, age) VALUES (?, ?)`</span>)</span><br><span class="line">	<span class="keyword">defer</span> stmt.Close()</span><br><span class="line"></span><br><span class="line">	ret, err := stmt.Exec(<span class="string">"xys"</span>, <span class="number">23</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> LastInsertId, err := ret.LastInsertId(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"LastInsertId:"</span>, LastInsertId)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> RowsAffected, err := ret.RowsAffected(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"RowsAffected:"</span>, RowsAffected)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (dbw *DbWorker) QueryDataPre() &#123;</span><br><span class="line">	dbw.UserInfo = userTB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (dbw *DbWorker) queryData() &#123;</span><br><span class="line">	stmt, _ := dbw.Db.Prepare(<span class="string">`SELECT * From user where age &gt;= ? AND age &lt; ?`</span>)</span><br><span class="line">	<span class="keyword">defer</span> stmt.Close()</span><br><span class="line"></span><br><span class="line">	dbw.QueryDataPre()</span><br><span class="line"></span><br><span class="line">	rows, err := stmt.Query(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			fmt.Printf(err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Name.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Name.String = <span class="string">""</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Age.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Age.Int64 = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"get data, id: "</span>, dbw.UserInfo.Id, <span class="string">" name: "</span>, dbw.UserInfo.Name.String, <span class="string">" age: "</span>, <span class="typename">int</span>(dbw.UserInfo.Age.Int64))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rows.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<font color="red">db.Prepare()返回的statement使用完之后需要手动关闭，即defer stmt.Close()</font>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Golang 提供了&lt;code&gt;database/sql&lt;/code&gt;包用于对&lt;code&gt;SQL数据库&lt;/code&gt;的访问, 作为操作数据库的入口对象&lt;code&gt;sql.DB&lt;/code&gt;, 主要为我们提供了两个重要的功能:&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="mysql" scheme="http://www.grdtechs.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go编译生成更小的执行程序</title>
    <link href="http://www.grdtechs.com/2016/10/23/go-build-small-exec/"/>
    <id>http://www.grdtechs.com/2016/10/23/go-build-small-exec/</id>
    <published>2016-10-23T14:00:32.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>尽管go1.7.3编译生成的可执行程序已经很小了,但是通过编译参数控制还能编译出更小的可执行文件，总结如下,<br><a id="more"></a></p>
<h2 id="u52A0-ldflags_u53C2_u6570"><a href="#u52A0-ldflags_u53C2_u6570" class="headerlink" title="加-ldflags参数"></a>加-ldflags参数</h2><p>在程序编译的时候可以加上<code>-ldflags &quot;-s -w&quot;</code> 参数来优化编译程序, 其实通过去除部分连接和调试等信息来使得编译之后的执行程序更小,具体参数如下:</p>
<ul>
<li><code>-a</code> 强制编译所有依赖包</li>
<li><code>-s</code> 去掉符号表信息, panic时候的stack trace就没有任何文件名/行号信息了.</li>
<li><code>-w</code> 去掉DWARF调试信息，得到的程序就不能用gdb调试了</li>
</ul>
<p>如执行如下命令可得到优化编译过的<code>test</code>可执行程序:4.8M</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -ldflags -w test.go</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不建议s和w同时使用。</p>
</blockquote>
<h2 id="u4F7F_u7528upx"><a href="#u4F7F_u7528upx" class="headerlink" title="使用upx"></a>使用upx</h2><p>上面golang build 时加上<code>-ldflags</code>参数得到了比较小的可执行程序， 但是还可以通过<code>upx</code>这个开源，绿色，好用的压缩工具进行进一步压缩，首先其下载地址:<a href="http://upx.sourceforge.net/#downloadupx" target="_blank" rel="external">http://upx.sourceforge.net/#downloadupx</a></p>
<p>linux 系统选择下载:<code>upx-3.91-amd64_linux.tar.bz2</code> 即可, 然后 <code>tar -xvf upx-3.91-amd64_linux.tar.bz2</code> 进入到解压文件夹中将可执行文件<code>upx</code> 拷贝到<code>/usr/bin</code>就可以全局执行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv upx /usr/bin</span><br><span class="line">➜  <span class="built_in">test</span> git:(master) ✗ upx -<span class="number">9</span> -k <span class="built_in">test</span> </span><br><span class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</span><br><span class="line">                          Copyright (C) <span class="number">1996</span> - <span class="number">2013</span></span><br><span class="line">UPX <span class="number">3.91</span>        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep <span class="number">30</span>th <span class="number">2013</span></span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">   <span class="number">5024059</span> -&gt;   <span class="number">1552060</span>   <span class="number">30.89</span>%  linux/ElfAMD   <span class="built_in">test</span> </span><br><span class="line"></span><br><span class="line">Packed <span class="number">1</span> file.</span><br></pre></td></tr></table></figure></p>
<p>可以看到通过<code>upx</code>进一步压缩之后得到的程序大约只有1.5M了， 压缩比率达到了<code>30.89%</code>.<br>其中<code>-k</code>参数表示保留备份文件， <code>-9</code>代表最优压缩，<code>upx</code>总共有9档压缩,从<code>1</code>到<code>9</code> 其中 <code>-1</code>压缩速度最快.</p>
<p>再来看看下面编译之后的效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build test.go ---&gt; 得到的 <span class="built_in">test</span>  大约<span class="number">6.5</span>MB </span><br><span class="line">$ go build -ldflags -w ---&gt; 得到的 <span class="built_in">test</span> 大约<span class="number">4.8</span>MB</span><br><span class="line">$ upx -<span class="number">9</span> <span class="built_in">test</span>  ---&gt; 得到的 <span class="built_in">test</span> 大约 <span class="number">1.5</span>MB</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;尽管go1.7.3编译生成的可执行程序已经很小了,但是通过编译参数控制还能编译出更小的可执行文件，总结如下,&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mac vim7.3 升级到vim8.0</title>
    <link href="http://www.grdtechs.com/2016/10/16/mac-update-vim8-0/"/>
    <id>http://www.grdtechs.com/2016/10/16/mac-update-vim8-0/</id>
    <published>2016-10-16T23:08:56.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>将mac自带的vim7.3 升级到vim8.0<br><a id="more"></a></p>
<h2 id="u5347_u7EA7vim8-0"><a href="#u5347_u7EA7vim8-0" class="headerlink" title="升级vim8.0"></a>升级vim8.0</h2><ul>
<li><p>升级终端用得vim </p>
<blockquote>
<p>brew install vim –with-lua –with-override-system-vi</p>
</blockquote>
</li>
<li><p>升级GUI版本的vim</p>
<blockquote>
<p>brew install macvim –with-lua –with-override-system-vim</p>
</blockquote>
</li>
</ul>
<h2 id="brew_install__u4E0B_u8F7D_u6162"><a href="#brew_install__u4E0B_u8F7D_u6162" class="headerlink" title="brew install 下载慢"></a>brew install 下载慢</h2><p>用<code>brew install</code>发现下载vim8.0很慢， 解决方案是先去浏览器或用<code>wget</code>等其它方式下载好要安装的包，然后替换掉<code>brew cache</code>下的包即可。具体操作：</p>
<ul>
<li>找<code>brew cache</code> 目录<blockquote>
<p>brew cache<br>/Users/lihong/Library/Cache/Homebrew</p>
</blockquote>
</li>
</ul>
<p>可以看到上述目录中已经有一个<code>vim-8.00041.tar.gz.incomplete</code> 文件了， 将自己下载好的安装包也修改为和这个未完成文件的文件名一样，如修改为<code>vim-8.00041.tar.gz</code>. 然后,</p>
<blockquote>
<p>brew install vim –with-lua –with-override-system-vi</p>
</blockquote>
<ul>
<li><p>mac vim8.0 具体安装信息如下: </p>
<ul>
<li><p>install </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➜  ~ brew install vim --with-lua --with-override-system-vi</span><br><span class="line">==&gt; Using the sandbox</span><br><span class="line">==&gt; Downloading https://github.com/vim/vim/archive/v8.<span class="number">0.0041</span>.tar.gz</span><br><span class="line">==&gt; Downloading from https://codeload.github.com/vim/vim/tar.gz/v8.<span class="number">0.0041</span></span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; ./configure --prefix=/usr/<span class="built_in">local</span> --mandir=/usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span>/share/man --enable-multibyte --with-tlib=ncurses --enable-cscope --with-compiledby=Homebrew --enable-luainterp --enable-perlinterp --enable-pythoninterp --enable-</span><br><span class="line">==&gt; make</span><br><span class="line">==&gt; make install prefix=/usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span> STRIP=/usr/bin/<span class="literal">true</span></span><br><span class="line">🍺  /usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span>: <span class="number">1</span>,<span class="number">706</span> files, <span class="number">23.3</span>M, built <span class="keyword">in</span> <span class="number">5</span> minutes <span class="number">16</span> seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>:version</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:version</span><br><span class="line">VIM - Vi IMproved <span class="number">8.0</span> (<span class="number">2016</span> Sep <span class="number">12</span>, compiled Oct <span class="number">16</span> <span class="number">2016</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">47</span>)</span><br><span class="line">MacOS X (unix) version</span><br><span class="line">Included patches: <span class="number">1</span>-<span class="number">41</span></span><br><span class="line">Compiled by Homebrew</span><br><span class="line">Huge version without GUI.  Features included (+) or not (-):</span><br><span class="line">+acl             -clientserver    +cursorbind      +ex_extra        -gettext         +libcall         +mouse           +mouse_xterm     +persistent_undo +ruby            +tag_old_static  -toolbar         +wildmenu        -xterm_save</span><br><span class="line">+arabic          +clipboard       +cursorshape     +extra_search    -hangul_input    +linebreak       -mouseshape      +multi_byte      +postscript      +scrollbind      -tag_any_white   +user_commands   +windows</span><br><span class="line">+autocmd         +cmdline_compl   +dialog_con      +farsi           +iconv           +lispindent      +mouse_dec       +multi_lang      +printer         +signs           -tcl             +vertsplit       +writebackup</span><br><span class="line">-balloon_<span class="built_in">eval</span>    +cmdline_hist    +diff            +file_<span class="keyword">in</span>_path    +insert_expand   +listcmds        -mouse_gpm       -mzscheme        +profile         +smartindent     +termguicolors   +virtualedit     -X11</span><br><span class="line">-browse          +cmdline_info    +digraphs        +find_<span class="keyword">in</span>_path    +job             +localmap        -mouse_jsbterm   +netbeans_intg   +python          +startuptime     +terminfo        +visual          -xfontset</span><br><span class="line">++<span class="built_in">builtin</span>_terms  +comments        -dnd             +<span class="built_in">float</span>           +jumplist        +lua             +mouse_netterm   +num64           -python3         +statusline      +termresponse    +visualextra     -xim</span><br><span class="line">+byte_offset     +conceal         -ebcdic          +folding         +keymap          +menu            +mouse_sgr       +packages        +quickfix        -sun_workshop    +textobjects     +viminfo         -xpm</span><br><span class="line">+channel         +cryptv          +emacs_tags      -footer          +lambda          +mksession       -mouse_sysmouse  +path_extra      +reltime         +syntax          +timers          +vreplace        -xsmp</span><br><span class="line">+cindent         +cscope          +<span class="built_in">eval</span>            +fork()          +langmap         +modify_fname    +mouse_urxvt     +perl            +rightleft       +tag_binary      +title           +wildignore      -xterm_clipboard</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;将mac自带的vim7.3 升级到vim8.0&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://www.grdtechs.com/categories/DevOps/"/>
    
    
      <category term="vim8.0" scheme="http://www.grdtechs.com/tags/vim8-0/"/>
    
  </entry>
  
  <entry>
    <title>优雅的关闭ticker</title>
    <link href="http://www.grdtechs.com/2016/10/16/close-ticker-correctly/"/>
    <id>http://www.grdtechs.com/2016/10/16/close-ticker-correctly/</id>
    <published>2016-10-16T14:27:39.000Z</published>
    <updated>2016-12-18T09:17:06.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在<code>ticker</code>和<code>goroutine</code>组合使用中当调用<code>ticker.Stop()</code>关闭<code>ticker</code>之后，相应的<code>goroutine</code>中的<code>ticker.C</code>并没有停掉，下面总结一种优雅的方式关闭<code>ticker</code>.<br><a id="more"></a></p>
<h2 id="u4F18_u96C5_u7684_u5173_u95EDticker"><a href="#u4F18_u96C5_u7684_u5173_u95EDticker" class="headerlink" title="优雅的关闭ticker"></a>优雅的关闭<code>ticker</code></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	Demo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Demo() &#123;</span><br><span class="line">	done := startTicker(PrintInfo)</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">12</span>) * time.Second)</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">1</span>) * time.Minute)</span><br><span class="line">	fmt.Println(<span class="string">"main finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> startTicker(f <span class="keyword">func</span>()) <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">		<span class="comment">//	ticker := time.NewTicker(5 * time.Minute)</span></span><br><span class="line">		<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				f()</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> PrintInfo() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过<code>startTicker</code>创建一个<code>ticker</code>, 当想要关闭这个<code>ticker</code>并同时退出对应<code>goroutine</code>中的<code>for</code>时，可以直接<code>close()</code>，发送<code>done</code>信号直接返回退出<code>startTicker</code>即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;ticker&lt;/code&gt;和&lt;code&gt;goroutine&lt;/code&gt;组合使用中当调用&lt;code&gt;ticker.Stop()&lt;/code&gt;关闭&lt;code&gt;ticker&lt;/code&gt;之后，相应的&lt;code&gt;goroutine&lt;/code&gt;中的&lt;code&gt;ticker.C&lt;/code&gt;并没有停掉，下面总结一种优雅的方式关闭&lt;code&gt;ticker&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="ticker" scheme="http://www.grdtechs.com/tags/ticker/"/>
    
  </entry>
  
  <entry>
    <title>Golang发送post表单请求</title>
    <link href="http://www.grdtechs.com/2016/09/07/go-postform/"/>
    <id>http://www.grdtechs.com/2016/09/07/go-postform/</id>
    <published>2016-09-07T16:00:32.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang这边将<code>map</code>结构序列化通常采用<code>json.Marshal</code>和<code>json.Unmarshal</code>来做，但是在php server端还需要做<code>json</code>反序列化解析才能用， 用golang模拟表单提交, php server端则非常方便提取相应的数据字段.<br><a id="more"></a></p>
<h2 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h2><p>方法是利用golang<code>net/http</code>包提供的<code>PostForm</code>提交post表单提交。<code>ParseForm</code>解析<code>URL</code>中的查询字符串，并将解析结果更新到<code>r.Form</code>字段。对于<code>POST</code>或<code>PUT</code>请求，<code>ParseForm</code>还会将<code>body</code>当作表单解析，并将结果既更新到<code>r.PostForm</code>也更新到<code>r.Form</code>。解析结果中，<code>POST</code>或<code>PUT</code>请求主体要优先于<code>URL</code>查询字符串（同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被<code>MaxBytesReader</code>函数设定限制，其大小默认限制为开头10MB。</p>
<h2 id="http-Client_7B_7D-PostForm"><a href="#http-Client_7B_7D-PostForm" class="headerlink" title="http.Client{}.PostForm"></a>http.Client{}.PostForm</h2><p>利用<code>http.Client{}.PostForm</code>提交post表单。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">res, err := client.PostForm(<span class="string">"http://127.0.0.1:8091/postpage"</span>, url.Values&#123;</span><br><span class="line">	<span class="string">"key"</span>:   &#123;<span class="string">"this is client key"</span>&#125;,</span><br><span class="line">	<span class="string">"value"</span>: &#123;<span class="string">"this is client value"</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="http-PostForm"><a href="#http-PostForm" class="headerlink" title="http.PostForm"></a>http.PostForm</h2><p>直接用<code>http.PostForm</code>提交post表单。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"><span class="comment">//data := make(url.Values)</span></span><br><span class="line"><span class="comment">//data["key"] = []string&#123;"this is key"&#125;</span></span><br><span class="line"><span class="comment">//data["value"] = []string&#123;"this is value"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把post表单发送给目标服务器</span></span><br><span class="line">res, err := http.PostForm(<span class="string">"http://127.0.0.1:8091/postpage"</span>, url.Values&#123;</span><br><span class="line">	<span class="string">"key"</span>:   &#123;<span class="string">"this is url key"</span>&#125;,</span><br><span class="line">	<span class="string">"value"</span>: &#123;<span class="string">"this is url value"</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="u5BF9_u8868_u5355_u6570_u636E_u7684_u63D0_u53D6"><a href="#u5BF9_u8868_u5355_u6570_u636E_u7684_u63D0_u53D6" class="headerlink" title="对表单数据的提取"></a>对表单数据的提取</h2><p>server端对表单数据的提取<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受post请求， 然后打印表单中key和value字段的值</span></span><br><span class="line"><span class="keyword">if</span> r.Method == <span class="string">"POST"</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		key   <span class="typename">string</span> = r.PostFormValue(<span class="string">"key"</span>)</span><br><span class="line">		value <span class="typename">string</span> = r.PostFormValue(<span class="string">"value"</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/researchlab/golearning/tree/master/postform" target="_blank" rel="external">github示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang这边将&lt;code&gt;map&lt;/code&gt;结构序列化通常采用&lt;code&gt;json.Marshal&lt;/code&gt;和&lt;code&gt;json.Unmarshal&lt;/code&gt;来做，但是在php server端还需要做&lt;code&gt;json&lt;/code&gt;反序列化解析才能用， 用golang模拟表单提交, php server端则非常方便提取相应的数据字段.&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="form" scheme="http://www.grdtechs.com/tags/form/"/>
    
      <category term="post" scheme="http://www.grdtechs.com/tags/post/"/>
    
  </entry>
  
  <entry>
    <title>php7 安装redis扩展</title>
    <link href="http://www.grdtechs.com/2016/08/02/php7-redis-install/"/>
    <id>http://www.grdtechs.com/2016/08/02/php7-redis-install/</id>
    <published>2016-08-02T18:56:05.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在<code>Ubuntu16.04</code>上， 安装<code>php7</code>的<code>redis</code>扩展, 记录安装过程。<br><a id="more"></a></p>
<h3 id="u5B89_u88C5phpredis"><a href="#u5B89_u88C5phpredis" class="headerlink" title="安装phpredis"></a>安装phpredis</h3><p><code>Redis</code>已经有了<code>PHP7</code>版本，可以从<code>github</code> 上获取项目克隆，然后手动切换到 <code>php7</code> 分支即可安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/phpredis/phpredis.git </span><br><span class="line">$ <span class="built_in">cd</span> phpredis/ </span><br><span class="line">$ git checkout php7 </span><br><span class="line">$ phpize </span><br><span class="line">$ ./configure </span><br><span class="line">$ make </span><br><span class="line">$ makeinstall</span><br></pre></td></tr></table></figure>
<p>如果没有安装php7.0-dev, 则没有安装 <code>phpize</code> , 可以直接<code>sudo apt install php7.0-dev</code> 安装即可。 </p>
<h2 id="u542F_u52A8_redis__u6269_u5C55"><a href="#u542F_u52A8_redis__u6269_u5C55" class="headerlink" title="启动 redis 扩展"></a>启动 redis 扩展</h2><p>光安装了还不够，我们还需要编辑PHP的配置文件来使扩展被加载才行， 打开配置文件<code>vim /etc/php/7.0/fpm/php .ini</code>, 在配置文件中添加如下语句：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=redis.so</span><br></pre></td></tr></table></figure></p>
<p>然后重启php服务,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/php7.<span class="number">0</span>-fpm restart</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;Ubuntu16.04&lt;/code&gt;上， 安装&lt;code&gt;php7&lt;/code&gt;的&lt;code&gt;redis&lt;/code&gt;扩展, 记录安装过程。&lt;br&gt;
    
    </summary>
    
      <category term="php" scheme="http://www.grdtechs.com/categories/php/"/>
    
    
      <category term="php_redis" scheme="http://www.grdtechs.com/tags/php-redis/"/>
    
      <category term="phpize" scheme="http://www.grdtechs.com/tags/phpize/"/>
    
  </entry>
  
  <entry>
    <title>php中mvc模式使用总结(一)</title>
    <link href="http://www.grdtechs.com/2016/07/30/php-mvc-1/"/>
    <id>http://www.grdtechs.com/2016/07/30/php-mvc-1/</id>
    <published>2016-07-30T16:34:45.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>尽管MVC(model view controller pattern)模式在<code>PHP</code>web开发中很受欢迎，但是网上很难找到一套代码简单又能清楚阐述<code>PHP MVC</code>模式的案例，本文希望通过理论和代码实践简单阐述<code>PHP MVC</code>模式。</p>
<a id="more"></a>
<p><code>MVC</code>模式在应用中分为<code>Model</code>, <code>View</code> 和 <code>Controller</code>三模块:</p>
<p><code>Model</code>负责处理数据; 主要负责数据有关的业务处理及存储读取工作。</p>
<p><code>View</code>负责将<code>Model</code>层的数据按一定的格式样式展现给用户。</p>
<p><code>Controller</code>负责将<code>Model</code>层和<code>View</code>层联系起来，<code>Controller</code>层响应用户的请求，并将请求业务分发给<code>Model</code>层相应的业务逻辑处理，然后将处理数据再返回给<code>View</code>层展示。 </p>
<p><code>MVC</code>三者之间的关系如图所示:</p>
<center><br><img src="/imgs/mvc-collaboration.png" alt="MVC pattern Diagram"><br></center>

<p>本文设计的<code>MVC</code>demo目录如下</p>
<center><br><img src="/imgs/mvc-structure.png" alt="mvc structure"><br></center>

<h2 id="Controller__u5C42"><a href="#Controller__u5C42" class="headerlink" title="Controller 层"></a>Controller 层</h2><p><code>Controller</code>层可是<code>MVC</code>的入口，接收一个用户请求，解析请求发送给<code>Model</code>层，调用<code>Model</code>层处理业务，接收<code>Model</code>层返回的数据结果，并将数据发送给展示层。<code>Controller</code>层是<code>Model</code>层和<code>View</code>层之间的连接纽带;小的框架中<code>Model</code>层和<code>View</code>层是包含在<code>Controller</code>层中。应用程序中一般会以<code>index.php</code>作为程序的入口，<code>index.php</code>会将用户的所有请求直接转发到<code>Controller</code>层,由<code>Controller</code>层进行相应的处理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.php file </span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">"controller/Controller.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$controller</span> = <span class="keyword">new</span> Controller();</span><br><span class="line"><span class="variable">$controller</span>-&gt;invoke();</span><br></pre></td></tr></table></figure>
<p>在本例中<code>Controller</code>层只有一个函数和一个构造函数。构造函数示例化一个<code>Model</code>类的实例;当<code>Controller</code>对接收的<code>req</code>解析之后，需要决定调用<code>Model</code>层相应的业务逻辑进行处理，然后将<code>Model</code>层返回的处理数据分发给<code>view</code>层展示。需要知道的是<code>Controller</code>层不是知道<code>data</code>如何处理的，也不知道页面是如何生成的。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//controller/Controller.php file</span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">"model/Model.php"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$model</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="variable">$this</span>-&gt;model = <span class="keyword">new</span> Model();	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="keyword">isset</span>(!_GET[<span class="string">'book'</span>]))&#123;</span><br><span class="line">			<span class="variable">$books</span> = <span class="variable">$this</span>-&gt;model-&gt;getBookList();</span><br><span class="line">			<span class="keyword">include</span> <span class="string">'view/booklist.php'</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// show the requested book</span></span><br><span class="line">			<span class="variable">$book</span> = <span class="variable">$this</span>-&gt;model-&gt;getBook(<span class="variable">$_GET</span>[<span class="string">'book'</span>]);</span><br><span class="line">			<span class="keyword">include</span> <span class="string">'view/viewbook.php'</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MVC</code>时序图</p>
<center><br><img src="/imgs/mvc-sequence1.png" alt="MVC Sequence Diagram"><br></center>

<h2 id="Model__u548C_Entity__u7C7B"><a href="#Model__u548C_Entity__u7C7B" class="headerlink" title="Model 和 Entity 类"></a>Model 和 Entity 类</h2><p><code>Model</code>层表示应用程序中的数据和逻辑，通常称之为业务逻辑; 通常表示为如下:</p>
<ul>
<li><p>存储，删除， 更新应用程序的数据。通常包括数据库方面的操作, 也可以按照一定的协议格式封装数据然后再通过调用第三方web服务或APIs进行相应的数据处理。</p>
</li>
<li><p>封装应用程序的业务逻辑;实现应用程序的所有业务逻辑。通常人们会错误的应用程序的一些业务逻辑实现写入到<code>Controller</code>层或<code>View</code>层中， 这是一种错误的或者说不规范的做法。 </p>
</li>
</ul>
<p>本例中，<code>Model</code>层主要由<code>Model</code>类和<code>Book</code>类组成。<code>Book</code>类是一个实体类，应该暴露给<code>View</code>层。在一个好的<code>MVC</code>模式设计中，<code>Model</code>层中只有<code>Entity</code>类应该暴露接口供<code>View</code>层调用。这样做的唯一目的就是保持数据,因为<code>Entity</code>类中的对象可以通过<code>xml</code>或<code>json</code>数据块替换。在上述的示例中，<code>Model</code>层返回了一个具体的<code>book</code>实例信息，或者一个<code>books</code>list:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//model/Model.php file</span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">"model/Book.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//here goes some hardcoded values to simulate the database</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">			<span class="string">"Jungle Book"</span>=&gt; <span class="keyword">new</span> Book(<span class="string">"Jungle Book"</span>, <span class="string">"R.Kipling"</span>, <span class="string">"A classic book."</span>),</span><br><span class="line">			<span class="string">"Moonwalker"</span>=&gt; <span class="keyword">new</span> Book(<span class="string">"Moonwalker"</span>, <span class="string">"J.Walker"</span>,<span class="string">""</span>),</span><br><span class="line">			<span class="string">"PHP for Dummies"</span>=&gt; <span class="keyword">new</span> Book(<span class="string">"PHP for Dummies"</span>, <span class="string">"Some Smart Guy"</span>,<span class="string">""</span>)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBook</span><span class="params">(<span class="variable">$title</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// we use the previous function to get all the books and then we return the requested one.</span></span><br><span class="line">		<span class="comment">// in a real life scenario this will be done through a db select command.</span></span><br><span class="line">		<span class="variable">$allBooks</span> = <span class="variable">$this</span>-&gt;getBookList();</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$allBooks</span>[<span class="variable">$title</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在真实场景中，<code>Model</code>层负责将所有的实体和类中的数据持久化到数据库，<code>Model</code>层中的类封装所有的业务逻辑。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//model/Book.php file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$title</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$author</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$description</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$title</span>, <span class="variable">$author</span>, <span class="variable">$description</span>)</span></span>&#123;</span><br><span class="line">		<span class="variable">$this</span>-&gt;title = <span class="variable">$title</span>;</span><br><span class="line">		<span class="variable">$this</span>-&gt;author = <span class="variable">$author</span>;</span><br><span class="line">		<span class="variable">$this</span>-&gt;description = <span class="variable">$description</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View_u5C42"><a href="#View_u5C42" class="headerlink" title="View层"></a>View层</h2><p><code>View</code>层负责将<code>Model</code>层返回的数据按照一定样式格式化呈现给用户。<code>Model</code>层返回的数据可以是简单的对象类型，也可以是xml, json等复杂的数据类型。</p>
<p><code>View</code>层对于类似的展示逻辑应提取为模板，便于复用<code>View</code>层代码的同时有利于维护 。<code>Controller</code>层通常通过<code>Entity</code>类中的主<code>Entity</code>实例对象将<code>Model</code>层返回的数据转发给<code>View</code>层中特定的展示元素。</p>
<p>在本例中<code>View</code>层包含展示单个<code>book</code>信息和展示所有<code>book</code>信息两个文件</p>
<h3 id="viewbook-php"><a href="#viewbook-php" class="headerlink" title="viewbook.php"></a>viewbook.php</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="php"><span class="preprocessor">&lt;?php</span></span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'Title:'</span> . <span class="variable">$book</span>-&gt;title . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'Author:'</span> . <span class="variable">$book</span>-&gt;author . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'Description:'</span> . <span class="variable">$book</span>-&gt;description . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">	<span class="preprocessor">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="booklist-php"><a href="#booklist-php" class="headerlink" title="booklist.php"></a>booklist.php</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">tbody</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Title<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Author<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">tbody</span>&gt;</span>	</span><br><span class="line">		<span class="php"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">foreach</span>(<span class="variable">$books</span> <span class="keyword">as</span> <span class="variable">$title</span> =&gt; <span class="variable">$book</span>)&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'&lt;tr&gt;&lt;td&gt;&lt;a href="index.php?book="'</span> . <span class="variable">$book</span>-&gt;title .<span class="string">'"&gt;'</span>.<span class="variable">$book</span>-&gt;title .<span class="string">'&lt;/a&gt;&lt;/td&gt;&lt;td&gt;'</span>.<span class="variable">$book</span>-&gt;author.<span class="string">'&lt;/td&gt;&lt;td&gt;'</span>.<span class="variable">$book</span>-&gt;description.<span class="string">'&lt;/td&gt;&lt;/tr&gt;'</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="preprocessor">?&gt;</span></span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至此本demo分析实现完毕，<a href="https://github.com/researchlab/CodeSnippets/tree/master/php_wrk/simple_mvc" target="_blank" rel="external">github示例代码</a></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Model</code>层和<code>View</code>层分开使得构建应用程序更加容易</li>
<li><code>Model</code>层和<code>View</code>层可以根据项目需要其中一层构成<code>MV</code>或<code>CV</code>模式</li>
<li>可以对<code>MVC</code>模式中每个层进行单独的测试和调试</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;尽管MVC(model view controller pattern)模式在&lt;code&gt;PHP&lt;/code&gt;web开发中很受欢迎，但是网上很难找到一套代码简单又能清楚阐述&lt;code&gt;PHP MVC&lt;/code&gt;模式的案例，本文希望通过理论和代码实践简单阐述&lt;code&gt;PHP MVC&lt;/code&gt;模式。&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://www.grdtechs.com/categories/php/"/>
    
    
      <category term="mvc" scheme="http://www.grdtechs.com/tags/mvc/"/>
    
      <category term="php" scheme="http://www.grdtechs.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>浏览器刷新后input输入框依旧保留原值不被清空</title>
    <link href="http://www.grdtechs.com/2016/07/10/browse-refresh-saveinputolderval/"/>
    <id>http://www.grdtechs.com/2016/07/10/browse-refresh-saveinputolderval/</id>
    <published>2016-07-10T18:22:43.000Z</published>
    <updated>2016-12-18T09:17:06.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>html页面中的input框如果在浏览器刷新前有值，怎么在刷新后依然保留这个值不被清空呢？下面用<code>setCookie</code>的方案来解决这个问题.<br><a id="more"></a><br>首选判断input框中有值时,<code>setcookie</code>, 每次刷新浏览器时，读取<code>Cookie</code>值,如果存在<code>Cookie</code>值，则用此值初始化input值。</p>
<h2 id="u7EAFjs_u5B9E_u73B0"><a href="#u7EAFjs_u5B9E_u73B0" class="headerlink" title="纯js实现"></a>纯js实现</h2><h3 id="u8BBE_u7F6ECookie"><a href="#u8BBE_u7F6ECookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @cname  cookie name </span><br><span class="line">* @cvalue cookie value </span><br><span class="line">* @ exdays cookie expires(天)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">cname,cvalue,exdays</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(<span class="built_in">document</span>.cookie || navigator.cookieEnabled))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'浏览器 cookie 未打开!'</span>);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">	d.setTime(d.getTime()+(exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line">	<span class="keyword">var</span> expires = <span class="string">"expires="</span>+d.toGMTString();</span><br><span class="line">	<span class="built_in">document</span>.cookie = cname+<span class="string">"="</span>+cvalue+<span class="string">"; "</span>+expires;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u83B7_u53D6Cookie"><a href="#u83B7_u53D6Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = cname + <span class="string">"="</span>;</span><br><span class="line">	<span class="keyword">var</span> ca = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ca.length; i++) </span><br><span class="line">	  &#123;</span><br><span class="line">	  <span class="keyword">var</span> c = ca[i].trim();</span><br><span class="line">	  <span class="keyword">if</span> (c.indexOf(name)==<span class="number">0</span>) <span class="keyword">return</span> c.substring(name.length,c.length);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>cname</code> 获取相应的cookie值， cookie不存在就返回空字符串.</p>
<h3 id="checkCookie"><a href="#checkCookie" class="headerlink" title="checkCookie"></a>checkCookie</h3><p>可以将判断Cookie是否存在的下一步处理逻辑封装到<code>checkCookie</code>方法中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user=getCookie(<span class="string">"username"</span>);</span><br><span class="line">	<span class="keyword">if</span> (user!=<span class="string">""</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'user'</span>, user);	</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	  &#123;</span><br><span class="line">	  <span class="keyword">if</span> (user!=<span class="string">""</span> &amp;&amp; user!=<span class="literal">null</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	    setCookie(<span class="string">"username"</span>,user,<span class="number">3000</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53E6_u4E00_u79CD_u65B9_u5F0F_u662F_u501F_u52A9jQuery_u5B9E_u73B0"><a href="#u53E6_u4E00_u79CD_u65B9_u5F0F_u662F_u501F_u52A9jQuery_u5B9E_u73B0" class="headerlink" title="另一种方式是借助jQuery实现"></a>另一种方式是借助jQuery实现</h2><p>首选引入jquery相应的库</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://apps.bdimg.com/libs/jquery.cookie/1.4.1/jquery.cookie.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="u521B_u5EFACookie"><a href="#u521B_u5EFACookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h2><p>如创建一个名为“example”，值为“foo”的cookie：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure></p>
<p>要设置cookie的有效期，可以设置expires值，如设置cookie的过期时间为10天：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;expires:<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>设置cookie一小时后过期：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookietime = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">cookietime.setTime(date.getTime() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));<span class="comment">//coockie保存一小时 </span></span><br><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;expires:cookietime&#125;);</span><br></pre></td></tr></table></figure>
<p>要设置cookie的保存路径，可以设置path值，如设置路径为根目录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;path:<span class="string">"/"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>如果要设置路径为/admin，则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;path:<span class="string">"/admin"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="u83B7_u53D6cookie_u503C"><a href="#u83B7_u53D6cookie_u503C" class="headerlink" title="获取cookie值"></a>获取cookie值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="u5220_u9664Cookie"><a href="#u5220_u9664Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h2><p>使用jQuery删除cookie，只需要将cookie的值为null，注意如果设置值为空的字符串时，并不能删除cookie，只是将cookie值清空而已。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">'the_cookie'</span>, <span class="string">''</span>, &#123; expires: -<span class="number">1</span> &#125;); <span class="comment">// 删除 cookie</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/researchlab/CodeSnippets" target="_blank" rel="external">github源码demo</a></p>
<ul>
<li>js-setcookie.html</li>
<li>jquery-setcookie.html</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>cookie是基于域名来储存的, cookie具有不同域名下储存不可共享的特性。 这也是cookie支持设置<code>path</code>和<code>domain</code>的作用之一。<br>所以要测试cookie是否生效，需要放到测试服务器上或者本地localhost服务器上才会生效。<strong><font color="red">单纯的本地一个html页面打开是无效的。</font></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;html页面中的input框如果在浏览器刷新前有值，怎么在刷新后依然保留这个值不被清空呢？下面用&lt;code&gt;setCookie&lt;/code&gt;的方案来解决这个问题.&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.grdtechs.com/categories/javascript/"/>
    
    
      <category term="getcookie" scheme="http://www.grdtechs.com/tags/getcookie/"/>
    
      <category term="setcookie" scheme="http://www.grdtechs.com/tags/setcookie/"/>
    
  </entry>
  
  <entry>
    <title>go http client/server 设置cookie小结</title>
    <link href="http://www.grdtechs.com/2016/07/10/go-setcookie/"/>
    <id>http://www.grdtechs.com/2016/07/10/go-setcookie/</id>
    <published>2016-07-10T16:51:56.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>Go</code>web开发中，经常需要设置获取cookies, 不管是从client端设置获取还是server设置获取，其实都差不多，下面就总结一下常用的方法。<br><a id="more"></a></p>
<h2 id="golang_u4E2Dcookie__u8BE6_u7EC6_u5B9A_u4E49"><a href="#golang_u4E2Dcookie__u8BE6_u7EC6_u5B9A_u4E49" class="headerlink" title="golang中cookie 详细定义"></a>golang中cookie 详细定义</h2><p>golang 官方文档中对<code>Cookie</code>结构的定义<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="typename">string</span></span><br><span class="line">    Value      <span class="typename">string</span></span><br><span class="line">    Path       <span class="typename">string</span></span><br><span class="line">    Domain     <span class="typename">string</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="typename">string</span></span><br><span class="line">    <span class="comment">// MaxAge=0表示未设置Max-Age属性</span></span><br><span class="line">    <span class="comment">// MaxAge&lt;0表示立刻删除该cookie，等价于"Max-Age: 0"</span></span><br><span class="line">    <span class="comment">// MaxAge&gt;0表示存在Max-Age属性，单位是秒</span></span><br><span class="line">    MaxAge   <span class="typename">int</span></span><br><span class="line">    Secure   <span class="typename">bool</span></span><br><span class="line">    HttpOnly <span class="typename">bool</span></span><br><span class="line">    Raw      <span class="typename">string</span></span><br><span class="line">    Unparsed []<span class="typename">string</span> <span class="comment">// 未解析的“属性-值”对的原始文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Cookie</code>代表一个出现在<code>HTTP回复的头域</code>中<code>Set-Cookie头的值里</code>或者<code>HTTP请求的头域</code>中Cookie头的值里的HTTP cookie。</p>
<ul>
<li><p><code>Expires</code> – 过期时间。指定cookie的生命期。具体是值是过期日期。如果想让cookie的存在期限超过当前浏览器会话时间，就必须使用这个属性。当过了到期日期时，浏览器就可以删除cookie文件，没有任何影响。</p>
</li>
<li><p><code>Path</code> – 路径。指定与cookie关联的WEB页。值可以是一个目录，或者是一个路径。如果/head/index.html 建立了一个cookie，那么在/head/目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个cookie。这就是说，在/head/stories/articles 里的任何页面都可以访问/head/index.html建立的cookie。但是，如果/zdnn/ 需要访问/head/index.html设置的cookes，该怎么办?这时，我们要把cookies的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。现在看另一个例子：如果想让 /head/filters/ 和/head/stories/共享cookies，就要把path设成“/head”。</p>
</li>
<li><p><code>Domain</code> – 域。指定关联的WEB服务器或域。值是域名，比如goaler.com。这是对path路径属性的一个延伸。如果我们想让dev.mycompany.com 能够访问bbs.mycompany.com设置的cookies，该怎么办? 我们可以把domain属性设置成“mycompany.com”，并把path属性设置成“/”。FYI：不能把cookies域属性设置成与设置它的服务器的所在域不同的值。</p>
</li>
<li><p><code>Secure</code> – 安全。指定cookie的值通过网络如何在用户和WEB服务器之间传递。这个属性的值或者是“secure”，或者为空。缺省情况下，该属性为空，也就是使用不安全的HTTP连接传递数据。如果一个 cookie 标记为secure，那么，它与WEB服务器之间就通过HTTPS或者其它安全协议传递数据。不过，设置了secure属性不代表其他人不能看到你机器本地保存的cookie。换句话说，把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。</p>
</li>
<li><p><code>HttpOnly</code>属性,如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</p>
</li>
<li><p><code>secure</code>属性是防止信息在传递的过程中被监听捕获后信息泄漏，<code>HttpOnly</code>属性的目的是防止程序获取cookie后进行攻击。</p>
</li>
</ul>
<p><strong> 参考更多 </strong></p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="external">中文维基 - Cookie</a></li>
<li><a href="https://en.wikipedia.org/wiki/HTTP_cookie#Session_management" target="_blank" rel="external">英文维基 - Http-Cookie</a></li>
</ul>
<h2 id="client__u7AEF_u8BBE_u7F6Ecookie"><a href="#client__u7AEF_u8BBE_u7F6Ecookie" class="headerlink" title="client 端设置cookie"></a>client 端设置cookie</h2><p>客户端设置cookie,很简单<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client  set cookie</span></span><br><span class="line">cookie := http.Cookie&#123;Name: <span class="string">"clientcookieid"</span>, Value: <span class="string">"121"</span>, Expires: time.Now().Add(<span class="number">111</span> * time.Second)&#125;</span><br><span class="line">req.AddCookie(&amp;cookie)</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.AddCookie(&amp;http.Cookie&#123;</span><br><span class="line">	Name:    <span class="string">"clientcookieid2"</span>,</span><br><span class="line">	Value:   <span class="string">"id2"</span>,</span><br><span class="line">	Expires: time.Now().Add(<span class="number">111</span> * time.Second),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="server_u7AEF_u63A5_u6536cookie"><a href="#server_u7AEF_u63A5_u6536cookie" class="headerlink" title="server端接收cookie"></a>server端接收cookie</h2><p>后端接收cookie有两种方式,如果是指定cookie的名字，只要取得1个或少数几个cookie, 可以用如下方式获取<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_cookie, _ := r.Cookie(<span class="string">"clientcookieid"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, client_cookie)</span><br><span class="line">fmt.Println(client_cookie.Name, clinet_cookie.Value) <span class="comment">// 通过点运算符获取client_cookie的属性</span></span><br></pre></td></tr></table></figure></p>
<p>如果指定了多个cookie值对，则可以通过迭代的方式访问<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> r.Cookies() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="server_u7AEF_u8BBE_u7F6Ecookie"><a href="#server_u7AEF_u8BBE_u7F6Ecookie" class="headerlink" title="server端设置cookie"></a>server端设置cookie</h2><p>server端设置cookie 和client端设置cookie类似，不同的是 server端用的是<code>http.SetCookie</code>, 而client端用的是<code>req.AddCookie</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http.SetCookie(w, &amp;http.Cookie&#123;</span><br><span class="line">	Name:    <span class="string">"servercookie"</span>,</span><br><span class="line">	Value:   <span class="string">"servercookievalue"</span>,</span><br><span class="line">	Expires: time.Now().Add(<span class="number">111</span> * time.Second),</span><br><span class="line">&#125;)</span><br><span class="line">http.SetCookie(w, &amp;http.Cookie&#123;</span><br><span class="line">	Name:    <span class="string">"servercookie2"</span>,</span><br><span class="line">	Value:   <span class="string">"servercookievalue2"</span>,</span><br><span class="line">	Expires: time.Now().Add(<span class="number">111</span> * time.Second),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="client__u7AEF_u63A5_u6536cookie"><a href="#client__u7AEF_u63A5_u6536cookie" class="headerlink" title="client 端接收cookie"></a>client 端接收cookie</h2><p>golang client端接收cookie 只能通过迭代的方式获取<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> resp.Cookies() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/researchlab/golearning/tree/master/setcookie" target="_blank" rel="external">完整示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;web开发中，经常需要设置获取cookies, 不管是从client端设置获取还是server设置获取，其实都差不多，下面就总结一下常用的方法。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="net/http" scheme="http://www.grdtechs.com/tags/net-http/"/>
    
      <category term="setcookie" scheme="http://www.grdtechs.com/tags/setcookie/"/>
    
  </entry>
  
  <entry>
    <title>html 美化输出 json 字符串</title>
    <link href="http://www.grdtechs.com/2016/06/17/jsonfmt/"/>
    <id>http://www.grdtechs.com/2016/06/17/jsonfmt/</id>
    <published>2016-06-17T10:55:21.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>json</code>字符串在html用js美化输出使用总结。<br><a id="more"></a></p>
<h2 id="JSON-stringify_28_29_u51FD_u6570_u539F_u578B"><a href="#JSON-stringify_28_29_u51FD_u6570_u539F_u578B" class="headerlink" title="JSON.stringify()函数原型"></a>JSON.stringify()函数原型</h2><p><strong>语法：</strong><br>　　<code>JSON.stringify(value [, replacer] [, space])</code></p>
<p><code>value</code>：是必选字段。就是你输入的对象，比如数组，类等。<br><code>replacer</code>：这个是可选的。它又分为2种方式，一种是数组，第二种是方法。<br>　　情况一：<code>replacer</code>为数组时，通过后面的实验可以知道，它是和第一个参数<code>value</code>有关系的。一般来说，系列化后的结果是通过键值对来进行表示的。 所以，如果此时第二个参数的值在第一个存在，那么就以第二个参数的值做<code>key</code>，第一个参数的值为<code>value</code>进行表示，如果不存在，就忽略。</p>
<p>　　情况二：<code>replacer</code>为方法时，那很简单，就是说把系列化后的每一个对象（记住是每一个）传进方法里面进行处理。 </p>
<p><code>space</code>：就是用什么来做分隔符的。<br>　　1）如果省略的话，那么显示出来的值就没有分隔符，直接输出来 。<br>　　2）如果是一个数字的话，那么它就定义缩进几个字符，当然如果大于10 ，则默认为10，因为最大值为10。<br>　　3）如果是一些转义字符，比如<code>\t</code>，表示回车，那么它每行一个回车。<br>　　4）如果仅仅是字符串，就在每行输出值的时候把这些字符串附加上去。当然，最大长度也是10个字符。 </p>
<h2 id="JSON-stringify_28_29__u5B9E_u4F8B"><a href="#JSON-stringify_28_29__u5B9E_u4F8B" class="headerlink" title="JSON.stringify() 实例"></a>JSON.stringify() 实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>html美化输出json字符串<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">'text/css'</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">pre</span> <span class="rules">&#123;<span class="rule"><span class="attribute">outline</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">5px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.string</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green</span></span>; &#125;</span></span><br><span class="line"><span class="class">.number</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> darkorange</span></span>; &#125;</span></span><br><span class="line"><span class="class">.boolean</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> blue</span></span>; &#125;</span></span><br><span class="line"><span class="class">.null</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> magenta</span></span>; &#125;</span></span><br><span class="line"><span class="class">.key</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>; &#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">pre</span> <span class="attribute">id</span>=<span class="value">"output"</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">pre</span> <span class="attribute">id</span>=<span class="value">"output2"</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;a:<span class="number">1</span>, <span class="string">'b'</span>:<span class="string">'foo'</span>, c:[<span class="literal">false</span>,<span class="literal">null</span>, &#123;d:&#123;e:<span class="number">1.3e5</span>&#125;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 最简单的输出</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj, <span class="literal">undefined</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'output'</span>).innerHTML = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 带高亮的输出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">highLight</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">			 json = json.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>).replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">			  <span class="keyword">return</span> json.replace(<span class="regexp">/("(\\u[a-zA-Z0-9]&#123;4&#125;|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match</span>) </span>&#123;</span><br><span class="line">				     <span class="keyword">var</span> cls = <span class="string">'number'</span>;</span><br><span class="line">				     <span class="keyword">if</span> (<span class="regexp">/^"/</span>.test(match)) &#123;</span><br><span class="line">				         <span class="keyword">if</span> (<span class="regexp">/:$/</span>.test(match)) &#123;</span><br><span class="line">				             cls = <span class="string">'key'</span>;</span><br><span class="line">				         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				             cls = <span class="string">'string'</span>;</span><br><span class="line">				         &#125;</span><br><span class="line">				     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/true|false/</span>.test(match)) &#123;</span><br><span class="line">				         cls = <span class="string">'boolean'</span>;</span><br><span class="line">				     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/null/</span>.test(match)) &#123;</span><br><span class="line">				         cls = <span class="string">'null'</span>;</span><br><span class="line">				     &#125;</span><br><span class="line">				     <span class="keyword">return</span> <span class="string">'&lt;span class="'</span> + cls + <span class="string">'"&gt;'</span> + match + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">				 &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> person = &#123;</span><br><span class="line">			 name: <span class="string">"Hello Kitty"</span>,</span><br><span class="line">			 sex: <span class="string">"男"</span>,</span><br><span class="line">			 age: <span class="number">20</span>,</span><br><span class="line">			 child: [</span><br><span class="line">			 	&#123;</span><br><span class="line">			 		name: <span class="string">"Hello"</span>,</span><br><span class="line">					sex: <span class="string">"男"</span>,</span><br><span class="line">					age: <span class="number">10</span>,</span><br><span class="line">					toy:[<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">			 	&#125;,</span><br><span class="line">			 	&#123;</span><br><span class="line">			 		name: <span class="string">"Kitty"</span>,</span><br><span class="line">					sex: <span class="string">"女"</span>,</span><br><span class="line">					age: <span class="number">8</span>,</span><br><span class="line">					toy:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">			 	&#125;</span><br><span class="line">			 ]</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(person, <span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment">//document.getElementById('output2').innerHTML = syntaxHighlight(str);</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'output2'</span>).innerHTML = highLight(str);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述示例的效果如图:</p>
<center><img src="/imgs/jsonfmt.png" alt="jsonformat"></center>

<p><a href="https://github.com/researchlab/CodeSnippets/blob/master/json.html" target="_blank" rel="external">详见github示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;json&lt;/code&gt;字符串在html用js美化输出使用总结。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.grdtechs.com/categories/javascript/"/>
    
    
      <category term="html" scheme="http://www.grdtechs.com/tags/html/"/>
    
      <category term="json" scheme="http://www.grdtechs.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>golang 格式化时间总结</title>
    <link href="http://www.grdtechs.com/2016/06/14/go-time-summary/"/>
    <id>http://www.grdtechs.com/2016/06/14/go-time-summary/</id>
    <published>2016-06-14T14:05:28.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>golang</code> 中经常需要格式化时间和日期来满足不同的业务需求,下面总结格式化时间日期中遇到的问题。<br><a id="more"></a></p>
<h2 id="golang_time_u5305__u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316_u5B9A_u4E49"><a href="#golang_time_u5305__u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316_u5B9A_u4E49" class="headerlink" title="golang time包 时间日期格式化定义"></a>golang time包 时间日期格式化定义</h2><p>go 的time package 提供了time.Format函数，用来对时间进行格式化输出;类似的还有time.Parse用来解析字符串类型的时间到time.Time。这是两个互逆的函数。</p>
<p><strong> 下面看<code>golang</code>中<code>time</code>包对于时间的详细定义 </strong></p>
<ul>
<li>月份 1,01,Jan,January</li>
<li>日　 2,02,_2</li>
<li>时　 3,03,15,PM,pm,AM,am</li>
<li>分　 4,04</li>
<li>秒　 5,05</li>
<li>年　 06,2006</li>
<li>时区 -07,-0700,Z0700,Z07:00,-07:00,MST</li>
<li>周几 Mon,Monday</li>
</ul>
<p><strong> 比如小时的表示(原定义是下午3时，也就是15时) </strong></p>
<ul>
<li>3 用12小时制表示，去掉前导0</li>
<li>03 用12小时制表示，保留前导0</li>
<li>15 用24小时制表示，保留前导0</li>
<li>03pm 用24小时制am/pm表示上下午表示，保留前导0</li>
<li>3pm 用24小时制am/pm表示上下午表示，去掉前导0</li>
</ul>
<p><strong> 又比如月份 </strong></p>
<ul>
<li>1 数字表示月份，去掉前导0</li>
<li>01 数字表示月份，保留前导0</li>
<li>Jan 缩写单词表示月份</li>
<li>January 全单词表示月份</li>
</ul>
<h2 id="u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316"><a href="#u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316" class="headerlink" title="时间日期格式化"></a>时间日期格式化</h2><ul>
<li>本地当期时间</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now()) <span class="comment">//2016-07-14 14:27:28.214512532 +0800 CST</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间格式化</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now().Format(<span class="string">"3:04:05.000 PM Mon Jan"</span>))            <span class="comment">// 2:27:05.702 PM Thu Jul</span></span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-_2 3:04:05.000 PM Mon Jan"</span>)) <span class="comment">// 2016-07-14 2:54:11.442 PM Thu Jul</span></span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))  <span class="comment">// 2016-07-14 14:54:11.442239513 +0800 CST</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地当前时间戳(10位)</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now().Unix()) <span class="comment">//1468479251</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地当前时间戳(19位)</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now().UnixNano()) <span class="comment">//1468480006774460462</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间戳转时间 </li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Unix(<span class="number">1389058332</span>, <span class="number">0</span>).Format(<span class="string">"2006-01-02 15:04:05"</span>)) <span class="comment">//2014-01-07 09:32:12</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间转时间戳</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Date(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">4</span>, <span class="number">0</span>, time.Local).Unix())</span><br></pre></td></tr></table></figure>
<ul>
<li>时间转换为UTC时间和本地时间( UTC:零时区 +0000， China: 东八区 +0800)</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dateStr := <span class="string">"2016-07-14 14:24:51"</span> </span><br><span class="line">timestamp1, _ := time.Parse(<span class="string">"2006-01-02 15:04:05"</span>, dateStr)</span><br><span class="line">timestamp2, _ := time.ParseInLocation(<span class="string">"2006-01-02 15:04:05"</span>, dateStr, time.Local)</span><br><span class="line">fmt.Println(timestamp1, timestamp2)               <span class="comment">//2016-07-14 14:24:51 +0000 UTC 2016-07-14 14:24:51 +0800 CST </span></span><br><span class="line">fmt.Println(timestamp1.Unix(), timestamp2.Unix()) <span class="comment">//1468506291 1468477491 </span></span><br><span class="line"></span><br><span class="line">now := time.Now()                </span><br><span class="line">year, mon, day := now.UTC().Date()</span><br><span class="line">hour, min, sec := now.UTC().Clock()</span><br><span class="line">zone, _ := now.UTC().Zone()     </span><br><span class="line">fmt.Printf(<span class="string">"UTC 时间是 %d-%d-%d %02d:%02d:%02d %s\n"</span>,         </span><br><span class="line">    year, mon, day, hour, min, sec, zone) <span class="comment">// UTC 时间是 2016-7-14 07:06:46 UTC</span></span><br><span class="line">                                                           </span><br><span class="line">year, mon, day = now.Date()</span><br><span class="line">hour, min, sec = now.Clock()</span><br><span class="line">zone, _ = now.Zone()</span><br><span class="line">fmt.Printf(<span class="string">"本地时间是 %d-%d-%d %02d:%02d:%02d %s\n"</span>,</span><br><span class="line">    year, mon, day, hour, min, sec, zone) <span class="comment">// 本地时间是 2016-7-14 15:06:46 CST</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;golang&lt;/code&gt; 中经常需要格式化时间和日期来满足不同的业务需求,下面总结格式化时间日期中遇到的问题。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="time" scheme="http://www.grdtechs.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>Go Vendoring Tools 使用总结</title>
    <link href="http://www.grdtechs.com/2016/05/24/comparison-of-Go-Vendoring-Tools/"/>
    <id>http://www.grdtechs.com/2016/05/24/comparison-of-Go-Vendoring-Tools/</id>
    <published>2016-05-24T14:03:36.000Z</published>
    <updated>2016-12-18T09:17:06.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang1.5版本开始支持第三方包到依赖管理,当多个项目在同一个<code>GOPATH</code>下，每个项目包含到第三方包通过<code>go get</code>命令都会<code>get</code>到<code>GOPATH</code>下到<code>src</code>目录中，而不是各个项目的文件夹中，这就导致第三方包的不同版本不能同时被<code>GOPATH</code>下到多个项目使用，从<code>golang</code>需要设置<code>GOPATH</code>来看,<code>golang</code>其实把每个项目当作一个个独立的第三包来看待。<br><a id="more"></a><br>关于<code>golang</code>包管理工具的topic, 在<code>golang</code>的官方wiki要有一篇总结对比的文章:<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="external">PackageManagementTools</a>。下面主要就项目中用过的<code>godep</code>,<code>govendor</code>,<code>glide</code>做一个简要的对比分析。</p>
<h2 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h2><p><a href="https://github.com/tools/godep" target="_blank" rel="external">godep</a> helps build packages reproducibly by fixing their dependencies.</p>
<p><strong>前置条件</strong></p>
<ul>
<li>项目处在<code>GOPATH</code>下</li>
<li>项目能被<code>go install</code>通过</li>
<li>项目能被<code>go test</code>通过</li>
</ul>
<p><strong>包初始化管理</strong><br>在项目根目录下执行<code>godep save</code>命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ godep save</span><br></pre></td></tr></table></figure></p>
<p>会在项目根目录下生成两个文件夹: </p>
<p><code>Godeps</code>目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  Godeps tree</span><br><span class="line">.</span><br><span class="line">├── Godeps.json</span><br><span class="line">└── Readme</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">2</span> files</span><br><span class="line">➜  Godeps cat Godeps.json </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"ImportPath"</span>: <span class="string">"yaml"</span>,</span><br><span class="line">	<span class="string">"GoVersion"</span>: <span class="string">"go1.6"</span>,</span><br><span class="line">	<span class="string">"GodepVersion"</span>: <span class="string">"v70"</span>,</span><br><span class="line">	<span class="string">"Packages"</span>: [</span><br><span class="line">		<span class="string">"./..."</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">"Deps"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"ImportPath"</span>: <span class="string">"gopkg.in/yaml.v2"</span>,</span><br><span class="line">			<span class="string">"Rev"</span>: <span class="string">"a83829b6f1293c91addabc89d0571c246397bbf4"</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vendor</code>目录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  vendor tree</span><br><span class="line">.</span><br><span class="line">└── gopkg.in</span><br><span class="line">    └── yaml.v2</span><br><span class="line">        ├── apic.go</span><br><span class="line">        ├── decode.go</span><br><span class="line">        ├── emitterc.go</span><br><span class="line">        ├── encode.go</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── LICENSE.libyaml</span><br><span class="line">        ├── parserc.go</span><br><span class="line">        ├── readerc.go</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── resolve.go</span><br><span class="line">        ├── scannerc.go</span><br><span class="line">        ├── sorter.go</span><br><span class="line">        ├── writerc.go</span><br><span class="line">        ├── yaml.go</span><br><span class="line">        ├── yamlh.go</span><br><span class="line">        └── yamlprivateh.go</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">16</span> files</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>godep</code>把第三包的版本依赖信息记录在<code>Godeps.json</code>下，并且把第三包完整拷贝一份到<code>vendor</code>下面。通过对<code>Godeps.json</code>文件进行版本管理即可以管理整个项目的第三方包依赖信息。</p>
<p><strong>添加新包</strong><br>方法一：</p>
<p>go get 把新增的第三方包get到<code>GOPATH</code>的<code>src</code>目录下，然后再执行<code>godep save</code></p>
<p>方法二：</p>
<p>godep get <url> 同样是把第三方包get到<code>GOPATH</code>的<code>src</code>下，然后再执行<code>godep save</code></url></p>
<p>可以看到<code>godep</code>只是把第三方包进行单独到依赖管理，而新增到第三包还是会被get到<code>GOPATH</code>中, 如果多个项目用同一个第三包的不同版本时，显然不能满足。</p>
<p><strong>更新包</strong><br><code>godep</code>通过<code>godep update</code> 更新制定的第三包以及<code>golang</code>的版本。</p>
<h2 id="govendor"><a href="#govendor" class="headerlink" title="govendor"></a>govendor</h2><p><a href="https://github.com/kardianos/govendor" target="_blank" rel="external">govendor</a> Uses the go1.5+ vendor folder. Multiple workflows supported, single tool.</p>
<p><strong>Quick Start</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setup your project.</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"my project in GOPATH"</span></span><br><span class="line">govendor init</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add existing GOPATH files to vendor.</span></span><br><span class="line">govendor add +external</span><br><span class="line"></span><br><span class="line"><span class="comment"># View your work.</span></span><br><span class="line">govendor list</span><br><span class="line"></span><br><span class="line"><span class="comment"># Look at what is using a package</span></span><br><span class="line">govendor list -v fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a specific version or revision to fetch</span></span><br><span class="line">govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</span><br><span class="line">govendor fetch golang.org/x/net/context@v1   <span class="comment"># Get latest v1.*.* tag or branch.</span></span><br><span class="line">govendor fetch golang.org/x/net/context@=v1  <span class="comment"># Get the tag or branch named "v1".</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Update a package to latest, given any prior version constraint</span></span><br><span class="line">govendor fetch golang.org/x/net/context</span><br></pre></td></tr></table></figure>
<p><strong>Sub-commands</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">init     Create the <span class="string">"vendor"</span> folder and the <span class="string">"vendor.json"</span> file.</span><br><span class="line">    list     List and filter existing dependencies and packages.</span><br><span class="line">    add      Add packages from <span class="variable">$GOPATH</span>.</span><br><span class="line">    update   Update packages from <span class="variable">$GOPATH</span>.</span><br><span class="line">    remove   Remove packages from the vendor folder.</span><br><span class="line">    status   Lists any packages missing, out-of-date, or modified locally.</span><br><span class="line">    fetch    Add new or update vendor folder packages from remote repository.</span><br><span class="line">    sync     Pull packages into vendor folder from remote repository with revisions</span><br><span class="line">                 from vendor.json file.</span><br><span class="line">    migrate  Move packages from a legacy tool to the vendor folder with metadata.</span><br><span class="line">    get      Like <span class="string">"go get"</span> but copies dependencies into a <span class="string">"vendor"</span> folder.</span><br><span class="line">    license  List discovered licenses <span class="keyword">for</span> the given status or import paths.</span><br><span class="line">    shell    Run a <span class="string">"shell"</span> to make multiple sub-commands more efficent <span class="keyword">for</span> large</span><br><span class="line">                 projects.</span><br><span class="line"></span><br><span class="line">    go tool commands that are wrapped:</span><br><span class="line">      `+&lt;status&gt;` package selection may be used with them</span><br><span class="line">    fmt, build, install, clean, <span class="built_in">test</span>, vet, generate</span><br></pre></td></tr></table></figure>
<p><strong>Status</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+<span class="built_in">local</span>    (l) packages <span class="keyword">in</span> your project</span><br><span class="line">    +external (e) referenced packages <span class="keyword">in</span> GOPATH but not <span class="keyword">in</span> current project</span><br><span class="line">    +vendor   (v) packages <span class="keyword">in</span> the vendor folder</span><br><span class="line">    +std      (s) packages <span class="keyword">in</span> the standard library</span><br><span class="line"></span><br><span class="line">    +unused   (u) packages <span class="keyword">in</span> the vendor folder, but unused</span><br><span class="line">    +missing  (m) referenced packages but not found</span><br><span class="line"></span><br><span class="line">    +program  (p) package is a main package</span><br><span class="line"></span><br><span class="line">    +outside  +external +missing</span><br><span class="line">    +all      +all packages</span><br></pre></td></tr></table></figure>
<p>可以看到<code>govendor init</code>之后会在根目录下生成一个<code>vendor</code>文件夹 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  yaml tree <span class="operator">-d</span></span><br><span class="line">.</span><br><span class="line">└── vendor</span><br><span class="line">    ├── github.com</span><br><span class="line">    │   └── cihub</span><br><span class="line">    │       └── seelog</span><br><span class="line">    └── gopkg.in</span><br><span class="line">        └── yaml.v2</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> directories</span><br><span class="line">➜  yaml cat vendor/vendor.json </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"comment"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="string">"ignore"</span>: <span class="string">"test"</span>,</span><br><span class="line">	<span class="string">"package"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"checksumSHA1"</span>: <span class="string">"Nc93Ubautl47L3RP6x4lTY+ud68="</span>,</span><br><span class="line">			<span class="string">"path"</span>: <span class="string">"github.com/cihub/seelog"</span>,</span><br><span class="line">			<span class="string">"revision"</span>: <span class="string">"cedd97ac8c6c2ec413a97864185f9510fb1775cc"</span>,</span><br><span class="line">			<span class="string">"revisionTime"</span>: <span class="string">"2016-05-20T13:10:56Z"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"checksumSHA1"</span>: <span class="string">"+OgOXBoiQ+X+C2dsAeiOHwBIEH0="</span>,</span><br><span class="line">			<span class="string">"path"</span>: <span class="string">"gopkg.in/yaml.v2"</span>,</span><br><span class="line">			<span class="string">"revision"</span>: <span class="string">"a83829b6f1293c91addabc89d0571c246397bbf4"</span>,</span><br><span class="line">			<span class="string">"revisionTime"</span>: <span class="string">"2016-03-01T20:40:22Z"</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="string">"rootPath"</span>: <span class="string">"yaml"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>govendor fetch &lt;url1&gt; &lt;url2&gt;</code>新增的第三方包直接被get到根目录的<code>vendor</code>文件夹下,不会与其它的项目混用第三方包，完美避免多个项目同用同一个第三方包的不同版本问题。</p>
<p>只需要对<code>vendor/vendor.json</code>进行版本控制，即可对第三包依赖关系进行控制。</p>
<h2 id="glide"><a href="#glide" class="headerlink" title="glide"></a>glide</h2><p><a href="https://github.com/Masterminds/glide" target="_blank" rel="external">Glide</a> Vendor Package Management for Golang.</p>
<p><strong>Usage</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  yaml glide --help</span><br><span class="line">USAGE:</span><br><span class="line">   glide [global options] <span class="built_in">command</span> [<span class="built_in">command</span> options] [arguments...]</span><br><span class="line"></span><br><span class="line">	create, init	Initialize a new project, creating a glide.yaml file</span><br><span class="line">    get			Install one or more packages into `vendor/` and add dependency to glide.yaml.</span><br><span class="line">    remove, rm		Remove a package from the glide.yaml file, and regenerate the lock file.</span><br><span class="line">    import		Import files from other dependency management systems.</span><br><span class="line">    name		Print the name of this project.</span><br><span class="line">    novendor, nv	List all non-vendor paths <span class="keyword">in</span> a directory.</span><br><span class="line">    rebuild		Rebuild (<span class="string">'go build'</span>) the dependencies</span><br><span class="line">    install, i		Install a project<span class="string">'s dependencies</span><br><span class="line">    update, up		Update a project'</span>s dependencies</span><br><span class="line">    tree		Tree prints the dependencies of this project as a tree.</span><br><span class="line">    list		List prints all dependencies that the present code references.</span><br><span class="line">    info		Info prints information about this project</span><br><span class="line">    about		Learn about Glide</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --yaml, -y <span class="string">"glide.yaml"</span>	Set a YAML configuration file.</span><br><span class="line">   --quiet, -q			Quiet (no info or debug messages)</span><br><span class="line">   --debug			Print Debug messages (verbose)</span><br><span class="line">   --home <span class="string">"/home/dev/.glide"</span>	The location of Glide files [<span class="variable">$GLIDE_HOME</span>]</span><br><span class="line">   --no-color			Turn off colored output <span class="keyword">for</span> <span class="built_in">log</span> messages</span><br><span class="line">   --help, -h			show <span class="built_in">help</span></span><br><span class="line">   --version, -v		<span class="built_in">print</span> the version</span><br></pre></td></tr></table></figure>
<p><code>glide</code>    通过<code>glide create</code>或<code>glide init</code>命令初始化第三方包管理，会在项目根目录下生成一个<code>glide.yaml</code>，这个文件记录用到的第三方包的依赖关系，支持编辑修改。<br><code>glide</code>通过<code>glide install</code>, 会把所有缺少的第三方包都下载到<code>vendor</code>文件夹下，并且会在<code>glide.yaml</code>中添加所有依赖的第三方包名称，在<code>glide.lock</code>文件中记录具体的版本管理信息。</p>
<p><strong>glide install</strong></p>
<p>When you want to install the specific versions from the glide.lock file use glide install.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ glide install</span><br></pre></td></tr></table></figure>
<p>This will read the <code>glide.lock</code> file and install the commit id specific versions there.</p>
<p>When the glide.lock file doesn’t tie to the <code>glide.yaml</code> file, such as there being a change, it will provide a warning. Running glide up will recreate the <code>glide.lock</code> file when updating the dependency tree.</p>
<p>If no glide.lock file is present glide install will perform an update and generate a lock file.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>godep</code>,<code>govendor</code>,<code>glide</code> 都可以很好的进行包管理。<code>govendor</code>,<code>glide</code>提供的可操作命令更丰富。</li>
<li><code>godep</code> 会在根目录生成<code>Godeps</code>和<code>vendor</code>两个文件夹; <code>govendor</code>把所有信息都生成在<code>vendor</code>目录下; <code>glide</code> 会在根目录下生成<code>glide.yaml</code>, <code>glide.lock</code>文件及<code>vendor</code>目录; 从<code>简洁度</code>和<code>尽量不污染项目</code>来看，<code>govendor</code>最优，<code>glide</code>次之。</li>
<li><p><code>godep</code>, <code>govendor</code>, <code>glide</code> 都提供get 第三方包的命令，但是 <code>glide</code>的<code>glide install</code> 最为方便， 并且直接把第三方包get到本项目的vendor目录下，并且<code>glide</code>提供的<code>便捷</code>命令也丰富。</p>
</li>
<li><p><strong> 在生产项目中推荐使用<code>govendor</code>, 更简洁; 在试验项目中推荐试用<code>glide</code>, 更方便。</strong></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang1.5版本开始支持第三方包到依赖管理,当多个项目在同一个&lt;code&gt;GOPATH&lt;/code&gt;下，每个项目包含到第三方包通过&lt;code&gt;go get&lt;/code&gt;命令都会&lt;code&gt;get&lt;/code&gt;到&lt;code&gt;GOPATH&lt;/code&gt;下到&lt;code&gt;src&lt;/code&gt;目录中，而不是各个项目的文件夹中，这就导致第三方包的不同版本不能同时被&lt;code&gt;GOPATH&lt;/code&gt;下到多个项目使用，从&lt;code&gt;golang&lt;/code&gt;需要设置&lt;code&gt;GOPATH&lt;/code&gt;来看,&lt;code&gt;golang&lt;/code&gt;其实把每个项目当作一个个独立的第三包来看待。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="glide" scheme="http://www.grdtechs.com/tags/glide/"/>
    
      <category term="godep" scheme="http://www.grdtechs.com/tags/godep/"/>
    
      <category term="govendor" scheme="http://www.grdtechs.com/tags/govendor/"/>
    
      <category term="vendoring" scheme="http://www.grdtechs.com/tags/vendoring/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动构建Hexo静态博客</title>
    <link href="http://www.grdtechs.com/2016/05/08/travis-ci-deploy-hexo-blog/"/>
    <id>http://www.grdtechs.com/2016/05/08/travis-ci-deploy-hexo-blog/</id>
    <published>2016-05-08T21:48:40.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。<code>Travis CI</code>就是一个在线的、分布式的持续集成服务，用来构建及测试在GitHub托管的代码。利用Travis CI 会在每一次push后生成一个虚拟机来执行事先安排好的自动构建任务，从来进行发布。本文就要用<code>Travis CI</code>来自动构建<code>Hexo</code>博客。<br><a id="more"></a></p>
<h2 id="u5B89_u88C5Hexo"><a href="#u5B89_u88C5Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ul>
<li>安装cnpm</li>
</ul>
<blockquote>
<p>注意：npm因为qiang的原因，经常会出问题，我换成了taobao的cmpn镜像，taobao的cnpm镜像这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
</blockquote>
<p>安装命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>
<ul>
<li>安装Hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>启动本地的服务器看下是否安装成功<code>hexo s</code>，浏览器打开<a href="http://localhost:4000。" target="_blank" rel="external">http://localhost:4000。</a></p>
<p>到目前为止，Hexo安装完毕，如何配置及发布到<code>github</code>上托管，请参考<a href="http://www.grdtechs.com/2016/01/15/hexo-blog-1/">用Hexo+github搭建本站</a>。本文重点记录如何用<code>Travis CI</code> 自动构建<code>Hexo</code>博客。</p>
<h2 id="u90E8_u7F72Travis_CI"><a href="#u90E8_u7F72Travis_CI" class="headerlink" title="部署Travis CI"></a>部署Travis CI</h2><p>目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。</p>
<ul>
<li>持续集成的概念</li>
</ul>
<p>持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，每人每天可能集成一次，甚至多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。</p>
<p>自动构建工具则是持续集成的一种出色实践。代码提交后，由软件自动完成代码的测试、构建，并将过程中状态与构建物产出才是持续集成的意义。</p>
<ul>
<li>为什么使用</li>
</ul>
<p>Travis CI本身已经是很好的自动构建的工具，而这里使用的原因，本质上是因为Hexo本身并不能进行多人合作。Hexo的hexo generate和hexo deploy会自动渲染并提交到GitHub上，所以当你从别的电脑上clone的时候，clone下来的是渲染好的html的文章。就算我在两个电脑上同时搭建了环境，但是每次渲染的时候只会渲染本地的markdown文章，依然不能进行同步。有些人选择了使用百度云进行同步，每次写之前下载下来并覆盖，就能进行同步。不否认，这个方法对于一个人写博客，在工作和家的电脑还算是比较方便的，因为始终是一个人进行操作。而我们的博客是多人共同写的，所以说会存在各种冲突问题，于是想到了用Travis CI。</p>
<center><img src="/imgs/travis-hexo-flowing.png" alt="travis-hexo-flowing"></center>

<p>从上述流程中分析下思路：<br>前提：我们在之前博客搭建的repo下面，新建一个blog的分支，这个分支用来进行环境代码的备份，并且配置出<code>.travis.yml</code>进行自动化构建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User - push -&gt; branch blog</span><br></pre></td></tr></table></figure>
<p>将代码push到在GitHub上的博客中的blog分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dev repo - sync -&gt; Travis CI</span><br></pre></td></tr></table></figure>
<p>在branch blog中配置<code>.travis.yml</code>文件，在Travis CI中开启branch blog的同步开关，并启用<code>Build only if .travis.yml is present</code>项，这样能在repo中有多个branch时，让Travis CI只构建放置了<code>.travis.yml</code>文件的<code>branch</code>。</p>
<ul>
<li>Travis CI - build and push -&gt; Pages repo</li>
</ul>
<p><code>Travis CI</code> 的自动化构建完全依靠唯一的<code>.travis.yml</code>脚本文件。需要在此文件中添加构建环境、构建Hexo、生成博客及后续push到Pages repo的全部脚本。</p>
<ul>
<li>生成SSH Key<br>要做到<code>Travis CI</code>向<code>Pages repo</code>自动推送就必须用到<code>Github SSH Key</code>，这样做的目的是免去Hexo部署时候输入密码的步骤。生成SSH Key的操作参照GitHub的官网即可：<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="external">Github SSH Key</a>。<br>这样会得到<code>id_rsa.pub</code>和<code>id_rsa</code>两个秘钥，我们将<code>id_rsa.pub</code>添加到了<code>github</code>，下面要加密<code>id_rsa</code>这个私钥并且上传到<code>Travis</code>。</li>
</ul>
<p><strong> 注意：</strong> <font color="red">这个SSH key不应该是你账号的全局SSH Key，这样Travis CI就获得了你所有代码库的提交权限。仅仅只需要把SSH Key添加到当前repo的setting中的key下面即可。</font></p>
<p>即将<code>id_rsa.pub</code>秘钥添加到当前项目<code>researchlab.github.io</code>下<code>Settings</code>下的<code>Deploy keys</code>中，如图:</p>
<center><img src="/imgs/deploy_keys.png" alt="deploy_keys"></center>

<blockquote>
<p>记得要将 <code>Allow write access</code> 的选项选上，这样 Travis CI 才能获得 push 代码的权限。 </p>
</blockquote>
<ul>
<li>Travis CI 环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp ~/.ssh/id_rsa / <span class="comment">#将上一步得到的`id_rsa`复制到当前blog根目录下</span></span><br><span class="line">$ vim .travis.yml <span class="comment">#创建.travis.yml</span></span><br><span class="line">$ gem install travis <span class="comment">#安装Travis CI</span></span><br><span class="line">$ travis login --auto <span class="comment">#登录Travis CI，需要输入GitHub的账号密码</span></span><br><span class="line">$ travis encrypt-file ssh_key --add <span class="comment">#加密私钥并上传至Travis 注意这里的 ssh_key 要换成上面私钥的名称，即: travis encrypt-file id_rsa</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>:<br>gem 的官方源经常被qiang, 所以要注意更换gem sources,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gem sources <span class="comment">#查看原有的官方源</span></span><br><span class="line">gem <span class="built_in">source</span> -r https://rubygems.org/ <span class="comment"># 删除 rubygems 官方源</span></span><br><span class="line">gem <span class="built_in">source</span> <span class="operator">-a</span> http://mirrors.aliyun.com/rubygems/   <span class="comment"># 添加aliyun 源</span></span><br><span class="line">gem install travis --no-rdoc --no-ri --verbose  <span class="comment"># 安装Travis</span></span><br></pre></td></tr></table></figure></p>
<p><strong>生成提示</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">encrypting id_rsa <span class="keyword">for</span> researchlab/researchlab.github.io</span><br><span class="line">storing result as id_rsa.enc</span><br><span class="line">storing secure env variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Make sure to add id_rsa.enc to the git repository.</span><br><span class="line">Make sure not to add id_rsa to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure>
<p>生成加密过得新秘钥<code>id_rsa.enc</code>, 并自动将branch blog中git的信息及解密秘钥的相关信息添加到<code>.travis.yml</code>中。<strong> 然后手动删除私钥文件<code>id_rsa</code>， 以保证代码仓库的安全。</strong></p>
<ul>
<li>SSH的设置<br>在当前目录下新建文件ssh_config，内容为</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure>
<p>修改.travis.yml中的命令，指定openssl解密后的生成位置，xxxxxxxxxx部分就是你的解密参数，不要去改动它。<br>即将<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- openssl aes-<span class="number">256</span>-cbc -K <span class="variable">$encrypted_xxxxxxxxxx_key</span> -iv <span class="variable">$encrypted_xxxxxxxxxx_iv</span></span><br><span class="line">	-in id_rsa.enc -out id_rsa <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- openssl aes-<span class="number">256</span>-cbc -K <span class="variable">$encrypted_xxxxxxxxxx_key</span> -iv <span class="variable">$encrypted_xxxxxxxxxx_iv</span></span><br><span class="line">  -in id_rsa.enc -out ~/.ssh/id_rsa <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改目录权限<br>紧接着在.travis.yml中修改目录权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- chmod <span class="number">600</span> ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<ul>
<li>将密钥加入系统<br>紧接着在.travis.yml中将密钥加入系统</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">- ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<ul>
<li>修改git信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- cp ssh_config ~/.ssh/config</span><br><span class="line">- git config --global user.name <span class="string">"username"</span></span><br><span class="line">- git config --global user.email username@example.com</span><br></pre></td></tr></table></figure>
<ul>
<li>添加分支信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - blog</span><br></pre></td></tr></table></figure>
<ul>
<li>配置Hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">install:</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">- npm install hexo --save</span><br><span class="line">- npm install</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo g </span><br><span class="line">- hexo d</span><br></pre></td></tr></table></figure>
<p>这样就完成了<code>.travis.yml</code>的设置，这里是我的源文件<code>.travis.yml</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: node_js&#10;node_js:&#10;- &#39;0.12&#39;&#10;branches:&#10;  only:&#10;  - blog&#10;before_install:&#10;- openssl aes-256-cbc -K $encrypted_xxxxxxxxxx_key-iv $encrypted_xxxxxxxxxx_iv&#10;  -in id_rsa.enc -out ~/.ssh/id_rsa -d&#10;- chmod 600 ~/.ssh/id_rsa&#10;- eval $(ssh-agent)&#10;- ssh-add ~/.ssh/id_rsa&#10;- cp ssh_config ~/.ssh/config&#10;- git config --global user.name &#34;researchlab&#34;&#10;- git config --global user.email leehongitrd@163.com &#10;- git clone -b master git@github.com:researchlab/researchlab.github.io.git deploy_git&#10;install:&#10;- npm install hexo-cli -g&#10;- npm install&#10;- npm install hexo-generator-feed --save&#10;- npm install hexo-deployer-git --save&#10;script:&#10;- hexo clean&#10;- hexo g&#10;- hexo d</span><br></pre></td></tr></table></figure>
<p>这个时候应该将其push到blog分支,然后就可以了。</p>
<h2 id="u9047_u5230Authentication_failed"><a href="#u9047_u5230Authentication_failed" class="headerlink" title="遇到Authentication failed"></a>遇到Authentication failed</h2><p>提交之后，发现<code>Travis-ci</code> 每次到<code>hexo d</code> 这一步时就报错了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed <span class="keyword">for</span> <span class="string">'https://github.com/researchlab/researchlab.github.io.git/'</span></span><br><span class="line">FATAL Something<span class="string">'s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for '</span>https://github.com/researchlab/researchlab.github.io.git/<span class="string">'</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/home/travis/build/researchlab/researchlab.github.io/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:110:17)</span><br><span class="line">    at maybeClose (child_process.js:1019:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (child_process.js:1091:5)</span><br><span class="line">FATAL remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for '</span>https://github.com/researchlab/researchlab.github.io.git/<span class="string">'</span><br><span class="line">Error: remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for '</span>https://github.com/researchlab/researchlab.github.io.git/<span class="string">'</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/home/travis/build/researchlab/researchlab.github.io/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:110:17)</span><br><span class="line">    at maybeClose (child_process.js:1019:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (child_process.js:1091:5)</span><br><span class="line">The command "hexo d" exited with 2.</span><br><span class="line">cache.2</span><br><span class="line">store build cache</span><br><span class="line">0.00s</span><br><span class="line">2.99schanges detected, packing new archive</span><br><span class="line">FAILED: tar -Pzcf /home/travis/.casher/push.tgz </span><br><span class="line">tar: Cowardly refusing to create an empty archive</span><br><span class="line">Try `tar --help'</span> or `tar --usage<span class="string">' for more information.</span><br><span class="line">uploading archive</span><br><span class="line">failed to upload cache</span><br><span class="line">curl: Can'</span>t open <span class="string">'/home/travis/.casher/push.tgz'</span>!</span><br><span class="line">curl: try <span class="string">'curl --help'</span> or <span class="string">'curl --manual'</span> <span class="keyword">for</span> more information</span><br><span class="line">Done. Your build exited with <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<p>这是因为hexo 根目录下的 <code>_config.yml</code>中配置问题导致的：<br>把如下配置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Deployment&#10;## Docs: https://hexo.io/docs/deployment.html&#10;deploy:&#10;  type: git&#10;  repository: https://github.com/researchlab/researchlab.github.io.git&#10;  branch: master</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Deployment&#10;## Docs: https://hexo.io/docs/deployment.html&#10;deploy:&#10;  type: git&#10;  repository: git@github.com:researchlab/researchlab.github.io.git&#10;  branch: master</span><br></pre></td></tr></table></figure>
<p>问题即解决！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。&lt;code&gt;Travis CI&lt;/code&gt;就是一个在线的、分布式的持续集成服务，用来构建及测试在GitHub托管的代码。利用Travis CI 会在每一次push后生成一个虚拟机来执行事先安排好的自动构建任务，从来进行发布。本文就要用&lt;code&gt;Travis CI&lt;/code&gt;来自动构建&lt;code&gt;Hexo&lt;/code&gt;博客。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.grdtechs.com/categories/Hexo/"/>
    
    
      <category term="Blog" scheme="http://www.grdtechs.com/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://www.grdtechs.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>gin中使用设置cookie过期时间总结</title>
    <link href="http://www.grdtechs.com/2016/03/29/gin-setcookie/"/>
    <id>http://www.grdtechs.com/2016/03/29/gin-setcookie/</id>
    <published>2016-03-29T01:48:56.000Z</published>
    <updated>2016-12-18T09:17:06.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>可以操作<code>Cookie</code>的<code>Http</code>头有两个:<code>Set-Cookie</code>和<code>Cookie</code>。<code>Set-Cookie</code>由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个<code>Cookie</code>。<code>Cookie</code>头由客户端发送，包含在<code>HTTP</code>请求的头部中。<br><a id="more"></a></p>
<font color="red"><strong>注意：<br>1.只有cookie的domain和path与请求的URL匹配才会发送这个cookie;<br>2.客户端发送cookie信息给服务器只发送键-值对到服务器，cookie的属性是不会发送给服务器的。</strong></font>

<h2 id="u8BD5_u9A8C_u9700_u6C42"><a href="#u8BD5_u9A8C_u9700_u6C42" class="headerlink" title="试验需求"></a>试验需求</h2><p>1.服务器给客户端设置cookie，并设置过期时间，客户端每次请求服务器时如果cookie没有过期，则服务器将cookie相应的value 加1并重设cookie, 如果cookie 过期，则重新设置cookie让value 从0开始计数。</p>
<h2 id="u8BD5_u9A8C_u4EE3_u7801"><a href="#u8BD5_u9A8C_u4EE3_u7801" class="headerlink" title="试验代码"></a>试验代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Use(Counter()) <span class="comment">//这个是每个请求都会执行Counter()这个方法，</span></span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/counter"</span>, <span class="keyword">func</span>(c *gin.Context) &#123;</span><br><span class="line">		<span class="keyword">if</span> cookie, err := c.Request.Cookie(<span class="string">"counter"</span>); err == <span class="constant">nil</span> &#123;</span><br><span class="line">			c.String(http.StatusOK, cookie.Expires.String())</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			http.SetCookie(c.Writer, &amp;http.Cookie&#123;</span><br><span class="line">				Name:    <span class="string">"counter"</span>,</span><br><span class="line">				Value:   <span class="string">""</span>,</span><br><span class="line">				Expires: time.Now().Add(<span class="number">10</span> * time.Second),</span><br><span class="line">			&#125;)</span><br><span class="line">			c.String(http.StatusOK, <span class="string">"SetCookie ok"</span>)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">"server start from 8010"</span>)</span><br><span class="line">	r.Run(<span class="string">":8010"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Counter() gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(c *gin.Context) &#123;</span><br><span class="line">		<span class="keyword">if</span> cookie, err := c.Request.Cookie(<span class="string">"counter"</span>); err == <span class="constant">nil</span> &#123;</span><br><span class="line">			value := cookie.Value</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(value) == <span class="number">0</span> &#123;</span><br><span class="line">				cookie.Value = <span class="string">"0"</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> v, err := strconv.Atoi(value); err == <span class="constant">nil</span> &#123;</span><br><span class="line">					i := v + <span class="number">1</span></span><br><span class="line">					cookie.Value = fmt.Sprintf(<span class="string">"%d"</span>, i)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			http.SetCookie(c.Writer, cookie)</span><br><span class="line">			<span class="comment">//before request</span></span><br><span class="line">			c.Next()</span><br><span class="line">			<span class="comment">//after request</span></span><br><span class="line">			c.String(http.StatusOK, <span class="string">" counter:"</span>+cookie.Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4EE3_u7801_u5206_u6790"><a href="#u4EE3_u7801_u5206_u6790" class="headerlink" title="代码分析"></a>代码分析</h2><p>上述代码中<code>r.Use(Counter())</code>表示客户端每次发送一个请求给服务器，都会执行<code>Counter()</code>这个函数。比如客户端发送一个<code>http://localhost:8010/counter</code>的请求给服务器，则具体的处理流程为：先执行<code>Counter()</code>函数中的<code>c.Next()</code>前面的代码，当执行到<code>c.Next()</code>时， 先去执行<code>r.GET(&quot;/counter&quot;,func(c *gin.Context) {xxx}</code>中<code>xxx</code>程序体，当<code>xxx</code>程序体执行完之后，再执行<code>Counter()</code>函数中<code>c.Next()</code>之后的程序体，然后整个请求执行完毕。</p>
<p>回到上面的试验需求，第一次请求时没有cookie，此时服务器设置cookie并设置过期时间，第二次请求时如果还没有过期则在Counter中就能查到cookie,此时通过<code>Counter()</code>重新设置cookie, 但是注意：这里设置的cookie，因为Name与之前的cookie是一样的，所以此次设置的cookie的属性会覆盖之前的cookie的属性，因为此次只是改变cookie的value，而没有设置cookie的属性，所以此次设置cookie没有过期时间可言了。所以上述的试验需求是不合理的。或者说可以通过<code>redis</code>的操作去实现，但是不能仅靠设置<code>cookie</code>来实现这个需求。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><strong>服务器发送cookie给客户端</strong><br> 从服务器端，发送cookie给客户端，是对应的Set-Cookie。包括了对应的cookie的名称，值，以及各个属性。<br> 例如：<br>Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.169it.com; HttpOnly<br>Set-Cookie: made_write_conn=1295214458; Path=/; Domain=.169it.com<br>Set-Cookie: reg_fb_gate=deleted; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Path=/; Domain=.169it.com; HttpOnly</p>
<p><strong>从客户端把cookie发送到服务器</strong><br> 从客户端发送cookie给服务器的时候，是不发送cookie的各个属性的，而只是发送对应的名称和值。<br> 例如：<br>GET /spec.html HTTP/1.1<br>Host: www.example.org<br>Cookie: name=value; name2=value2<br>Accept: <em>/</em>  </p>
<font color="red">除了name=value对以外，我们还可以设置Cookie其他属性以支持更丰富的Cookie需求，<strong>这些属性通常是浏览器用来判断如何对待cookie，何时删除、屏蔽或者如何发送name-value对给Server。也就是说无论我们设置了某个cookie的多少属性，这些Cookie属性是不会被浏览器发送回给Server的。包括设置的过期时间也不会发送到服务器端</strong></font>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;可以操作&lt;code&gt;Cookie&lt;/code&gt;的&lt;code&gt;Http&lt;/code&gt;头有两个:&lt;code&gt;Set-Cookie&lt;/code&gt;和&lt;code&gt;Cookie&lt;/code&gt;。&lt;code&gt;Set-Cookie&lt;/code&gt;由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个&lt;code&gt;Cookie&lt;/code&gt;。&lt;code&gt;Cookie&lt;/code&gt;头由客户端发送，包含在&lt;code&gt;HTTP&lt;/code&gt;请求的头部中。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="gin" scheme="http://www.grdtechs.com/tags/gin/"/>
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="setcookie" scheme="http://www.grdtechs.com/tags/setcookie/"/>
    
  </entry>
  
  <entry>
    <title>golang类型转换(指定精度/四舍五入)</title>
    <link href="http://www.grdtechs.com/2016/03/24/go-type-convert/"/>
    <id>http://www.grdtechs.com/2016/03/24/go-type-convert/</id>
    <published>2016-03-24T02:06:54.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>Go</code>的数据类型很多都需要显示转换才能使用,比如<code>string</code>转<code>float64</code>指定精度等。转换中常用到的第三方包为<code>strconv</code>和<code>math</code>包。<br><a id="more"></a></p>
<h2 id="u6574_u578B_u8F6C_u5B57_u7B26_u4E32"><a href="#u6574_u578B_u8F6C_u5B57_u7B26_u4E32" class="headerlink" title="整型转字符串"></a>整型转字符串</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strconv.Itoa(i) <span class="comment">//方法1</span></span><br><span class="line">strconv.FormatInt(<span class="typename">int64</span>(i),<span class="number">10</span>) <span class="comment">//方法2</span></span><br></pre></td></tr></table></figure>
<h2 id="u5B57_u7B26_u4E32_u8F6C_u6574_u578B"><a href="#u5B57_u7B26_u4E32_u8F6C_u6574_u578B" class="headerlink" title="字符串转整型"></a>字符串转整型</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strconv.Atoi(s) <span class="comment">//方法1</span></span><br><span class="line">strconv.ParseInt(s,<span class="number">10</span>,<span class="number">0</span>) <span class="comment">//方法2</span></span><br></pre></td></tr></table></figure>
<h2 id="bytes_u8F6Cfloat64"><a href="#bytes_u8F6Cfloat64" class="headerlink" title="bytes转float64"></a>bytes转float64</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> bytesToFloat64(bytes []<span class="typename">byte</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	bits := binary.LittleEndian.Uint64(bytes)</span><br><span class="line">	<span class="keyword">return</span> math.Float64frombits(bits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="float64_u8F6Cbytes"><a href="#float64_u8F6Cbytes" class="headerlink" title="float64转bytes"></a>float64转bytes</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> float64ToBytes(input <span class="typename">float64</span>) []<span class="typename">byte</span> &#123;</span><br><span class="line">	bits := math.Float64bits(input)</span><br><span class="line">	bytes := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number">8</span>) <span class="comment">//这里表示[]uint8, 所以用了 8</span></span><br><span class="line">	binary.LittleEndian.PutUint64(bytes,bits)</span><br><span class="line">	<span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="float64_u8F6Cstring"><a href="#float64_u8F6Cstring" class="headerlink" title="float64转string"></a>float64转string</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> FloatToStr(num <span class="typename">float64</span>, floatPartLen <span class="typename">int</span>) <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.FormatFloat(num,<span class="string">'f'</span>,floatPartLen,<span class="number">64</span>) <span class="comment">//这里64改为32，则表示float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string_u8F6Cfloat64"><a href="#string_u8F6Cfloat64" class="headerlink" title="string转float64"></a>string转float64</h2><p><code>string</code>转<code>float64</code> 这里有两种方法，都支持指定精度。<strong> 注意：所有数字要在表现层显示最好转换为字符串传送给表现层，如果用于后端计算则转换为数字即可。比如：数字2.10 如果用保持5位数字精度显示： 那么 数字2.10 显示为：2.1, 而将2.10转换为字符串同时保持5位精度，则显示为: 2.10000。但是它们都是转换为了5位精度的，只是显示的时候，数字2.10000 直接显示为2.1了， 所以要显示精度则转换为字符串，要用于计算则转换为数字。</strong></p>
<p>方法1： 只支持指定精度<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> strToFloat64(str <span class="typename">string</span>, <span class="built_in">len</span> <span class="typename">int</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	lenstr := <span class="string">"%."</span> + strconv.Itoa(<span class="built_in">len</span>) + <span class="string">"f"</span></span><br><span class="line">	value,_ := strconv.ParseFloat(str,<span class="number">64</span>)</span><br><span class="line">	nstr := fmt.Sprintf(lenstr,value)</span><br><span class="line">	val,_ := strconv.ParseFloat(nstr,<span class="number">64</span>)</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法2：支持指定精度，支持是否四舍五入<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> strToFloat64Round(str <span class="typename">string</span>, prec <span class="typename">int</span>, round <span class="typename">bool</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	f,_ := strconv.ParseFloat(str,<span class="number">64</span>)</span><br><span class="line">	<span class="keyword">return</span> Precision(f,prec,round)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Precision(f <span class="typename">float64</span>, prec <span class="typename">int</span>, round <span class="typename">bool</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	pow10_n := math.Pow10(prec)</span><br><span class="line">	<span class="keyword">if</span> round &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Trunc(f + <span class="number">0.5</span>/pow10_n)*pow10_n) / pow10_n	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> math.Trunc((f)*pow10_n) / pow10_n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体请参考[<a href="https://github.com/researchlab/golearning/blob/master/base/convert.go" target="_blank" rel="external">示例代码</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;的数据类型很多都需要显示转换才能使用,比如&lt;code&gt;string&lt;/code&gt;转&lt;code&gt;float64&lt;/code&gt;指定精度等。转换中常用到的第三方包为&lt;code&gt;strconv&lt;/code&gt;和&lt;code&gt;math&lt;/code&gt;包。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 设计模式之observer使用总结</title>
    <link href="http://www.grdtechs.com/2016/02/26/observer-pattern-in-go-md/"/>
    <id>http://www.grdtechs.com/2016/02/26/observer-pattern-in-go-md/</id>
    <published>2016-02-26T00:40:11.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>观察者(<code>Observer</code>)设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。观察者模式将观察者和被观察的对象分离开,体现了面向对象设计中一个对象只做一件事情的原则，提高了应用程序的可维护性和重用性。<br><a id="more"></a></p>
<h2 id="u5B9E_u73B0_u89C2_u5BDF_u8005_u6A21_u5F0F"><a href="#u5B9E_u73B0_u89C2_u5BDF_u8005_u6A21_u5F0F" class="headerlink" title="实现观察者模式"></a>实现观察者模式</h2><p>观察者模式有很多实现方式，从根本上说，该模式必须包含两个角色：观察者(Observer)和被观察对象(Subject)。</p>
<p><center><img src="/imgs/observer_pattern.jpg" alt="observer_pattern"></center></p>
<ul>
<li><p>观察者<br>观察者（<code>Observer</code>）将自己注册到被观察对象（<code>Subject</code>）中，被观察对象将观察者存放在一个容器（<code>Container</code>）里。</p>
</li>
<li><p>被观察<br>被观察对象(<code>Subject</code>)发生了某种变化，从容器中得到所有注册过的观察者，将变化通知观察者(<code>notifyObservers</code>)。</p>
</li>
<li><p>撤销观察<br>观察者告诉被观察者要撤销观察，被观察者从容器中将观察者去除。<br><strong>观察者将自己注册到被观察者的容器中时，被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口。</strong>这样的优点是：假定程序中还有别的观察者，那么只要这个观察者也是相同的接口实现即可。一个被观察者可以对应多个观察者，当被观察者发生变化的时候，它可以将消息一一通知给所有的观察者。基于接口，而不是具体的实现——这一点为程序提供了更大的灵活性。<br>下面通过构建一个股民(<code>Observer</code>)和他们关注的某支具体股票(<code>Subject</code>)案例分析,<br>首先观察者(<code>Observer</code>)要能注册/注销到某个被观察者(<code>Subject</code>)中，同时被观察者(<code>Subject</code>)发送变化时要能够通知到依赖它的观察者(<code>Observer</code>),由此我们需要声明一个被观察者(<code>Subject</code>)的接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subject被观察者接口</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">	Attach(Observer)</span><br><span class="line">	Detach(Observer)</span><br><span class="line">	Notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>遵循被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口的原则，当被观察者(<code>Subject</code>)因自身改变通知观察者(<code>Observer</code>)改变时，应提供一个观察者(<code>Observer</code>)接口供被观察者(<code>Subject</code>)调用:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer观察者</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Update(Subject, <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口设计好之后，就需要通过具体的对象来实现这些接口，在这个案例中假定股民关注的是中国石油这只股票，那么股票就是观察者(<code>Observer</code>),而中国石油股票则是被观察者(<code>Subject</code>),具体结构如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体observer观察者</span></span><br><span class="line"><span class="keyword">type</span> Investors <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/*投资人*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体subject被观察者</span></span><br><span class="line"><span class="keyword">type</span> ChinaPetroleum <span class="keyword">struct</span> &#123;</span><br><span class="line">	oblist []Observer <span class="comment">//注册者链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观察者(&lt;code&gt;Observer&lt;/code&gt;)设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。观察者模式将观察者和被观察的对象分离开,体现了面向对象设计中一个对象只做一件事情的原则，提高了应用程序的可维护性和重用性。&lt;br&gt;
    
    </summary>
    
      <category term="go-pattern" scheme="http://www.grdtechs.com/categories/go-pattern/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="observer" scheme="http://www.grdtechs.com/tags/observer/"/>
    
  </entry>
  
  <entry>
    <title>golang 设计模式之singleton使用总结</title>
    <link href="http://www.grdtechs.com/2016/02/25/singleton-pattern-in-go/"/>
    <id>http://www.grdtechs.com/2016/02/25/singleton-pattern-in-go/</id>
    <published>2016-02-25T17:01:43.000Z</published>
    <updated>2016-12-18T09:17:06.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>golang</code> 1.5版本之后默认设置<code>GOMAXPROCS</code>值为当前计算机真实核心数，使得<code>goroutines</code>从默认的<code>单线程内并发执行</code>变成了默认的（真实核心数支持的）的<code>多线程内并行</code>执行。多线程并行执行<code>goroutines</code>需要考虑并行执行过程中引入的<code>线程安全问题</code>。<br><a id="more"></a></p>
<h2 id="u5355_u7EBF_u7A0Bsingleton_u6A21_u578B"><a href="#u5355_u7EBF_u7A0Bsingleton_u6A21_u578B" class="headerlink" title="单线程singleton模型"></a>单线程singleton模型</h2><p>单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。先摘取一个在实际工作项目中碰到的singleton模型代码:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="constant">nil</span> &#123;</span><br><span class="line">       instance = &amp;singleton&#123;&#125;   <span class="comment">// 没有考虑线程安全 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>singleton</code>设计代码在见过的几个<code>golang</code>项目中都是这么写的，如果这段代码放在<code>golang</code>1.5版本之前默认的单线程场景下运行显然是没什么问题的。<code>golang</code>1.5版本之后默认是启动多核并行执行<code>goroutines</code>的，如果上述代码放在<code>golang</code>1.5版本之后，如果程序开启n个<code>goroutines</code>初始化一个<code>singleton</code>对象, 显然会初始化成功最少一个最多n个<code>singleton</code>对象，从而会存在潜在的多个单例实例对象了，也就不可能保证这个<code>singleton</code>对象全局唯一性了，那后继采用<code>singleton</code>对象进行全局唯一性操作时势必会造成数据不一致的问题。如果场景中但个<code>goroutines</code>执行时间短的话，会使得调试更难。</p>
<h2 id="u91C7_u7528_u4E92_u65A5_u9501_u673A_u5236"><a href="#u91C7_u7528_u4E92_u65A5_u9501_u673A_u5236" class="headerlink" title="采用互斥锁机制"></a>采用互斥锁机制</h2><p>面对上述线程安全问题，一般会考虑到用锁机制(<code>Mutex</code>)来解决因线程安全引入的数据不一致问题，采用锁机制如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">    mu.Lock()                    <span class="comment">// singleton实例对象操作之后，锁就是多余的了 </span></span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="constant">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码可以看到，引入锁机制<code>Sync.Mutex</code>后，能够保证多线程并行执行<code>goroutines</code>创建的<code>singleton</code>实例对象是唯一的，但是当这个<code>singleton</code>实例对象被初始化创建之后，再次并行来创建<code>singleton</code>实例对象时，其实已经不再需要锁了，因为已经存在了一个创建好的<code>singleton</code>实例对象，所以直接返回即可;但是因为锁机制的存在，使得再次创建<code>singleton</code>实例对象时，还是需要先获取锁，然后在判断处理，多线程执行中这种锁竞争使得多线程的并行执行变成了多线程的串行执行，这显然会使程序丧失并行执行带来的性能提升。在一个高度并行的程序中，这样显示会是抑制程序性能提升的一个瓶颈。</p>
<h2 id="u91C7_u7528_u53CC_u91CD_u68C0_u67E5_u9501_u673A_u5236"><a href="#u91C7_u7528_u53CC_u91CD_u68C0_u67E5_u9501_u673A_u5236" class="headerlink" title="采用双重检查锁机制"></a>采用双重检查锁机制</h2><p>在<code>C++</code>等编程语言中，为了同时保证最小锁和线程安全通常采用的方法是<code>双重检查锁(Check-Lock-Check)</code>机制，也表述为<code>DCL(Double Check Lock)</code>。<code>双重检查锁</code>机制的伪代码一般是下面的这种形式:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> check() &#123;</span><br><span class="line">    lock() &#123;</span><br><span class="line">       <span class="keyword">if</span> check() &#123;</span><br><span class="line">           <span class="comment">// 锁安全代码 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实对这个<code>singleton</code>实例对象来说，只有在第一次创建实例的时候才需要同步，所以为了减少同步，先check一下，判断<code>singleton</code>实例对象是否为空，如果为空，表示是第一使用这个<code>singleton</code>实例对象，那就锁住它，new一个<code>singleton</code>实例，下次另一个线程来<code>GetInstance</code>的时候，看到这个<code>singleton</code>实例对象不为空，就表示已经创建过一个实例了，那就可以直接得到这个实例，避免再次锁。这是第一个 check的作用。 </p>
<p>第二个check是解决锁竞争情况下的问题，假设现在两个线程来请求<code>GetInstance</code>，A、B线程同时发现<code>singleton</code>实例对象为空，因为我们在第一次check方法上没有加锁，然后A线程率先获得锁，进入同步代码块，new了一个<code>singleton</code>实例对象，之后释放锁，接着B线程获得了这个锁，发现<code>singleton</code>实例对象已经被创建了，就直接释放锁，退出同步代码块。所以这就是<code>Check-Lock-Check</code>; 将上面的<code>singleton</code>实例用<code>Check-Lock-Check</code>机制实现如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="constant">nil</span> &#123; </span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="constant">nil</span> &#123;</span><br><span class="line">	            instance = &amp;singleton&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的<code>Check-Lock-Check</code>机制,的确可以解决锁竟争的问题，但是这种方法不管是否<code>singleton</code>实例对象是否已创建，每次都要执行两次check才是一个完整的判断，那有没有方法使得只要一次check就可以完成对<code>singleton</code>实例对象是否存在的检查呢？ 有！通过<code>golang</code>的<code>sync/atomic</code>包提供的原子性操作可以更高效的完成这个检查，改进代码如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync/atomic"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialized <span class="typename">uint32</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> atomic.LoadUInt32(&amp;initialized) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initialized == <span class="number">0</span> &#123;</span><br><span class="line">         instance = &amp;singleton&#123;&#125;</span><br><span class="line">         atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改进之后的代码通过设置一个标志操作，使得<code>singleton</code>实例对象创建之后，直接通过原子操作读取标志字段的值判断返回已经存在的实例，连锁操作及其后面的代码都略过了。</p>
<h2 id="u91C7_u7528atomic_u8FDB_u4E00_u6B65_u7B80_u5316"><a href="#u91C7_u7528atomic_u8FDB_u4E00_u6B65_u7B80_u5316" class="headerlink" title="采用atomic进一步简化"></a>采用atomic进一步简化</h2><p>上面通过<code>Check-Lock-Check</code>机制改进之后似乎没有什么可做的了，先不急，来看看<code>golang</code>原生标准包<code>sync</code>包中对<code>Once</code>实现的源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	m    Mutex</span><br><span class="line">	done <span class="typename">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do calls the function f if and only if Do is being called for the</span></span><br><span class="line"><span class="comment">// first time for this instance of Once. In other words, given</span></span><br><span class="line"><span class="comment">//	var once Once</span></span><br><span class="line"><span class="comment">// if once.Do(f) is called multiple times, only the first call will invoke f,</span></span><br><span class="line"><span class="comment">// even if f has a different value in each invocation.  A new instance of</span></span><br><span class="line"><span class="comment">// Once is required for each function to execute.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do is intended for initialization that must be run exactly once.  Since f</span></span><br><span class="line"><span class="comment">// is niladic, it may be necessary to use a function literal to capture the</span></span><br><span class="line"><span class="comment">// arguments to a function to be invoked by Do:</span></span><br><span class="line"><span class="comment">//	config.once.Do(func() &#123; config.init(filename) &#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because no call to Do returns until the one call to f returns, if f causes</span></span><br><span class="line"><span class="comment">// Do to be called, it will deadlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, Do considers it to have returned; future calls of Do return</span></span><br><span class="line"><span class="comment">// without calling f.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">func</span> (o *Once) Do(f <span class="keyword">func</span>()) &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> &#123; <span class="comment">// &lt;-- Check</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow-path.</span></span><br><span class="line">	o.m.Lock()                           <span class="comment">// &lt;-- Lock</span></span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;                     <span class="comment">// &lt;-- Check</span></span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们之前其实是借鉴了<code>golang</code>原生标准包<code>sync</code>中对<code>Once</code>实现对源码，那既然标准包中已经实现了这个<code>Check-Lock-Check</code>机制，那我们直接调用<code>sync</code>包提供<code>once.Do()</code>方法对某个方法只进行一次性调用：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">once.Do(<span class="keyword">func</span>() &#123;</span><br><span class="line">	 <span class="comment">// perform safe initialization here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么下面是根据<code>sync</code>包提供的<code>sync.Once</code>改进的获取<code>singleton</code>实例对象最终优化版本:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">    once.Do(<span class="keyword">func</span>() &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此使用<code>sync</code>包提供的<code>sync.Once</code>实现获取<code>singleton</code>实例对象可以说是最安全有效又简洁的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;golang&lt;/code&gt; 1.5版本之后默认设置&lt;code&gt;GOMAXPROCS&lt;/code&gt;值为当前计算机真实核心数，使得&lt;code&gt;goroutines&lt;/code&gt;从默认的&lt;code&gt;单线程内并发执行&lt;/code&gt;变成了默认的（真实核心数支持的）的&lt;code&gt;多线程内并行&lt;/code&gt;执行。多线程并行执行&lt;code&gt;goroutines&lt;/code&gt;需要考虑并行执行过程中引入的&lt;code&gt;线程安全问题&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="go-pattern" scheme="http://www.grdtechs.com/categories/go-pattern/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="singleton" scheme="http://www.grdtechs.com/tags/singleton/"/>
    
  </entry>
  
</feed>
