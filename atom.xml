<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朴实的一线攻城狮</title>
  <subtitle>十年磨一剑，一步一步脚踏实地的耕种</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.grdtechs.com/"/>
  <updated>2017-03-03T03:59:22.287Z</updated>
  <id>http://www.grdtechs.com/</id>
  
  <author>
    <name>Lee Hong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于fzzy/radix/redis封装新的redispool</title>
    <link href="http://www.grdtechs.com/2017/03/02/redispool-baseon-fzzy-radix/"/>
    <id>http://www.grdtechs.com/2017/03/02/redispool-baseon-fzzy-radix/</id>
    <published>2017-03-02T14:42:42.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>之前的老项目的redis client sdk 直接大名鼎鼎的<code>github.com/fzzy/radix</code>提供的<code>redis client</code> 和<code>redis pool</code>, 当访问峰值达到一定的值后会出现<code>too many open files</code>等tcp连接错误，同时也没有直接提供authorization 密钥认证的接口，为满足这些新需求基于<code>fzzy/radix</code>封装出的新的<code>redispool</code>, 已投入生产使用半年来暂无问题，本文总结如下,<br><a id="more"></a></p>
<h2 id="auth_u8BA4_u8BC1"><a href="#auth_u8BA4_u8BC1" class="headerlink" title="auth认证"></a>auth认证</h2><p>如果redis server 需要密钥访问的话，每新建一个client 连接后都需要先通过authorization认证之后才能被使用，如果每次都通过新建一个redis client 再oauth认证来用显然没什么问题，但对于要频繁进行redis操作的系统而言，最好采用redis pool 的办法来解决，用redis conn 池本来也很好解决， 就是在新建redis conn pool时 每新建一个redis client就auth认证一下然后再保存起来就可以使用了，并且这个连接以后都不需要在进行auth认证了。<br>如果redis pool在新建之后就固定的话， 是可以如上面这么简单的，但是采用的<code>fzzy/radix</code>包在实现的方案是可根据需要自动伸缩地新建redis client conn,之前设置的redis 连接池的大小其实是最小的空闲连接池，当业务需求需要的redis client连接数大于pool中的数目时则会通过redis.Dial()的方法新建一个redis client conn 以满足业务的需求，即在建立redis连接池的时候auth认证的redis client conn 和最后回到pool池中的redis client conn 可能就不是同一个client了，因为当新的redis client conn 塞满redis 连接池后 之前auth认证过的旧的redis client conn就会被Close关闭到而不再回到pool池中，具体实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (p *RedisPool) getRedisClient() (*redis.Client, error) &#123;</span><br><span class="line">	client, err := redis.Dial(p.network, p.addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.pwd) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> client, err = p.redisAuth(client); err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="constant">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> client, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (p *RedisPool) redisAuth(client *redis.Client) (*redis.Client, error) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := client.Cmd(<span class="string">"AUTH"</span>, p.pwd).Str(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">		client.Close()</span><br><span class="line">		<span class="keyword">return</span> client, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> client, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码提供了一个redisAuth方法来提供auth认证，这样不管是通过新建redis池还是当池中redis client conn耗尽之后单独新建的redis client 都通过上述提供getRedisClient()方法来获取新建的redis client conn ,这样便可保证每次新建的redis client conn 都是通过auth认证的(当然上次实现的时候如果没有设置密码，则不进行密钥认证，只有设置了密钥才会调用auth进行认证授权)。</p>
<h2 id="qps_u9650_u5236"><a href="#qps_u9650_u5236" class="headerlink" title="qps限制"></a>qps限制</h2><p>因为<code>fzzy/radix</code>包当初始化创建的redis 连接池中的redis client 耗尽后会通过redis.Dial()方法新建一个redis.client, 如果在某一个峰值redis连接池耗尽的同时大量新建redis.client 而不能及时Close掉这些redis.Client,则后继再redis.Dial()新建的redis client conn 就会因为受系统限制无法分配文件句柄地址而报”too many open files”错误。具体试验可以先限制redis连接池为100, 然后同时发起10w redis 连接请求， 可以通过下面的命令观察到当redis client conn最大分配的大小，超过之后程序也会崩掉。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch -n <span class="number">1</span> <span class="string">"redis-cli -h localhost -p 6379 -a 123456 client list | wc -l"</span> <span class="comment"># redis client 连接数</span></span><br><span class="line">watch -n <span class="number">1</span> <span class="string">"lsof -i:6379 | wc -l "</span> <span class="comment"># redis tcp 连接数</span></span><br></pre></td></tr></table></figure></p>
<p>上述命令可以动态看到每一秒内当前的redis client 连接数目 和 tcp 连接数</p>
<p>显然程序不能仍由业务需求无限的取申请redis client 连接数， 本文设计通过每次成功Get到一个redis client时 则通过<code>sync/atomic</code>包原子的给qps新增一 进行计数，当Put到池或Empty全部清空时则进行减一 计数操作, 具体实现如下,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrieves an available redis client. If there are none available it will</span></span><br><span class="line"><span class="comment">// create a new one on the fly</span></span><br><span class="line"><span class="keyword">func</span> (p *RedisPool) Get() (client *redis.Client, err error) &#123;</span><br><span class="line">	<span class="keyword">if</span> p.qpsLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> p.qps &gt; p.qpsLimit &#123;</span><br><span class="line">			time.Sleep(time.Millisecond * time.Duration(<span class="number">10</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> client, err = p.get(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> pstate, perr := client.Cmd(<span class="string">"PING"</span>).Str(); pstate == <span class="string">"PONG"</span> &amp;&amp; perr == <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="constant">nil</span> &#123;</span><br><span class="line">		atomic.AddInt32(&amp;p.qps, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a client back to the pool. If the pool is full the client is closed</span></span><br><span class="line"><span class="comment">// instead. If the client is already closed (due to connection failure or</span></span><br><span class="line"><span class="comment">// what-have-you) it should not be put back in the pool. The pool will create</span></span><br><span class="line"><span class="comment">// more connections as needed.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (p *RedisPool) Put(conn *redis.Client) &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.pool &lt;- conn:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		conn.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.qps &gt; <span class="number">0</span> &#123;</span><br><span class="line">		atomic.AddInt32(&amp;p.qps, -<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes and calls Close() on all the connections currently in the pool.</span></span><br><span class="line"><span class="comment">// Assuming there are no other connections waiting to be Put back this method</span></span><br><span class="line"><span class="comment">// effectively closes and cleans up the pool.</span></span><br><span class="line"><span class="keyword">func</span> (p *RedisPool) Empty() &#123;</span><br><span class="line">	<span class="keyword">var</span> conn *redis.Client</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> conn = &lt;-p.pool:</span><br><span class="line">			conn.Close()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p.qps &gt; <span class="number">0</span> &#123;</span><br><span class="line">			atomic.AddInt32(&amp;p.qps, -<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的代码设计及测试代码请参见: <a href="https://github.com/researchlab/experiments/tree/master/redispool" target="_blank" rel="external">https://github.com/researchlab/experiments/tree/master/redispool</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的老项目的redis client sdk 直接大名鼎鼎的&lt;code&gt;github.com/fzzy/radix&lt;/code&gt;提供的&lt;code&gt;redis client&lt;/code&gt; 和&lt;code&gt;redis pool&lt;/code&gt;, 当访问峰值达到一定的值后会出现&lt;code&gt;too many open files&lt;/code&gt;等tcp连接错误，同时也没有直接提供authorization 密钥认证的接口，为满足这些新需求基于&lt;code&gt;fzzy/radix&lt;/code&gt;封装出的新的&lt;code&gt;redispool&lt;/code&gt;, 已投入生产使用半年来暂无问题，本文总结如下,&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="redispool" scheme="http://www.grdtechs.com/tags/redispool/"/>
    
  </entry>
  
  <entry>
    <title>beego/orm使用总结</title>
    <link href="http://www.grdtechs.com/2017/03/01/use-beego-orm-summary/"/>
    <id>http://www.grdtechs.com/2017/03/01/use-beego-orm-summary/</id>
    <published>2017-03-01T10:44:29.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>很早之前的一个老项目就使用过ORM，当时使用的是<code>xorm</code>，后来新的项目设计说考虑性能什么的又用写原生sql来做了，在项目中使用一直没什么问题， 但是代码中到处写着原生的sql语句,并且有很多重复的语句，很不好维护，于是最近又重新考虑采用orm的方式来操作数据库，最近看中<code>beego/orm</code>这个包， 它的官方文档也写了很详细的使用说明，下面还是简要总结一下自己在项目中的使用经历,<br><a id="more"></a></p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM, 即Object-Relational Mapping(对象关系映射)，它的作用是在关系型数据库和业务实体对象之间作一个映射，这样在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。</p>
<p><strong> 优势 </strong> </p>
<ul>
<li><p>隐藏了数据访问细节，也是ORM的核心所在, “封闭”的通用数据库交互。使数据库交互变得简单易行，并且完全不用考虑SQL语句。快速开发，由此而来。</p>
</li>
<li><p>ORM使构造固化数据结构变得简单易行。在使用ORM之前, 需要将对象模型转化为一条一条的SQL语句，通过直连或是DB helper在关系数据库构造想要的数据库体系。而基本上所有的ORM框架都提供了通过对象模型构造关系数据库结构的功能。</p>
</li>
</ul>
<p>ORM有优势也存在缺点，</p>
<p><strong> 缺点 </strong></p>
<ul>
<li><p>无可避免的，自动化意味着映射和关联管理，代价是牺牲性能(早期，这是所有不喜欢ORM人的共同点)。现各种ORM框架都在尝试使用各种方法来减轻这块(LazyLoad，Cache),效果还是很显著的。</p>
</li>
<li><p>面向对象的查询语言(X-QL)作为一种数据库与对象之间的过渡, 虽然隐藏了数据层面的业务抽象, 但并不能完全的屏蔽掉数据库层的设计, 并且无疑将增加学习成本。</p>
</li>
<li><p>对于复杂查询，ORM仍然力不从心。虽然可以实现，但是不值的。视图可以解决大部分calculated column，case，group，having, order by, exists，但是查询条件(a and b and not c and (d or d))。</p>
</li>
</ul>
<p>从ORM优缺点来看， ORM适合使用在较大型复杂的系统中或数据库操作很多的系统中， 当即便使用了ORM的复杂项目在特殊情况下也应考虑用原生SQL来解决复杂查询和性能问题，小的项目则看性能苛刻来考虑了，如果性能苛刻则用原生的SQL实现更合适，如果没有什么要求则用不用ORM都没啥关系。</p>
<h2 id="beego/orm__u4F7F_u7528"><a href="#beego/orm__u4F7F_u7528" class="headerlink" title="beego/orm 使用"></a>beego/orm 使用</h2><p>据beego/orm官方文档说明目前其还处在开发中只支持<code>MySQL</code>,<code>PostgreSQL</code>, <code>Sqlite3</code>三种数据库驱动，目前beego/orm包支持以下特性,</p>
<ul>
<li>支持 Go 的所有类型存储</li>
<li>轻松上手，采用简单的 CRUD 风格</li>
<li>自动 Join 关联表</li>
<li>跨数据库兼容查询</li>
<li>允许直接使用 SQL 查询／映射</li>
<li>严格完整的测试保证 ORM 的稳定与健壮</li>
</ul>
<p>官方使用案例,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span> <span class="comment">//import your used driver</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model Struct</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="typename">int</span></span><br><span class="line">	Name <span class="typename">string</span> <span class="string">`orm:"size(100)"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> init() &#123;</span><br><span class="line">	<span class="comment">// set default database</span></span><br><span class="line">	orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, <span class="string">"root:123456@/my_db?charset=utf8"</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// register model</span></span><br><span class="line">	orm.RegisterModel(<span class="built_in">new</span>(User))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create table</span></span><br><span class="line">	orm.RunSyncdb(<span class="string">"default"</span>, <span class="constant">false</span>, <span class="constant">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line">	user := User&#123;Name: <span class="string">"slene"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert</span></span><br><span class="line">	id, err := o.Insert(&amp;user)</span><br><span class="line">	fmt.Printf(<span class="string">"ID: %d, ERR: %v\n"</span>, id, err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update</span></span><br><span class="line">	user.Name = <span class="string">"astaxie"</span></span><br><span class="line">	num, err := o.Update(&amp;user)</span><br><span class="line">	fmt.Printf(<span class="string">"NUM: %d, ERR: %v\n"</span>, num, err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read one</span></span><br><span class="line">	u := User&#123;Id: user.Id&#125;</span><br><span class="line">	err = o.Read(&amp;u)</span><br><span class="line">	fmt.Printf(<span class="string">"ERR: %v\n"</span>, err)</span><br><span class="line">	fmt.Println(<span class="string">"u:"</span>, u)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delete</span></span><br><span class="line">	num, err = o.Delete(&amp;u)</span><br><span class="line">	fmt.Printf(<span class="string">"NUM: %d, ERR: %v\n"</span>, num, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码可知，使用ORM大致分以下几步，<br>1.注册数据库;<br>2.注册待使用的数据库表结构对象;<br>3.在数据库中生成上述注册的数据库表结构对象;<br>4.得到一个待操作ORMER对象;<br>5.用上述的得到ORMER对象即可对数据库进行CURD操作了。</p>
<p>可以看到整个过程几乎不用写SQL语句， 并且逻辑清晰，当然性能方面跟直接用原生的SQL语句写肯定要差一些，因为beego/orm源码里面为了判断数据类型/转换数据类型等用了很多反射/强转等操作，这样做虽然是为了最大限度兼容各类数据操作，但对于本就不涉及复杂繁多的SQL的系统而言， 还是多考虑用原生SQL语句来写了。</p>
<p>下面是工作中应用抽取出来的一个代码片段，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	DEBUG = <span class="constant">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db orm.Ormer</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> init() &#123;</span><br><span class="line">	orm.RegisterDriver(<span class="string">"mysql"</span>, orm.DRMySQL)</span><br><span class="line">	err := orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, *dsn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"connect database error: %v\n"</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"connect db success"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	orm.RegisterModel(<span class="built_in">new</span>(Record))</span><br><span class="line"></span><br><span class="line">	err = orm.RunSyncdb(<span class="string">"default"</span>, <span class="constant">false</span>, <span class="constant">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		log.Fatalf(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	db = orm.NewOrm()</span><br><span class="line">	<span class="keyword">if</span> DEBUG &#123;</span><br><span class="line">		orm.Debug = <span class="constant">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	recordsChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Record, *insertBatchNum)</span><br><span class="line">	recordInsterLoop(done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetDB() orm.Ormer &#123;</span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> newRecord(param *requestParameter, resp *responseData) *Record &#123;</span><br><span class="line">	r := <span class="built_in">new</span>(Record)</span><br><span class="line">	r.Src = param.values.Get(<span class="string">"src"</span>)</span><br><span class="line">	r.OpenID = param.values.Get(<span class="string">"openid"</span>)</span><br><span class="line">	r.IdempotentStr = param.values.Get(<span class="string">"idempotent_str"</span>)</span><br><span class="line">	r.Noncestr = param.values.Get(<span class="string">"noncestr"</span>)</span><br><span class="line">	r.ReqTimestamp, _ = strconv.Atoi(param.values.Get(<span class="string">"timestamp"</span>))</span><br><span class="line">	r.ActivityID, _ = strconv.Atoi(param.values.Get(<span class="string">"activity_id"</span>))</span><br><span class="line">	r.BatchID, _ = strconv.Atoi(param.values.Get(<span class="string">"batch_id"</span>))</span><br><span class="line">	r.Sign = param.values.Get(<span class="string">"sign"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> resp != <span class="constant">nil</span> &#123;</span><br><span class="line">		r.ErrorCode = resp.ErrorCode</span><br><span class="line">		r.ErrorMsg = resp.ErrorMsg</span><br><span class="line">		<span class="keyword">if</span> resp.Timestamp == <span class="number">0</span> &#123;</span><br><span class="line">			r.RespTimestamp = <span class="typename">int</span>(time.Now().Unix())</span><br><span class="line">		&#125;</span><br><span class="line">		r.CouponID = resp.CouponID</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID            <span class="typename">int</span>    <span class="string">`orm:"column(id)" json:"record_id"`</span></span><br><span class="line">	Src           <span class="typename">string</span> <span class="string">`json:"str"`</span></span><br><span class="line">	OpenID        <span class="typename">string</span> <span class="string">`orm:"column(open_id)" json:"open_id"`</span></span><br><span class="line">	IdempotentStr <span class="typename">string</span> <span class="string">`json:"idempotent_str"`</span></span><br><span class="line">	Noncestr      <span class="typename">string</span> <span class="string">`json:"noncestr"`</span></span><br><span class="line">	ReqTimestamp  <span class="typename">int</span>    <span class="string">`json:"req_timestamp"`</span></span><br><span class="line">	ActivityID    <span class="typename">int</span>    <span class="string">`orm:"column(activity_id)" json:"activity_id"`</span></span><br><span class="line">	BatchID       <span class="typename">int</span>    <span class="string">`orm:"column(batch_id)" json:"batch_id"`</span></span><br><span class="line">	Sign          <span class="typename">string</span> <span class="string">`json:"sign"`</span></span><br><span class="line">	ErrorCode     <span class="typename">int</span>    <span class="string">`json:"error_code"`</span></span><br><span class="line">	ErrorMsg      <span class="typename">string</span> <span class="string">`json:"error_msg"`</span></span><br><span class="line">	RespTimestamp <span class="typename">int</span>    <span class="string">`json:"resp_timestamp"`</span></span><br><span class="line">	CouponID      <span class="typename">int</span>    <span class="string">`orm:"column(coupon_id)" json:"coupon_id"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (Record) TableName() <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"records"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recordsChan <span class="keyword">chan</span> *Record</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (r *Record) InsertRecord() &#123;</span><br><span class="line">	recordsChan &lt;- r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> recordInsterLoop(done &lt;-<span class="keyword">chan</span> <span class="typename">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		records := <span class="built_in">make</span>([]*Record, <span class="number">0</span>, *insertBatchNum)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				recordCopy := Copyrecode(records)</span><br><span class="line">				insertMulti(recordLen, recordCopy)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(time.Duration(<span class="number">5</span>) * time.Second):</span><br><span class="line"></span><br><span class="line">				recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">				insertMulti(recordLen, recordCopy)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> r := &lt;-recordsChan:</span><br><span class="line">				records = <span class="built_in">append</span>(records, r)</span><br><span class="line">				recordLen := <span class="built_in">len</span>(records)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> recordLen &gt;= *insertBatchNum &#123;</span><br><span class="line">					recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">					insertMulti(recordLen, recordCopy)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(recordsChan)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Copyrecode(records []*Record) (recordCopy []*Record, recordLen <span class="typename">int</span>) &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	recordLen = <span class="built_in">len</span>(records)</span><br><span class="line">	recordCopy = <span class="built_in">make</span>([]*Record, recordLen)</span><br><span class="line">	<span class="built_in">copy</span>(recordCopy, records)</span><br><span class="line">	records = <span class="built_in">make</span>([]*Record, <span class="number">0</span>, *insertBatchNum)</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> insertMulti(n <span class="typename">int</span>, rs []*Record) (<span class="typename">int64</span>, error) &#123;</span><br><span class="line">	<span class="keyword">return</span> GetDB().InsertMulti(n, rs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码就是用ORM将数据插入到指定数据库表中，实现过程考虑到了数据插入超时及强制退出时将records中预留的数据插入数据库一定程度上保证数据不丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很早之前的一个老项目就使用过ORM，当时使用的是&lt;code&gt;xorm&lt;/code&gt;，后来新的项目设计说考虑性能什么的又用写原生sql来做了，在项目中使用一直没什么问题， 但是代码中到处写着原生的sql语句,并且有很多重复的语句，很不好维护，于是最近又重新考虑采用orm的方式来操作数据库，最近看中&lt;code&gt;beego/orm&lt;/code&gt;这个包， 它的官方文档也写了很详细的使用说明，下面还是简要总结一下自己在项目中的使用经历,&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="beego/orm" scheme="http://www.grdtechs.com/tags/beego-orm/"/>
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mysql 数据库表及数据导入导出方法总结</title>
    <link href="http://www.grdtechs.com/2017/02/22/mysql-import-export-summary/"/>
    <id>http://www.grdtechs.com/2017/02/22/mysql-import-export-summary/</id>
    <published>2017-02-22T10:50:36.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>由于公司的MySQL是搭建在服务器上，为了避免对服务器进行直接改动，想远程导出和导入MySQL的数据库表结构及数据进行操作, 刚好Mysql本身提供了命令行导出工具<code>Mysqldump</code>和<code>Mysql Source</code>导入命令进行SQL数据导入导出工作，通过Mysql命令行导出工具Mysqldump命令能够将Mysql数据导出为文本格式(txt)的SQL文件，通过Mysql Source命令能够将SQL文件导入Mysql数据库中，下面通过Mysql导入导出SQL实例详解Mysqldump和Source命令的用法</p>
<a id="more"></a>
<h2 id="u6570_u636E_u5E93_u8868_u53CA_u6570_u636E_u5BFC_u51FA"><a href="#u6570_u636E_u5E93_u8868_u53CA_u6570_u636E_u5BFC_u51FA" class="headerlink" title="数据库表及数据导出"></a>数据库表及数据导出</h2><p>需求说明是要希望导出整个数据库结构脚本，而MySQL提供的Mysqldump命令刚好可达到此目的而且还可以将数据库中的数据也一并导出，</p>
<p><strong> mysqldump导出语法以及实践 </strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h&#123;hostname&#125; [-P&#123;port&#125;] -u&#123;username&#125; -p&#123;password&#125; [--default-character-set=charset] database [tablename] &gt; &#123;you file path&#125;</span><br><span class="line"><span class="comment"># 注:-h和[hostname]之间并没有空格相连, 后同之, []扩起来的为可选项, 可不填</span></span><br></pre></td></tr></table></figure>
<ul>
<li>hostname表示主机名, 本地则填localhost, 远程则填写你的远程IP, 如192.168.0.3;</li>
<li>username是你的MySQL登录帐号, password则是登录密码;</li>
<li>default-character-set则是你的字符集编码, 如gb2312、gbk和utf8(没有横杠哦);</li>
<li>dbname是你的数据库名称, tablename是你的表名, 假如你不填写tablename的话则默认导出所有的表。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.<span class="number">168.0</span>.<span class="number">3</span> -P3307 -uroot -p123456 --default-character-set=utf8  crm_adapter &gt; ./crm_adapter_db.sql</span><br></pre></td></tr></table></figure>
<p>通过上面的导出语句, 将会在当前目录下面创建一个crm_adapter_db.sql脚本文件, 这个脚本文件是可运行的, 它包含了crm_adapter数据库中所有数据表的建表细节以及其所有的数据。这就是导出命令的特点，它不但会导出数据，还会导出表或者数据库的结构信息。另外如果不带”&gt; {you file path}”这一部分路径信息，mysqldump导出命令或把内容打印在terminal命令界面上。</p>
<h2 id="u6570_u636E_u5E93_u8868_u53CA_u6570_u636E_u5BFC_u5165"><a href="#u6570_u636E_u5E93_u8868_u53CA_u6570_u636E_u5BFC_u5165" class="headerlink" title="数据库表及数据导入"></a>数据库表及数据导入</h2><p>数据库表及数据导入可用mysqldump 和source 两种方法来操作， </p>
<p><strong> 通过mysqldump 工具导入</strong><br>mysqldump -h{hostname} [-P{port}] -u{username} -p{password} [–default-character-set=charset] database [tablename] &lt; {you file path}</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.<span class="number">168.0</span>.<span class="number">3</span> -P3308 -uroot -p123456  databasename &lt; ./crm_adapter_db.sql</span><br></pre></td></tr></table></figure>
<p><strong> 通过source 命令导入 </strong></p>
<p><code>source</code>命令导入不同于mysqldump, 它是一个SQL命令, 必须登录进入MySQL在命令行那里才可以运行, 而mysqldump实则是一个管理工具，无须登入MySQ在命令行那里运行，只须在命令行下运行即可。先登入MySQL:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h&#123;hostname&#125; [-p&#123;port&#125;] -u&#123;username&#125; -p&#123;password&#125;</span><br></pre></td></tr></table></figure>
<p>举例, 我们登入一个远程MySQL可以用下面的命令,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.<span class="number">168.0</span>.<span class="number">3</span> -unikey -p123456</span><br></pre></td></tr></table></figure>
<p>登入之后，进入我们要作用的数据库,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; use my_crm_adapter;</span><br></pre></td></tr></table></figure>
<p>然后我们可以使用source命令来运行前面导出的sql脚本实现数据的导入,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; <span class="built_in">source</span> ./crm_adapter_db.sql;</span><br></pre></td></tr></table></figure>
<p><strong> mysqldump vs source </strong><br>mysqldump虽然好用, 但它实际上也是运用先登录在运行脚本的策略, 只是其中的细节我们无需关心, 但是, 因为其中有很多远程连接细节, 我们有可能遭遇中文乱码问题。</p>
<center><img src="/imgs/mysqldump_error.png" alt="mysqldump 乱码"></center>

<p>关于为何在使用mysqldump做导入时会出现中文乱码问题, 我们先用mysql命令登入, 然后输入下面的命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like <span class="string">'character%'</span>;</span><br></pre></td></tr></table></figure></p>
<center><img src="/imgs/mysqldump_ret.png" alt="mysqldump character error"></center>

<p>是否注意到红圈部分的编码是latin1? latin1是MySQL的默认字符集, 可能由于某种原因你没有指定默认编码, 它就会默认为latin1了, 这就是你中文乱码出现的原因。</p>
<p><strong> <font color="red"> 所以建议优先使用source 命令来导入数据 </font> </strong> </p>
<h2 id="mysqldump_u4F7F_u7528_u603B_u7ED3"><a href="#mysqldump_u4F7F_u7528_u603B_u7ED3" class="headerlink" title="mysqldump使用总结"></a>mysqldump使用总结</h2><ul>
<li><p>导出所有库<br>  系统命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword --all-databases &gt; all.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入所有库<br>  mysql命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> all.sql;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出某些库<br>  系统命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword --databases db1 db2 &gt; db1db2.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入某些库<br>  mysql命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> db1db2.sql;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入某个库<br>  系统命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uusername -ppassword db1 &lt; db1.sql;</span><br></pre></td></tr></table></figure>
<p>  或mysql命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> db1.sql;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出某些数据表<br>  系统命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword db1 table1 table2 &gt; tb1tb2.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入某些数据表<br>  系统命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uusername -ppassword db1 &lt; tb1tb2.sql</span><br></pre></td></tr></table></figure>
<p>  或mysql命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;user db1;</span><br><span class="line">mysql&gt;<span class="built_in">source</span> tb1tb2.sql;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mysqldump字符集设置<br>  mysqldump -uusername -ppassword –default-character-set=gb2312 db1 table1 &gt; tb1.sql<br>  mysqldump客户端可用来转储数据库或搜集数据库进行备份或将数据转移到另一个sql服务器(不一定是一个mysql服务器)。转储包含创建表和/或装载表的sql语句。<br>  如果在服务器上进行备份，并且表均为myisam表，应考虑使用mysqlhotcopy，因为可以更快地进行备份和恢复。<br>  有3种方式来调用mysqldump:<br>  系统命令行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	mysqldump [options] db_name [tables]</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">	mysqldump [options] ---database db1 [db2 db3...]</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">	mysqldump [options] --all--database</span><br></pre></td></tr></table></figure>
<p>  如果没有指定任何表或使用了—database或–all–database选项，则转储整个数据库。<br>  要想获得你的版本的mysqldump支持的选项，执行mysqldump —help。<br>  如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内存。如果转储大数据库可能会出现问题。该选项默认启用，但可以用–skip-opt禁用。<br>  如果使用最新版本的mysqldump程序生成一个转储重装到很旧版本的mysql服务器中，不应使用–opt或-e选项。<br>  mysqldump支持下面的选项:<br>   <code>--help</code> 或<code>-?</code><br>   显示帮助消息并退出。<br>   <code>--add-drop--database</code><br>   在每个create database语句前添加drop database语句。<br>   <code>--add-drop-tables</code><br>   在每个create table语句前添加drop table语句。<br>   <code>--add-locking</code><br>   用lock tables和unlock tables语句引用每个表转储。重载转储文件时插入得更快。<br>   <code>--all--database</code> 或 <code>-a</code><br>  转储所有数据库中的所有表。与使用—database选项相同，在命令行中命名所有数据库。<br>   <code>--allow-keywords</code><br>   允许创建关键字列名。应在每个列名前面加上表名前缀。<br>   <code>--comments[={0|1}]</code><br>   如果设置为0, 禁止转储文件中的其它信息, 例如程序版本, 服务器版本和主机。<code>--skip—comments</code>与<code>--comments=0</code>的结果相同。 默认值为1，即包括额外信息。<br>   <code>--compact</code><br>   产生少量输出。该选项禁用注释并启用<code>--skip-add-drop-tables</code>、<code>--no-set-names</code>、<code>--skip-disable-keys</code>和<code>--skip-add-locking</code>选项。<br>   <code>--compatible=name</code><br>   产生与其它数据库系统或旧的mysql服务器更兼容的输出。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options或者no_field_options。要使用几个值，用逗号将它们隔开。这些值与设置服务器sql模式的相应选项有相同的含义。该选项不能保证同其它服务器之间的兼容性。它只启用那些目前能够使转储输出更兼容的sql模式值。例如，–compatible=oracle 不映射oracle类型或使用oracle注释语法的数据类型。<br>   <code>--complete-insert</code> 或 <code>-c</code><br>   使用包括列名的完整的insert语句。<br>   <code>--compress</code> 或<code>-c</code><br>   压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。<br>   <code>--create-option</code><br>   在create table语句中包括所有mysql表选项。<br>  <code>--database</code> 或 <code>-b</code><br>  转储几个数据库。通常情况, mysqldump将命令行中的第1个名字参量看作数据库名，后面的名看作表名。使用该选项，它将所有名字参量看作数据库名。create database if not exists db_name和use db_name语句包含在每个新数据库前的输出中。<br>   <code>--debug[=debug_options]</code> 或<code>-# [debug_options]</code><br>   写调试日志。debug_options字符串通常为’d:t:o,file_name’。<br>   <code>--default-character-set=charset</code><br>   使用charsetas默认字符集。如果没有指定，mysqldump使用utf8。<br>   <code>--delayed-insert</code><br>   使用insert delayed语句插入行。<br>   <code>--delete-master-logs</code><br>   在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用<code>--master-data</code>。<br>   <code>--disable-keys</code> 或 <code>-k</code><br>   对于每个表，用/<em>!40000 alter table tbl_name disable keys </em>/;和/<em>!40000 alter table tbl_name enable keys </em>/;语句引用insert语句。这样可以更快地装载转储文件，因为在插入所有行后创建索引。该选项只适合myisam表。<br>   <code>--extended-insert</code> 或 <code>-e</code><br>   使用包括几个values列表的多行insert语法。这样使转储文件更小，重载文件时可以加速插入。<br>   <code>--fields-terminated-by=...，--fields-enclosed-by=...，--fields-optionally-enclosed-by=...，--fields-escaped-by=...，--行-terminated-by=...</code><br>   这些选项结合-t选项使用，与load data infile的相应子句有相同的含义。<br>   <code>--first-slave</code> 或 <code>-x</code><br>   不赞成使用，现在重新命名为–lock-all-tables。<br>   <code>--flush-logs</code> 或 <code>-f</code><br>   开始转储前刷新mysql服务器日志文件。该选项要求reload权限。请注意如果结合<code>--all--database</code>(或-a)选项使用该选项，根据每个转储的数据库刷新日志。例外情况是当使用<code>--lock-all-tables</code>或<code>--master-data</code>的时候:在这种情况下, 日志只刷新一次, 在所有表被锁定后刷新。如果你想要同时转储和刷新日志，应使用<code>--flush-logs</code>连同<code>--lock-all-tables</code>或<code>--master-data</code>。<br>   <code>--force</code>或<code>-f</code><br>   在表转储过程中, 即使出现sql错误也继续。<br>   <code>--host=host_name</code> 或 <code>-h host_name</code><br>   从给定主机的mysql服务器转储数据。默认主机是localhost。<br>   <code>--hex-blob</code><br>   使用十六进制符号转储二进制字符串列(例如，’abc’ 变为0x616263)。影响到的列有binary、varbinary、blob。<br>   <code>--lock-all-tables</code> 或 <code>-x</code><br>   所有数据库中的所有表加锁。在整体转储过程中通过全局读锁定来实现。该选项自动关闭<code>--single-transaction</code>和<code>--lock-tables</code>。<br>   <code>--lock-tables</code> 或<code>-l</code><br>   开始转储前锁定所有表。用read local锁定表以允许并行插入myisam表。对于事务表例如innodb和bdb，<code>--single-transaction</code>是一个更好的选项，因为它不根本需要锁定表。请注意当转储多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证转储文件中的表在数据库之间的逻辑一致性。不同数据库表的转储状态可以完全不同。<br>   <code>--master-data[=value]</code><br>   该选项将二进制日志的位置和文件名写入到输出中。该选项要求有reload权限，并且必须启用二进制日志。如果该选项值等于1，位置和文件名被写入change master语句形式的转储输出，如果你使用该sql转储主服务器以设置从服务器，从服务器从主服务器二进制日志的正确位置开始。如果选项值等于2，change master语句被写成sql注释。如果value被省略，这是默认动作。<br>   <code>--master-data</code>选项启用<code>--lock-all-tables</code>，除非还指定<code>--single-transaction</code>(在这种情况下，只在刚开始转储时短时间获得全局读锁定。又见<code>--single-transaction</code>。在任何一种情况下，日志相关动作发生在转储时。该选项自动关闭<code>--lock-tables</code>。<br>   <code>--no-create-db</code> 或 <code>-n</code><br>   该选项禁用create database /<em>!32312 if not exists</em>/ db_name语句，如果给出—database或–all–database选项，则包含到输出中。<br>   <code>--no-create-info</code> 或 <code>-t</code><br>   不写重新创建每个转储表的create table语句。<br>   <code>--no-data</code> 或 <code>-d</code><br>   不写表的任何行信息。如果你只想转储表的结构这很有用。<br>   <code>--opt</code><br>   该选项是速记；等同于指定 –add-drop-tables–add-locking –create-option –disable-keys–extended-insert –lock-tables –quick –set-charset。它可以给出很快的转储操作并产生一个可以很快装入mysql服务器的转储文件。该选项默认开启，但可以用–skip-opt禁用。要想只禁用确信用-opt启用的选项，使用–skip形式；例如，–skip-add-drop-tables或–skip-quick。<br>   –password[=password]，-p[password]<br>   连接服务器时使用的密码。如果你使用短选项形式(-p)，不能在选项和密码之间有一个空格。如果在命令行中，忽略了–password或-p选项后面的 密码值，将提示你输入一个。<br>   –port=port_num，-p port_num<br>   用于连接的tcp/ip端口号。<br>   –protocol={tcp | socket | pipe | memory}<br>   使用的连接协议。<br>   –quick，-q<br>   该选项用于转储大的表。它强制mysqldump从服务器一次一行地检索表中的行而不是检索所有行并在输出前将它缓存到内存中。<br>   –quote-names，-q<br>   用”`“字符引用数据库、表和列名。如果服务器sql模式包括ansi_quotes选项，用”字符引用名。默认启用该选项。可以用–skip-quote-names禁用，但该选项应跟在其它选项后面，例如可以启用–quote-names的–compatible。<br>   –result-file=file，-r file<br>  –socket=path，-s path<br>   当连接localhost(为默认主机)时使用的套接字文件。<br>   –skip–comments<br>  参见—comments选项的描述。<br>  –tab=path，-t path<br>  产生tab分割的数据文件。对于每个转储的表，mysqldump创建一个包含创建表的create table语句的tbl_name.sql文件，和一个包含其数据的tbl_name.txt文件。选项值为写入文件的目录。<br>  默认情况，.txt数据文件的格式是在列值和每行后面的新行之间使用tab字符。可以使用–fields-xxx和–行–xxx选项明显指定格式。<br>  注释：该选项只适用于mysqldump与mysqld服务器在同一台机器上运行时。你必须具有file权限，并且服务器必须有在你指定的目录中有写文件的许可。<br>  –tables<br>  覆盖—database或-b选项。选项后面的所有参量被看作表名。<br>  –triggers<br>  为每个转储的表转储触发器。该选项默认启用；用–skip-triggers禁用它。<br>  –tz-utc<br>  在转储文件中加入set time_zone=’+00:00’以便timestamp列可以在具有不同时区的服务器之间转储和重载。(不使用该选项，timestamp列在具有本地时区的源服务器和目的服务器之间转储和重载）。–tz-utc也可以保护由于夏令时带来的更改。–tz-utc默认启用。要想禁用它，使用–skip-tz-utc。该选项在mysql 5.1.2中加入。<br>   –where=’where-condition’, -w ‘where-condition’<br>   只转储给定的where条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。<br>   例如:<br>   <code>&quot;--where=user=&#39;jimf&#39;&quot;
   &quot;-wuserid&gt;1&quot;
   &quot;-wuserid&lt;1&quot;</code><br>   –xml，-x<br>   将转储输出写成xml。<br>   还可以使用–var_name=value选项设置下面的变量:<br>   max_allowed_packet<br>   客户端/服务器之间通信的缓存区的最大大小。最大为1gb。<br>   net_buffer_length<br>   客户端/服务器之间通信的缓存区的初始大小。当创建多行插入语句时(如同使用选项–extended-insert或–opt)，mysqldump创建长度达net_buffer_length的行。如果增加该变量，还应确保在mysql服务器中的net_buffer_length变量至少这么大。<br>   还可以使用–set-variable=var_name=value或-o var_name=value语法设置变量。然而，现在不赞成使用该语法。<br>   mysqldump最常用于备份一个整个的数据库:<br>  mysqldump –opt db_name &gt; backup-file.sql<br>  可以这样将转储文件读回到服务器:<br>  mysql db_name &lt; backup-file.sql<br>   或:<br>  mysql -e “source /path-to–backup/backup-file.sql” db_name<br>   mysqldump也可用于从一个mysql服务器向另一个服务器复制数据时装载数据库:<br>  mysqldump –opt db_name | mysql –host=remote_host -c db_name<br>  可以用一个命令转储几个数据库:<br>  mysqldump —database db_name1 [db_name2 …] &gt; my_databases.sql<br>  如果想要转储所有数据库，使用–all–database选项:<br>  mysqldump –all-databases &gt; all_databases.sql<br>  如果表保存在innodb存储引擎中，mysqldump提供了一种联机备份的途径(参见下面的命令)。该备份只需要在开始转储时对所有表进行全局读锁定(使用flush tables with read lock)。获得锁定后，读取二进制日志的相应内容并将锁释放。因此如果并且只有当发出flush…时正执行一个长的更新语句，mysql服务器才停止直到长语句结束，然后转储则释放锁。因此如果mysql服务器只接收到短(“短执行时间”)的更新语句，即使有大量的语句，也不会注意到锁期间。<br>  mysqldump –all-databases –single-transaction &gt; all_databases.sql<br>  对于点对点恢复(也称为“前滚”，当你需要恢复旧的备份并重放该备份以后的更改时)，循环二进制日志或至少知道转储对应的二进制日志内容很有用：<br>  mysqldump –all-databases –master-data=2 &gt; all_databases.sql<br>  或<br>  mysqldump –all-databases –flush-logs –master-data=2 &gt; all_databases.sql<br>  如果表保存在innodb存储引擎中，同时使用–master-data和–single-transaction提供了一个很方便的方式来进行适合点对点恢复的联机备份。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于公司的MySQL是搭建在服务器上，为了避免对服务器进行直接改动，想远程导出和导入MySQL的数据库表结构及数据进行操作, 刚好Mysql本身提供了命令行导出工具&lt;code&gt;Mysqldump&lt;/code&gt;和&lt;code&gt;Mysql Source&lt;/code&gt;导入命令进行SQL数据导入导出工作，通过Mysql命令行导出工具Mysqldump命令能够将Mysql数据导出为文本格式(txt)的SQL文件，通过Mysql Source命令能够将SQL文件导入Mysql数据库中，下面通过Mysql导入导出SQL实例详解Mysqldump和Source命令的用法&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://www.grdtechs.com/categories/DevOps/"/>
    
    
      <category term="mysql" scheme="http://www.grdtechs.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux Signal及Golang中的信号处理</title>
    <link href="http://www.grdtechs.com/2017/01/22/linux-signal-golang/"/>
    <id>http://www.grdtechs.com/2017/01/22/linux-signal-golang/</id>
    <published>2017-01-22T14:35:45.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。<br>当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。<br>如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。</p>
<a id="more"></a>
<h2 id="u53D1_u9001_u4FE1_u53F7"><a href="#u53D1_u9001_u4FE1_u53F7" class="headerlink" title="发送信号"></a>发送信号</h2><ul>
<li><code>kill</code> 系统调用(system call)可以用来发送一个特定的信号给进程。</li>
<li><code>kill</code> 命令允许用户发送一个特定的信号给进程。</li>
<li><code>raise</code> 库函数可以发送特定的信号给当前进程。</li>
</ul>
<p>在Linux下运行man kill可以查看此命令的介绍和用法。</p>
<blockquote>
<p>The command kill sends the specified signal to the specified process or process group. If no signal is specified, the TERM signal is sent. The TERM signal will kill processes which do not catch this signal. For other processes, it may be necessary to use the KILL (9) signal, since this signal cannot be caught.<br>Most modern shells have a builtin kill function, with a usage rather similar to that of the command described here. The ‘-a’ and ‘-p’ options, and the possibility to specify pids by command name is a local extension.<br>If sig is 0, then no signal is sent, but error checking is still performed.</p>
</blockquote>
<p>一些异常比如除以0或者<code>segmentation violation</code>相应的会产生<code>SIGFPE</code>和<code>SIGSEGV</code>信号，缺省情况下导致<code>core dump</code>和程序退出。<br>内核在某些情况下发送信号，比如在进程往一个已经关闭的管道写数据时会产生<code>SIGPIPE</code>信号.<br>在进程的终端敲入特定的组合键也会导致系统发送某个特定的信号给此进程：</p>
<ul>
<li><code>Ctrl-C</code> 发送 INT signal (SIGINT)，通常导致进程结束</li>
<li><code>Ctrl-Z</code> 发送 TSTP signal (SIGTSTP); 通常导致进程挂起(suspend)</li>
<li><code>Ctrl-\</code> 发送 QUIT signal (SIGQUIT); 通常导致进程结束 和 dump core.</li>
<li><code>Ctrl-T</code> (不是所有的UNIX都支持) 发送INFO signal (SIGINFO); 导致操作系统显示此运行命令的信息</li>
<li><code>kill -9 pid</code> 会发送 SIGKILL信号给进程。</li>
</ul>
<h2 id="u5904_u7406_u4FE1_u53F7"><a href="#u5904_u7406_u4FE1_u53F7" class="headerlink" title="处理信号"></a>处理信号</h2><p>Signal handler可以通过signal()系统调用进行设置。如果没有设置，缺省的handler会被调用，当然进程也可以设置忽略此信号。<br>有两种信号不能被拦截和处理: <code>SIGKILL</code>和<code>SIGSTOP</code>。</p>
<p>当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<p>1.中止进程(Term)<br>2.忽略信号(Ign)<br>3.中止进程并保存内存信息(Core)<br>4.停止进程(Stop)<br>5.继续运行进程(Cont)<br>6.用户可以通过signal或sigaction函数修改信号的响应动作（也就是常说的”注册信号”）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。</p>
<h2 id="u4FE1_u53F7_u7C7B_u578B"><a href="#u4FE1_u53F7_u7C7B_u578B" class="headerlink" title="信号类型"></a>信号类型</h2><p>不同平台的信号定义或许有些不同。下面列出了POSIX中定义的信号。<br>Linux 使用34-64信号用作实时系统中。<br>命令man 7 signal提供了官方的信号介绍。</p>
<p>在POSIX.1-1990标准中定义的信号列表</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>Term</td>
<td>终端控制进程结束(终端连接断开)</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>Term</td>
<td>用户发送INTR字符(Ctrl+C)触发</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>Core</td>
<td>用户发送QUIT字符(Ctrl+/)触发</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>Core</td>
<td>非法指令(程序错误、试图执行数据段、栈溢出等)</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>Core</td>
<td>调用abort函数触发</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>Core</td>
<td>算术运行错误(浮点运算错误、除数为零等)</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Term</td>
<td>无条件结束程序(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>Core</td>
<td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>Term</td>
<td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>Term</td>
<td>时钟定时信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Term</td>
<td>结束程序(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>20,17,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td>Cont</td>
<td>继续执行已经停止的进程(不能被阻塞)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>Stop</td>
<td>停止进程(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>Stop</td>
<td>停止进程(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>Stop</td>
<td>后台程序从终端中读取数据时触发</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>Stop</td>
<td>后台程序向终端中写数据时触发</td>
</tr>
</tbody>
</table>
<p>在SUSv2和POSIX.1-2001标准中的信号列表:</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGTRAP</td>
<td>5</td>
<td>Core</td>
<td>Trap指令触发(如断点，在调试器中使用)</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>0,7,10</td>
<td>Core</td>
<td>非法地址(内存地址对齐错误)</td>
</tr>
<tr>
<td>SIGPOLL</td>
<td></td>
<td>Term</td>
<td>Pollable event (Sys V). Synonym for SIGIO</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>27,27,29</td>
<td>Term</td>
<td>性能时钟信号(包含系统调用时间和进程占用CPU的时间)</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>12,31,12</td>
<td>Core</td>
<td>无效的系统调用(SVr4)</td>
</tr>
<tr>
<td>SIGURG</td>
<td>16,23,21</td>
<td>Ign</td>
<td>有紧急数据到达Socket(4.2BSD)</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>26,26,28</td>
<td>Term</td>
<td>虚拟时钟信号(进程占用CPU的时间)(4.2BSD)</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24,24,30</td>
<td>Core</td>
<td>超过CPU时间资源限制(4.2BSD)</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>25,25,31</td>
<td>Core</td>
<td>超过文件大小资源限制(4.2BSD)</td>
</tr>
</tbody>
</table>
<p>Windows中没有SIGUSR1,可以用SIGBREAK或者SIGINT代替。</p>
<h2 id="Go_u4E2D_u7684Signal_u53D1_u9001_u548C_u5904_u7406"><a href="#Go_u4E2D_u7684Signal_u53D1_u9001_u548C_u5904_u7406" class="headerlink" title="Go中的Signal发送和处理"></a>Go中的Signal发送和处理</h2><p>有时候我们想在Go程序中处理<code>Signal</code>信号，比如收到<code>SIGTERM</code>信号后优雅的关闭程序(参看下一节的应用)。<br>Go信号通知机制可以通过往一个<code>channel</code>中发送<code>os.Signal</code>实现。<br>首先我们创建一个<code>os.Signal channel</code>，然后使用<code>signal.Notify</code>注册要接收的信号。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os/signal"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"syscall"</span></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        sig := &lt;-sigs</span><br><span class="line">        fmt.Println(sig)</span><br><span class="line">        done &lt;- <span class="constant">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"awaiting signal"</span>)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go run main.go执行这个程序，敲入<code>ctrl-C</code>会发送<code>SIGINT</code>信号。 此程序接收到这个信号后会打印退出。</p>
<p>在工作中，遇到这样一个场景:需要往阿里日志服务写数据，但要等到满了200条数据才会触发写入阿里日志服务操作， 辣就会遇到一个问题，当程序被人为中断退出时，但是又没有达到200数据，如果不做其它处理，则这些数据就会丢失了， 为防止存在上述情况的丢失，可以使用Signal来做，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGABRT, syscall.SIGTERM, syscall.SIGPIPE)</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> sig := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		<span class="keyword">switch</span> sig &#123;</span><br><span class="line">		<span class="keyword">case</span> syscall.SIGPIPE:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			this.Terminate()</span><br><span class="line">		&#125;</span><br><span class="line">		glog.Info(<span class="string">"[服务] 收到信号 "</span>, sig)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上述代码的好处时当收到Signal信号之后，就可以选择调用this.Terminate()方法来作出相应的处理</p>
</blockquote>
<h2 id="Go_u7F51_u7EDC_u670D_u52A1_u5668_u5982_u679C_u65E0_u7F1D_u91CD_u542F"><a href="#Go_u7F51_u7EDC_u670D_u52A1_u5668_u5982_u679C_u65E0_u7F1D_u91CD_u542F" class="headerlink" title="Go网络服务器如果无缝重启"></a>Go网络服务器如果无缝重启</h2><p>Go很适合编写服务器端的网络程序。DevOps经常会遇到的一个情况是升级系统或者重新加载配置文件，在这种情况下我们需要重启此网络程序，如果网络程序暂停的时间较长，则给客户的感觉很不好。</p>
<p>如何实现优雅地重启一个Go网络程序呢。主要要解决两个问题:</p>
<ul>
<li>进程重启不需要关闭监听的端口</li>
<li>既有请求应当完全处理或者超时</li>
</ul>
<p>文章<a href="https://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="external">Graceful Restart in Golang</a>中提供了一种方式，而Florian von Bock根据此思路实现了一个框架<a href="https://github.com/fvbock/endless" target="_blank" rel="external">endless</a>。</p>
<p>此框架使用起来超级简单:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := endless.ListenAndServe(<span class="string">"localhost:4242"</span>, mux)</span><br></pre></td></tr></table></figure></p>
<p>只需替换<code>http.ListenAndServe</code>和<code>http.ListenAndServeTLS</code>。</p>
<p>它会监听这些信号： <code>syscall.SIGHUP</code>, <code>syscall.SIGUSR1</code>, <code>syscall.SIGUSR2</code>, <code>syscall.SIGINT</code>, <code>syscall.SIGTERM</code>和<code>syscall.SIGTSTP</code>。</p>
<p>此文章提到的思路是：</p>
<p>通过<code>exec.Command</code> fork一个新的进程，同时继承当前进程的打开的文件(输入输出，socket等)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file := netListener.File() // this returns a Dup()</span><br><span class="line">path := <span class="string">"/path/to/executable"</span></span><br><span class="line">args := []string&#123;</span><br><span class="line">    <span class="string">"-graceful"</span>&#125;</span><br><span class="line">cmd := exec.Command(path, args...)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.ExtraFiles = []*os.File&#123;file&#125;</span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"gracefulRestart: Failed to launch, error: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子进程初始化</p>
<p>网络程序的启动代码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server := &amp;http.Server&#123;Addr: <span class="string">"0.0.0.0:8888"</span>&#125;</span><br><span class="line"> <span class="keyword">var</span> gracefulChild <span class="typename">bool</span></span><br><span class="line"> <span class="keyword">var</span> l net.Listever</span><br><span class="line"> <span class="keyword">var</span> err error</span><br><span class="line"> flag.BoolVar(&amp;gracefulChild, <span class="string">"graceful"</span>, <span class="constant">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</span><br><span class="line"> <span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">     log.Print(<span class="string">"main: Listening to existing file descriptor 3."</span>)</span><br><span class="line">     f := os.NewFile(<span class="number">3</span>, <span class="string">""</span>)</span><br><span class="line">     l, err = net.FileListener(f)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     log.Print(<span class="string">"main: Listening on a new file descriptor."</span>)</span><br><span class="line">     l, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>父进程停止</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">    parent := syscall.Getppid()</span><br><span class="line">    log.Printf(<span class="string">"main: Killing parent pid: %v"</span>, parent)</span><br><span class="line">    syscall.Kill(parent, syscall.SIGTERM)</span><br><span class="line">&#125;</span><br><span class="line">server.Serve(l)</span><br></pre></td></tr></table></figure>
<p>因此，处理特定的信号可以实现程序无缝的重启。</p>
<h2 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h2><p>graceful shutdown实现非常的简单，通过简单的信号处理就可以实现。本文介绍的是graceful restart,要求无缝重启，所以所用的技术相当的hack。</p>
<p>Facebook的工程师也提供了http和net的实现： <a href="https://github.com/facebookgo/grace" target="_blank" rel="external">facebookgo</a>。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://colobu.com/2015/10/09/Linux-Signals/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://colobu.com/2015/10/09/Linux-Signals/?utm_source=tuicool&amp;utm_medium=referral</a></p>
<p><a href="https://en.wikipedia.org/wiki/Unix_signal" target="_blank" rel="external">https://en.wikipedia.org/wiki/Unix_signal</a><br><a href="http://hutaow.com/blog/2013/10/19/linux-signal/" target="_blank" rel="external">http://hutaow.com/blog/2013/10/19/linux-signal/</a><br><a href="http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf" target="_blank" rel="external">http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf</a><br><a href="https://golang.org/pkg/os/signal/" target="_blank" rel="external">https://golang.org/pkg/os/signal/</a><br><a href="https://gobyexample.com/signals" target="_blank" rel="external">https://gobyexample.com/signals</a><br><a href="http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="external">http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/</a><br><a href="https://fitstar.github.io/falcore/hot_restart.html" target="_blank" rel="external">https://fitstar.github.io/falcore/hot_restart.html</a><br><a href="https://github.com/rcrowley/goagain" target="_blank" rel="external">https://github.com/rcrowley/goagain</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。&lt;br&gt;当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。&lt;br&gt;如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="signal" scheme="http://www.grdtechs.com/tags/signal/"/>
    
  </entry>
  
  <entry>
    <title>golang server 跨域解决总结</title>
    <link href="http://www.grdtechs.com/2017/01/20/go-http-cross-origin/"/>
    <id>http://www.grdtechs.com/2017/01/20/go-http-cross-origin/</id>
    <published>2017-01-20T15:30:40.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>server提供api服务直接对接前端js, 但是存在跨域问题，本文使用先查询请求过来的host 然后判断主域名是否存在，存在,则在返回头部设置这个请求域名充许跨域访问。<br><a id="more"></a></p>
<h2 id="u8DE8_u57DF_u6982_u5FF5"><a href="#u8DE8_u57DF_u6982_u5FF5" class="headerlink" title="跨域概念"></a>跨域概念</h2><p>浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。</p>
<p>一般的，只要网站的 协议名protocol 、 主机host 、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。</p>
<p>一般的，发起跨域请求而没有被设置许可跨域时，则会返回类型下面的说明</p>
<center><img src="/imgs/cross-website.png" alt="cross-website"></center>

<p>上面返回提示说明: 跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。</p>
<blockquote>
<p>为了防止CSRF的攻击，我们建议修改浏览器在发送POST请求的时候加上一个Origin字段，这个Origin字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面Origin字段的值就为空。隐私方面：这种Origin字段的方式比Referer更人性化，因为它尊重了用户的隐私。<br>1、Origin字段里只包含是谁发起的请求，并没有其他信息 (通常情况下是方案，主机和活动文档URL的端口)。跟Referer不一样的是，Origin字段并没有包含涉及到用户隐私的URL路径和请求内容，这个尤其重要。<br>2、Origin字段只存在于POST请求，而Referer则存在于所有类型的请求, (随便点击一个超链接（比如从搜索列表里或者企业intranet），并不会发送Origin字段)。</p>
</blockquote>
<h2 id="u83B7_u53D6_u5B8C_u6574url"><a href="#u83B7_u53D6_u5B8C_u6574url" class="headerlink" title="获取完整url"></a>获取完整url</h2><p>查阅了r *http.Request对象中的所有属性，没有发现可以直接获取完整的url的方法。于是尝试根据host和请求地址进行拼接。在golang中可以通过r.Host获取hostname，r.RequestURI获取相应的请求地址。</p>
<p>但是还少一个协议的判断，怎么区分是http和https呢？一开始尝试通过r.Proto属性判断，但是发现该属性不管是http，还是https都是返回HTTP/1.1，又寻找了下发现TLS属性，在https协议下有对应值，在http下为nil。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> index(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    fmt.Println(r.Proto)</span><br><span class="line">    <span class="comment">// output:HTTP/1.1</span></span><br><span class="line">    fmt.Println(r.TLS)</span><br><span class="line">    <span class="comment">// output: &lt;nil&gt;</span></span><br><span class="line">    fmt.Println(r.Host)</span><br><span class="line">    <span class="comment">// output: localhost:9090</span></span><br><span class="line">    fmt.Println(r.RequestURI)</span><br><span class="line">    <span class="comment">// output: /index?id=1</span></span><br><span class="line"> </span><br><span class="line">    scheme := <span class="string">"http://"</span></span><br><span class="line">    <span class="keyword">if</span> r.TLS != <span class="constant">nil</span> &#123;</span><br><span class="line">        scheme = <span class="string">"https://"</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(strings.Join([]<span class="typename">string</span>&#123;scheme, r.Host, r.RequestURI&#125;, <span class="string">""</span>))</span><br><span class="line">    <span class="comment">// output: http://localhost:9090/index?id=1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/index"</span>, index)</span><br><span class="line"> </span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="constant">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u52A8_u6001_u8BB8_u53EF_u8DE8_u57DF"><a href="#u52A8_u6001_u8BB8_u53EF_u8DE8_u57DF" class="headerlink" title="动态许可跨域"></a>动态许可跨域</h2><p>1.直接取头部的<code>Origin</code>字段， 如果取到， 则判断是否包含主域名，然后设置跨域，如果<code>Origin</code>字段为空不存在，则转下面第2步;<br>2.获取子域名(scheme + r.Host)之后, 先判断是否存在，并且是否包含主域名，然后设置跨域, 如果<code>r.Host</code>字段为空， 则转下面第3步;<br>3.获取子域名(scheme + r.URL.Host)之后， 判断是否存在， 并且是否包含主域名， 然后设置跨域，</p>
<p>还有一种方法是利用redis缓存，同样通过上述三个方法获取子域名， 然后查询redis缓存是否存在这个域名，如果有则设置许可跨域; redis缓存的数据来源是 另外准备一个后台，当后台有修改许可跨域网站时，写完db(mysql)的同时先清空缓存，然后在回填缓存即可。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Origin := r.Header.Get(<span class="string">"Origin"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> != <span class="built_in">len</span>(Origin) &amp;&amp; strings.Contains(Origin, <span class="string">"domain.com"</span>)&#123;</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Origin"</span>, Origin)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"POST,GET,OPTIONS,DELETE"</span>)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"x-requested-with,content-type"</span>)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当不添加 <code>Access-Control-Allow-Methods</code>属性时， 默认支持使用GET、HEAD或者POST请求方法跨域请求</p>
</blockquote>
<p>更多参考</p>
<p><a href="http://www.open-open.com/lib/view/open1473667695212.html" target="_blank" rel="external">前端跨域请求原理与实践</a></p>
<p><a href="http://www.cnblogs.com/dojo-lzz/p/4265637.html" target="_blank" rel="external">探讨跨域请求资源的几种方式</a></p>
<p><a href="https://github.com/hstarorg/HstarDoc/blob/master/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CORS%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="external">关于CORS</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;server提供api服务直接对接前端js, 但是存在跨域问题，本文使用先查询请求过来的host 然后判断主域名是否存在，存在,则在返回头部设置这个请求域名充许跨域访问。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>git submodule使用总结</title>
    <link href="http://www.grdtechs.com/2017/01/18/git-submodule/"/>
    <id>http://www.grdtechs.com/2017/01/18/git-submodule/</id>
    <published>2017-01-18T17:11:52.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>现在golang已经可以通过<code>vendor</code>来管理第三方依赖包了，但是之前的一个老项目用的是<code>git submodule</code>来管理的，但是<code>.gitsubmodule</code>文件中只记录管理了项目的部分依赖包， 需要把还没有被管理的第三包也加上，下面总结使用<code>git submodule</code>的过程。<br><a id="more"></a></p>
<h2 id="u6DFB_u52A0_u7B2C_u4E09_u65B9_u5305"><a href="#u6DFB_u52A0_u7B2C_u4E09_u65B9_u5305" class="headerlink" title="添加第三方包"></a>添加第三方包</h2><p>为当前工程添加submodule，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add 仓库地址 保存路经路径</span><br></pre></td></tr></table></figure>
<p>例如要为gomail包添加<code>submodule</code>管理，<br>gomail包 仓库地址: <code>https://github.com/go-gomail/gomail.git</code><br>gomail包要保存在项目里的路经为: <code>src/github.com/go-gomail/gomail</code>, 则命令为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/go-gomail/gomail   src/github.com/go-gomail/gomail</span><br></pre></td></tr></table></figure>
<p>但是老项目遇到的情况是在保存路经<code>src/github.com/go-gomail/gomail</code>中已经存在<code>gomail</code>, 这里只是需要把这个第三包用<code>git submodule</code>记录下来编译管理， 所以需要加一个强制参数， 则命令为如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add <span class="operator">-f</span> https://github.com/go-gomail/gomail   src/github.com/go-gomail/gomail</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。<br>注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）</p>
</blockquote>
<p>命令执行完成，会在当前工程根路径下生成一个名为<code>.gitmodules</code>的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。</p>
<h2 id="u5220_u9664_u7B2C_u4E09_u65B9_u5305"><a href="#u5220_u9664_u7B2C_u4E09_u65B9_u5305" class="headerlink" title="删除第三方包"></a>删除第三方包</h2><p>submodule的删除稍微麻烦点:首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。</p>
<h2 id="u4E0B_u8F7D_u7684_u5DE5_u7A0B_u5E26_u6709submodule"><a href="#u4E0B_u8F7D_u7684_u5DE5_u7A0B_u5E26_u6709submodule" class="headerlink" title="下载的工程带有submodule"></a>下载的工程带有submodule</h2><p>当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p>
<p>即可将子模块内容下载下来后工程才不会缺少相应的文件。</p>
<h2 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h2><p>当第三包被<code>git submodule</code>记录之后，<code>git status</code>命令会出现下面的情况,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status vendor | grep modified:</span><br><span class="line"><span class="comment">#       modified:   vendor/rails (modified content)</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff vendor/</span><br><span class="line">diff --git a/vendor/rails b/vendor/rails</span><br><span class="line">--- a/vendor/rails</span><br><span class="line">+++ b/vendor/rails</span><br><span class="line">@@ -<span class="number">1</span> +<span class="number">1</span> @@</span><br><span class="line">-Subproject commit <span class="number">046</span>c900df27994d454b7f906caa0e4226bb42b6f</span><br><span class="line">+Subproject commit <span class="number">046</span>c900df27994d454b7f906caa0e4226bb42b6f-dirty</span><br></pre></td></tr></table></figure>
<p>如何让<code>git status</code>不显示那个<code>modified content</code>呢？<br>修改<code>.gitmodule</code>文件， 在显示<code>modified content</code>的第三包管理下添加一个<code>ignore = dirty</code>， 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">"bundle/fugitive"</span>]</span><br><span class="line">    path = bundle/fugitive</span><br><span class="line">    url = git://github.com/tpope/vim-fugitive.git</span><br><span class="line">    ignore = dirty</span><br></pre></td></tr></table></figure></p>
<p>上述三个步骤一般就能解决问题了， 如果想深入理解<code>git submodule</code>,可进一步参考<a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html" target="_blank" rel="external">git submodule使用完整教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在golang已经可以通过&lt;code&gt;vendor&lt;/code&gt;来管理第三方依赖包了，但是之前的一个老项目用的是&lt;code&gt;git submodule&lt;/code&gt;来管理的，但是&lt;code&gt;.gitsubmodule&lt;/code&gt;文件中只记录管理了项目的部分依赖包， 需要把还没有被管理的第三包也加上，下面总结使用&lt;code&gt;git submodule&lt;/code&gt;的过程。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://www.grdtechs.com/categories/DevOps/"/>
    
    
      <category term="submodule" scheme="http://www.grdtechs.com/tags/submodule/"/>
    
  </entry>
  
  <entry>
    <title>http 缓存知识总结</title>
    <link href="http://www.grdtechs.com/2017/01/17/http-cache/"/>
    <id>http://www.grdtechs.com/2017/01/17/http-cache/</id>
    <published>2017-01-17T17:54:18.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Http缓存机制作为web性能优化的重要手段, 本文对网络中，工作中使用的http缓存知识进行归纳总结。<br><a id="more"></a></p>
<h2 id="u7F13_u5B58_u5206_u7C7B"><a href="#u7F13_u5B58_u5206_u7C7B" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>缓存分为<code>服务端缓存</code>(server side，比如Nginx、Apache)和<code>客户端缓存</code>(client side，比如 web browser)。</p>
<ul>
<li><code>服务端缓存</code>又分为<code>代理服务器缓存</code>和<code>反向代理服务器缓存</code>(也叫网关缓存，比如Nginx反向代理、Squid等)，其实广泛使用的CDN也是一种服务端缓存，目的都是让用户的请求走”捷径”(一般用CDN缓存图片、文件等静态资源)。</li>
<li><code>客户端缓存</code>一般指的是<code>浏览器缓存</code>，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天pv都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。</li>
</ul>
<p>下文总结的http缓存主要指浏览器缓存和代理服务器缓存</p>
<center><img src="/imgs/cache_where.png" alt="cache"></center>

<p>上图中有三个角色，浏览器, Web代理和服务器，如图所示Http缓存存在于浏览器和Web代理中。<br>当然在服务器内部，也存在着各种缓存，但这已经不是本文要讨论的Http缓存了。<br>所谓的Http缓存控制，就是一种约定，通过设置不同的响应头Cache-Control来控制浏览器和Web代理对缓存的使用策略，通过设置请求头If-None-Match和响应头ETag，来对缓存的有效性进行验证。在开发Web服务时，只需要关注请求头If-None-Match、响应头ETag、响应头Cache-Control就足够了。</p>
<p><strong> 响应头ETag </strong></p>
<p>ETag全称Entity Tag，用来标识一个资源。在具体的实现中，ETag可以是资源的hash值，也可以是一个内部维护的版本号。但不管怎样，ETag应该能反映出资源内容的变化，这是Http缓存可以正常工作的基础。</p>
<center><img src="/imgs/etag.png" alt="ETag"></center>

<p>如上例中所展示的，服务器在返回响应时，通常会在Http头中包含一些关于响应的元数据信息，其中，ETag就是其中一个，本例中返回了值为<code>x1323ddx</code>的<code>ETag</code>。当资源/file的内容发生变化时，服务器应当返回不同的ETag。</p>
<blockquote>
<p>为什么使用ETag呢? 主要是为了解决Last-Modified无法解决的一些问题。</p>
<blockquote>
<p>1.某些服务器不能精确得到文件的最后修改时间, 这样就无法通过最后修改时间来判断文件是否更新了。<br>2.某些文件的修改非常频繁, 在秒以下的时间内进行修改, Last-Modified只能精确到秒。<br>3.一些文件的最后修改时间改变了, 但是内容并未改变, 我们不希望客户端认为这个文件修改了。</p>
</blockquote>
</blockquote>
<p><strong> 请求头If-None-Match </strong></p>
<p>对于同一个资源，比如上一例中的/file，在进行了一次请求之后，浏览器就已经有了/file的一个版本的内容，和这个版本的ETag，当下次用户再需要这个资源，浏览器再次向服务器请求的时候，可以利用请求头If-None-Match来告诉服务器自己已经有个ETag为x1323ddx的/file，这样，如果服务器上的/file没有变化，也就是说服务器上的/file的ETag也是x1323ddx的话，服务器就不会再返回/file的内容，而是返回一个304的响应，告诉浏览器该资源没有变化，缓存有效。</p>
<center><img src="/imgs/if-none-match.png" alt="If-None-Match"></center>

<p>如上例中所示，在使用了If-None-Match之后，服务器只需要很小的响应就可以达到相同的结果，从而优化了性能。</p>
<p><strong> 响应头Cache-Control </strong></p>
<p>每个资源都可以通过Http头Cache-Control来定义自己的缓存策略，Cache-Control控制谁在什么条件下可以缓存响应以及可以缓存多久。最快的请求是不必与服务器进行通信的请求:通过响应的本地副本, 我们可以避免所有的网络延迟以及数据传输的数据成本。为此，HTTP规范允许服务器返回一系列不同的<code>Cache-Control</code>指令，控制浏览器或者其他中继缓存如何缓存某个响应以及缓存多长时间。</p>
<blockquote>
<p>Cache-Control头在HTTP/1.1规范中定义，取代了之前用来定义响应缓存策略的头(例如 Expires)。当前的所有浏览器都支持Cache-Control，因此，使用它就够了。</p>
</blockquote>
<p>其中Cache-Control的参数包括:</p>
<ul>
<li><strong> max-age </strong>  - 该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒。例如：Cache-Control:max-age=60表示响应可以再缓存和重用 60 秒。需要注意的是，在max-age指定的时间之内，浏览器不会向服务器发送任何请求，包括验证缓存是否有效的请求，也就是说，如果在这段时间之内，服务器上的资源发生了变化，那么浏览器将不能得到通知，而使用老版本的资源。所以在设置缓存时间的长度时，需要慎重。)，它在最大生存期后必须在源服务器处被验证或被重新下载。在现代浏览器中这个选项大体上取代了Expires头部，浏览器也将其作为决定内容的新鲜度的基础。最大可以表示一年的新鲜期（31536000秒）。但是这个参数定义的是时间大小(比如: 60)而不是确定的时间点, 单位是[秒seconds] </li>
<li><strong> s-maxage </strong>  - 类似于max-age, 但是它只用于公享缓存(e.g., proxy), 这个选项非常类似于max-age，它指明了内容能够被缓存的时间。区别是这个选项只在中间节点的缓存中有效。结合这两个选项可以构建更加灵活的缓存策略。</li>
<li><strong> public </strong> - 设置了public，表示该响应可以再浏览器或者任何中继的Web代理中缓存，public是默认值，即Cache-Control:max-age=60等同于Cache-Control:public, max-age=60。</li>
<li><strong> private </strong> - 在服务器设置了private比如Cache-Control:private, max-age=60的情况下，表示只有用户的浏览器可以缓存private响应，不允许任何中继Web代理对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的HTML网页，但是CDN不能缓存。</li>
<li><strong> no-cache </strong> - 如果服务器在响应中设置了no-cache即Cache-Control:no-cache，那么浏览器在使用缓存的资源之前，必须先与服务器确认返回的响应是否被更改，如果资源未被更改，可以避免下载。这个验证之前的响应是否被修改，就是通过上面介绍的请求头If-None-match和响应头ETag来实现的。<font color="red">(注意: no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。如果设置了no-cache，而ETag的实现没有反应出资源的变化，那就会导致浏览器的缓存数据一直得不到更新的情况。)</font> </li>
<li><strong> no-store </strong> - 如果服务器在响应中设置了no-store即Cache-Control:no-store，那么浏览器和任何中继的Web代理，都不会存储这次相应的数据。当下次请求该资源时，浏览器只能重新请求服务器，重新从服务器读取资源。</li>
<li><strong> must-revalidate </strong> - 响应在特定条件下会被重用, 以满足接下来的请求, 但是它必须到服务器端去验证它是不是仍然是最新的,它指明了由max-age、s-maxage或Expires头部指明的新鲜度信息必须被严格的遵守。它避免了缓存的数据在网络中断等类似的场景中被使用。</li>
<li><strong> proxy-revalidate </strong> - 类似于must-revalidate, 但不适用于代理缓存, 它和上面的选项有着一样的作用，但只应用于中间的代理节点。在这种情况下，用户的浏览器可以在网络中断时使用过期内容，但中间缓存内容不能用于此目的。</li>
<li><strong> no-transform </strong> - 这个选项告诉缓存在任何情况下都不能因为性能的原因修改接收到的内容。这意味着，缓存不允许压缩接收到的内容（没有从原始服务器处接收过压缩版本的该内容）并发送。</li>
</ul>
<blockquote>
<p>如果no-store和no-cache都被设置，那么no-store会取代no-cache。</p>
<p>cache-control默认为private, 其作用根据不同的重新浏览方式分为以下几种情况:</p>
<blockquote>
<p>1.打开新窗口 值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器，例如: Cache-control:max-age=5(表示当访问此网页后的5秒内再次访问不会去服务器)<br>2.在地址栏回车 值为private或must-revalidate则只有第一次访问时会访问服务器，以后就不再访问。 值为no-cache，那么每次都会访问。 值为max-age，则在过期之前不会重复访问。<br>3.按后退按扭 值为private、must-revalidate、max-age，则不会重访问，值为no-cache，则每次都重复访问<br>4.按刷新按扭 无论为何值，都会重复访问 Cache-control值为”no-cache”时，访问此页面不会在Internet临时文件夹留下页面备份。</p>
</blockquote>
</blockquote>
<p>Cache-Control 有这么多字段可用来控制缓存策略， 那到底是怎么用的? ， 下面通过一张图来表述一个资源的Cache-Control策略,</p>
<center><img src="/imgs/cache_control_workflow.png" alt="cache-control-work-flow"></center>

<h2 id="u7F13_u5B58_u65B0_u9C9C_u5EA6"><a href="#u7F13_u5B58_u65B0_u9C9C_u5EA6" class="headerlink" title="缓存新鲜度"></a>缓存新鲜度</h2><p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。</p>
<p><strong> 第一种, 浏览器把缓存文件的<code>最后修改时间</code>通过header字段”If-Modified-Since”来告诉Web服务器。</strong><br><strong> 第二种, 浏览器把缓存文件的<code>ETag</code>, 通过header字段”If-None-Match”, 来告诉Web服务器。</strong></p>
<p><strong> 第一种: </strong> 通过最后修改时间, 来判断缓存新鲜度 </p>
<p>1.浏览器客户端想请求一个文档, 首先检查本地缓存, 发现存在这个文档的缓存, 获取缓存中文档的最后修改时间, 通过:If-Modified-Since， 发送Request给Web服务器。<br>2.Web服务器收到Request, 将服务器的文档修改时间(Last-Modified):跟request header中的, If-Modified-Since相比较, 如果时间是一样的, 说明缓存还是最新的, Web服务器将发送<code>304 Not Modified</code>给浏览器客户端, 告诉客户端直接使用缓存里的版本。如下图。</p>
<center><img src="/imgs/cache_304.png" alt="cache 304"></center>

<p>3.假如该文档已经被更新了。Web服务器将发送该文档的最新版本给浏览器客户端， 如下图。</p>
<center><img src="/imgs/cache_200.png" alt="cache 200"></center>

<p><strong> 第二种: </strong> 服务器通过比对客户端请求发来的”If-None-Match”带上的Etag值, 如果一致则表示可以使用本地缓存，如果不一致表示服务器内容有更新，此时会重新发一份新的给客户端。</p>
<p>至此，浏览器端http cache 的大致流程可总结如图，</p>
<center><img src="/imgs/cache_workflow.png" alt="cache workflow"></center>

<p><strong> <font color="red">Etag/If-None-Match:</font>Etag/If-None-Match要配合Cache-Control使用。</strong></p>
<blockquote>
<p>Etag: web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定)。Apache中，ETag的值，默认是对文件的索引节(INode)，大小(Size)和最后修改时间(MTime)进行Hash后得到的。<br>If-None-Match: 当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match(Etag的值)。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。</p>
</blockquote>
<p><strong> <font color="red">Last-Modified/If-Modified-Since:</font>Last-Modified/If-Modified-Since也要配合Cache-Control使用。 </strong></p>
<blockquote>
<p>Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br>If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Last-Modified声明，则再次向web服务器请求时带上头If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p>
</blockquote>
<p><font color="red">既生Last-Modified何生Etag? </font><br>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag(实体标识)呢? HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题,</p>
<blockquote>
<p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间, 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存,有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>
<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符, 能够更加准确的控制缓存。Last-Modified与ETag一起使用时, 服务器会优先验证ETag。</p>
</blockquote>
<p><strong> 注: <font color="red">yahoo的Yslow法则中则提示谨慎设置Etag,</font> </strong> 需要注意的是分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败，Yahoo建议分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样，因为除了last-modified、inode也很难保持一致)。</p>
<p>此外浏览器缓存行为还与用户的操作行为有关, 归纳总结如下,</p>
<table>
<thead>
<tr>
<th style="text-align:left">用户操作</th>
<th>Expires/Cache-Control</th>
<th>Last-Modified/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">地址栏回车</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td style="text-align:left">页面链接跳转</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td style="text-align:left">新开窗口</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td style="text-align:left">前进、后退</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td style="text-align:left"><font color="red">F5/按钮刷新 </font></td>
<td><font color="red"> 无效(BR重置max-age=0)</font></td>
<td><font color="red"> 有效     </font></td>
</tr>
<tr>
<td style="text-align:left"><font color="red">Ctrl+F5刷新 </font></td>
<td><font color="red"> 无效(重置CC=no-cache)</font></td>
<td><font color="red"> 无效(请求头丢弃该选项)</font></td>
</tr>
</tbody>
</table>
<h2 id="u6848_u4F8B_u5206_u6790"><a href="#u6848_u4F8B_u5206_u6790" class="headerlink" title="案例分析"></a>案例分析</h2><p>案例, page.html内容如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;meta http-equiv="cache-control" content="no-cache"&gt;--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"cache-control"</span> <span class="attribute">content</span>=<span class="value">"private"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>page页<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"images/head.png"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"page.html"</span>&gt;</span>重新访问page页<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>首次访问该页面，页面中head.png响应头信息如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p>
<p><strong> <font color="red"> 问题1: 请问当点击”重新访问page页”链接重新加载该页面后, head.png 如何二次加载? </font> </strong> </p>
<p><strong> <font color="red"> 问题2: 如果将上述信息中的 Cache-Control 设置为 private，那么结果又会如何呢? </font> </strong></p>
<p>下面从系统体系化角度来讲讲<code>Http缓存头</code>是如何协同工作的</p>
<p><strong> HTTP缓存体系 </strong></p>
<p>首先我将 Http 缓存体系分为以下三个部分:</p>
<center><img src="/imgs/cache_sys.png" alt="cache"></center>

<p><strong> 1.缓存存储策略 </strong></p>
<p>这个策略的作用只有一个, 用于确定Http响应内容是否可以被客户端缓存, 以及可以被哪些客户端缓存</p>
<p>对于Cache-Control头里的Public, Private, no-cache, max-age, no-store他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据(关于no-cache应理解为”不建议使用本地缓存”, 其仍然会缓存数据到本地), 后者no-store则不会在客户端缓存任何响应数据。</p>
<p>通过Cache-Control:Public设置我们可以将Http响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用, 为啥? 因为它无法确定本地缓存的数据是否可用(可能已经失效), 还必须借助一套鉴别机制来确认才行, 这就是我们下面要讲到的”缓存过期策略”。</p>
<p><strong> 2.缓存过期策略 </strong></p>
<p>客户端用来确认存储在本地的缓存数据是否已过期, 进而决定是否要发请求到服务端获取数据<br>这个策略的作用也只有一个, 那就是决定客户端是否可直接从本地缓存数据中加载数据并展示(否则就发请求到服务端获取)<br>刚上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用, 那么浏览器通过什么条件来判断呢? 答案是:Expires，Expires指明了缓存数据有效的绝对时间, 告诉客户端到了这个时间点(比照客户端时间点)后本地缓存就作废了, 在这个时间点内客户端可以认为缓存数据有效, 可直接从缓存中加载展示。</p>
<p>不过Http缓存头设计并没有想象的那么规矩, 像上面提到的Cache-Control(这个头是在Http1.1里加进来的)头里的no-cache和max-age就是特例, 它们既包含缓存存储策略也包含缓存过期策略, 以max-age为例, 它实际上相当于: Cache-Control:public/private(这里不太确定具体哪个)</p>
<p>Expires: 当前客户端时间 + maxAge。<br>而Cache-Control: no-cache 和 Cache-Control: max-age=0(单位是秒)相当</p>
<p>这里需要注意的是:</p>
<p><font color="red">Cache-Control中指定的缓存过期策略优先级高于Expires, 当它们同时存在的时候, Expires将被忽略不起作用。</font><br>缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了, 需要再发一次请求到服务器去确认, 并不等同于本地缓存数据从此就没用了, 有些情况下即使过期了还是会被再次用到，具体下面会讲到。</p>
<blockquote>
<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p>
</blockquote>
<p><strong> 3.缓存对比策略 </strong></p>
<p>将缓存在客户端的数据标识发往服务端, 服务端通过标识来判断客户端缓存数据是否仍有效, 进而决定是否要重发数据。<br>客户端检测到数据过期或浏览器刷新后, 往往会重新发起一个http请求到服务器, 服务器此时并不急于返回数据, 而是看请求头有没有带标识(If-Modified-Since, If-None-Match)过来, 如果判断标识仍然有效, 则返回304告诉客户端取本地缓存数据来用即可(这里要注意的是你必须要在首次响应时输出相应的头信息(Last-Modified, ETags)到客户端)。至此我们就明白了上面所说的本地缓存数据即使被认为过期，并不等于数据从此就没用了的道理了。</p>
<p>关于Last-Modified，这个响应头使用要注意，可能会影响到缓存过期策略，具体原因，后面我会通过解答开篇提到的2道题来作说明。</p>
<p>以上就是我所认识的缓存策略，下面我将缓存策略三要素和常用的几个缓存头(项)结合一起，让大家更清晰的认识到它们之间的关系:</p>
<center><img src="/imgs/cache_sys_relation.png" alt="cache sys relation"></center>

<p>通过上图可以清晰的看到各缓存项分别属于哪个缓存策略范畴，这其中有部分重叠，它表明这些缓存项具有多重缓存策略，所以实际在分析缓存头的时候，除了常规的头外，我们还需要将这些具有双重缓存策略的项分解开来。<br>现在回到最开始提到的2道题目,</p>
<p><strong> 第一道题: </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, <span class="number">08</span> Nov <span class="number">2016</span> <span class="number">06</span>:<span class="number">59</span>:<span class="number">00</span> GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, <span class="number">10</span> Nov <span class="number">2016</span> <span class="number">02</span>:<span class="number">48</span>:<span class="number">50</span> GMT</span><br><span class="line">Content-Length: <span class="number">3534</span></span><br></pre></td></tr></table></figure></p>
<p>分析上述Http响应头发现有以下两项与缓存相关:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache </span><br><span class="line">Last-Modified: Tue, <span class="number">08</span> Nov <span class="number">2016</span> <span class="number">06</span>:<span class="number">59</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure></p>
<p>我们上面讲到了Cache-Control:no-cache 相当于Cache-Control:max-age=0，且他们都是多重策略头, 我们需将其分解:</p>
<p>Cache-Control:no-cache 等于 Cache-Control:max-age=0， </p>
<p>接着Cache-Control:max-age=0 又可分解成:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public/private （不确定是二者中的哪一个）</span><br><span class="line">Expires: 当前时间</span><br></pre></td></tr></table></figure></p>
<p><strong> 最终我们得到了以下完整的缓存策略三要素: </strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">缓存策略类型</th>
<th style="text-align:left">缓存策略值</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">缓存存储策略</td>
<td style="text-align:left">cache-control:public/private</td>
<td style="text-align:left">响应数据会被缓存到客户端</td>
<td style="text-align:left">由cache-control:no-cache拆解而来</td>
</tr>
<tr>
<td style="text-align:center">缓存过期策略</td>
<td style="text-align:left">Expires:当前时间</td>
<td style="text-align:left">立马过期, 二次资源访问浏览器会重新发起http请求</td>
<td style="text-align:left">由cache-control:no-cache拆解而来</td>
</tr>
<tr>
<td style="text-align:center">缓存对比策略</td>
<td style="text-align:left">Last-Modifed: Tue, 08 Nov 2016 06:59:00 GMT</td>
<td style="text-align:left">浏览器会携带该值去服务端比对，比对成功则返回304, 服务端提示浏览器从本地加载数据，否在返回200并响应数据。</td>
</tr>
</tbody>
</table>
<p>所以最终结果是:浏览器会再次请求服务端, 并携带上Last-Modified指定的时间去服务器对比:</p>
<p>a)对比失败: 服务器返回200并重发数据, 客户端接收到数据后展示, 并刷新本地缓存。<br>b)对比成功: 服务器返回304且不重发数据, 客户端收到304状态码后从本地读取缓存数据。</p>
<center><img src="/imgs/cache_data1.jpg" alt="cache_data"></center>

<p>这道题本身不难, 但若认为no-cache不会缓存数据到本地, 那么你理解起来就会很矛盾, 因为如果文件数据没有被本地缓存, 服务器返回304后将会无法展示出图片内容, 但实际上它是能正常展示的。这道题很好的证明了no-cache也会缓存数据到本地这一说法。</p>
<p><strong> 第二道题: </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, <span class="number">08</span> Nov <span class="number">2016</span> <span class="number">06</span>:<span class="number">59</span>:<span class="number">00</span> GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, <span class="number">10</span> Nov <span class="number">2016</span> <span class="number">02</span>:<span class="number">48</span>:<span class="number">50</span> GMT</span><br><span class="line">Content-Length: <span class="number">3534</span></span><br></pre></td></tr></table></figure></p>
<p>解题思路和上题一样，首先先找到缓存相关项:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private     </span><br><span class="line">Last-Modified: Tue, <span class="number">08</span> Nov <span class="number">2016</span> <span class="number">06</span>:<span class="number">59</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure></p>
<p><code>private</code>: 指对于单个用户的整个或部分响应消息进行缓存，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效,这里可以看到没有提供任何缓存过期策略</p>
<p>在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略, <strong> 根据响应头中2个时间字段Date和Last-Modified之间的时间差值，取其值的10%作为缓存时间周期。</strong> 下面是官方解释,</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 Cache-Control Header is present: private</span><br><span class="line">HTTP Last-Modified Header is present: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">No explicit HTTP Cache Lifetime information was provided.</span><br><span class="line">Heuristic expiration policies suggest defaulting to: 10% of the delta between Last-Modified and Date.</span><br><span class="line">That's '05:15:02' so this response will heuristically expire 2016/11/11 0:46:01.</span><br></pre></td></tr></table></figure>
<p>最终我们得到了以下完整的缓存策略三要素:</p>
<table>
<thead>
<tr>
<th style="text-align:center">缓存策略类型</th>
<th style="text-align:left">缓存策略值</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">缓存存储策略</td>
<td style="text-align:left">cache-control:private</td>
<td style="text-align:left">响应数据会被缓存到客户端</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">缓存过期策略</td>
<td style="text-align:left">Expires: 当前时间 + (date - Last-Modified) * 10%</td>
<td style="text-align:left">根据计算公式得到一个缓存过期时间</td>
<td style="text-align:left">在没有提供任何浏览器缓存过期策略的情况下，客户端计算响应头中2个时间字段Date和Last-Modified之间的时间差值(单位:秒), 取该值的10%作为缓存过期周期</td>
</tr>
<tr>
<td style="text-align:center">缓存对比策略</td>
<td style="text-align:left">Last-Modifed: Tue, 08 Nov 2016 06:59:00 GMT</td>
<td style="text-align:left">浏览器会携带该值去服务端比对，比对成功则返回304, 服务端提示浏览器从本地加载数据，否在返回200并响应数据。</td>
</tr>
</tbody>
</table>
<p>即: 浏览器会根据<code>Date</code>和<code>Last-Modified</code>之间的时间差值缓存一段时间，这段时间内会直接使用本地缓存数据而不会再去请求服务器(强制请求除外)，缓存过期后，会再次请求服务端，并携带上<code>Last-Modified</code>指定的时间去服务器对比并根据服务端的响应状态决定是否要从本地加载缓存数据。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] 浏览器缓存机制</p>
<p><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>[2] Web 开发人员需知的 Web 缓存知识</p>
<p><a href="http://www.oschina.net/news/41397/web-cache-knowledge" target="_blank" rel="external">http://www.oschina.net/news/41397/web-cache-knowledge</a></p>
<p>[3] 浏览器缓存详解:expires,cache-control,last-modified,etag详细说明</p>
<p><a href="http://blog.csdn.net/eroswang/article/details/8302191" target="_blank" rel="external">http://blog.csdn.net/eroswang/article/details/8302191</a></p>
<p>[4] 在浏览器地址栏按回车、F5、Ctrl+F5刷新网页的区别</p>
<p><a href="http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=15790" target="_blank" rel="external">http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=15790</a></p>
<p><a href="http://blog.csdn.net/yui/article/details/6584401" target="_blank" rel="external">http://blog.csdn.net/yui/article/details/6584401</a></p>
<p>[5] Cache Control 與 ETag</p>
<p><a href="https://blog.othree.net/log/2012/12/22/cache-control-and-etag/" target="_blank" rel="external">https://blog.othree.net/log/2012/12/22/cache-control-and-etag/</a></p>
<p>[6] 缓存的故事</p>
<p><a href="http://segmentfault.com/blog/animabear/1190000000375344" target="_blank" rel="external">http://segmentfault.com/blog/animabear/1190000000375344</a></p>
<p>[7] Google的PageSpeed网站优化理论中提到使用Etag可以减少服务器负担</p>
<p><a href="https://developers.google.com/speed/docs/pss/AddEtags" target="_blank" rel="external">https://developers.google.com/speed/docs/pss/AddEtags</a></p>
<p>[8] yahoo的Yslow法则中则提示谨慎设置Etag</p>
<p><a href="http://developer.yahoo.com/performance/rules.html#etags" target="_blank" rel="external">http://developer.yahoo.com/performance/rules.html#etags</a></p>
<p>[9] H5 缓存机制浅析 移动端 Web 加载性能优化</p>
<p><a href="http://segmentfault.com/a/1190000004132566" target="_blank" rel="external">http://segmentfault.com/a/1190000004132566</a></p>
<p>[10] 网页性能： 缓存效率实践</p>
<p><a href="http://www.w3ctech.com/topic/1648" target="_blank" rel="external">http://www.w3ctech.com/topic/1648</a></p>
<p>[11] 透过浏览器看HTTP缓存</p>
<p><a href="http://www.cnblogs.com/skylar/p/browser-http-caching.html" target="_blank" rel="external">http://www.cnblogs.com/skylar/p/browser-http-caching.html</a></p>
<p>[12] 浏览器缓存知识小结及应用</p>
<p><a href="http://web.jobbole.com/84888/" target="_blank" rel="external">http://web.jobbole.com/84888/</a></p>
<p>[13] 大公司里怎样开发和部署前端代码？</p>
<p><a href="http://zhihu.com/question/20790576/answer/32602154?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu" target="_blank" rel="external">http://zhihu.com/question/20790576/answer/32602154?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu</a></p>
<p>[14] 浏览器缓存机制详解</p>
<p><a href="https://mangguo.org/browser-cache-mechanism-detailed/" target="_blank" rel="external">https://mangguo.org/browser-cache-mechanism-detailed/</a></p>
<p>[15] 关于缓存和 Chrome 的“新版刷新”</p>
<p><a href="http://www.cnblogs.com/ziyunfei/p/6308652.html" target="_blank" rel="external">http://www.cnblogs.com/ziyunfei/p/6308652.html</a></p>
<p>[16] HTTP缓存控制小结</p>
<p><a href="http://www.kuqin.com/shuoit/20160801/352684.html?url_type=39&amp;object_type=webpage&amp;pos=1" target="_blank" rel="external">http://www.kuqin.com/shuoit/20160801/352684.html?url_type=39&amp;object_type=webpage&amp;pos=1</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Http缓存机制作为web性能优化的重要手段, 本文对网络中，工作中使用的http缓存知识进行归纳总结。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://www.grdtechs.com/categories/DevOps/"/>
    
    
      <category term="cache" scheme="http://www.grdtechs.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法总结</title>
    <link href="http://www.grdtechs.com/2017/01/16/consistent-hashing-summary/"/>
    <id>http://www.grdtechs.com/2017/01/16/consistent-hashing-summary/</id>
    <published>2017-01-16T11:02:50.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>存在一种场景, 当一个缓存服务由多个服务器组共同提供时, key应该路由到哪一个服务。这里假如采用最通用的方式取模求余: <code>key%N</code>(N为服务器数目), 这样做均衡性没有什么问题, 但是当服务器数目发送增加或减少时, 分配方式则变为<code>key%(N+1)</code>或<code>key%(N-1)</code>。这里将会有大量的key失效迁移, 如果后端key对应的是有状态的存储数据,那么毫无疑问,这种做法将导致服务器间大量的数据迁移,从而造成服务的不稳定。解决思路，采用一致性哈希方法可以解决此问题。 </p>
<a id="more"></a>
<h2 id="u7B97_u6CD5_u539F_u7406"><a href="#u7B97_u6CD5_u539F_u7406" class="headerlink" title="算法原理"></a>算法原理</h2><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希(DHT)实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希(DHT)可以在P2P环境中真正得到应用。 </p>
<p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义:</p>
<p>1.<code>平衡性(Balance)</code>: 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
<p>2.<code>单调性(Monotonicity)</code>: 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </p>
<p>3.<code>分散性(Spread)</code>: 在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </p>
<p>4.<code>负载(Load)</code>: 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。在移除/添加一个cache时，利用一致性哈希算法能够尽可能小的改变已存在key映射关系，尽可能的满足单调性的要求。</p>
<p>下面就来按照5个步骤简单讲讲 consistent hashing 算法的基本原理:</p>
<p><strong> 1 环形hash空间 </strong></p>
<p>考虑通常的hash算法都是将value映射到一个32位的key值, 也即是0~2^32-1次方的数值空间上; 可以将这个空间想象成一个首(0)尾(2^32-1)相接的圆环, 如图1所示,</p>
<center><img src="/imgs/hashring.jpg" alt="hash ring">图1 环形hash空间</center>

<p><strong> 2 把对象映射到hash空间 </strong></p>
<p>接下来考虑4个对象object1~object4，通过hash函数计算出的hash值key在环上的分布如图2所示,</p>
<p>hash(object1) = key1;<br>… …<br>hash(object4) = key4;</p>
<center><img src="/imgs/object.jpg" alt="hash ring">图2 4个对象的key值分布</center>

<p><strong> 3 把cache server映射到hash空间 </strong></p>
<p>一致性哈希算法的基本思想就是将对象和cache server都映射到同一个hash数值空间中，并且使用相同的hash算法。</p>
<p>假设当前有A, B和C共3台cache server，那么其映射结果将如图3所示，他们在hash空间中，以对应的hash值排列(一般采用升序，好便于后继将对象映射到相应的cache server上)。</p>
<p>hash(cache A) = key A;<br>… …<br>hash(cache C) = key C;</p>
<center><img src="/imgs/cache.jpg" alt="hash ring">图3 cache server 和对象的key值分布</center>

<font color="red">通常cache server的hash计算, 是用cache机器的IP地址或机器名作为hash输入, 后继的实现案例中利用了cache server的IP地址作为参数因子。</font>

<p><strong> 4 把对象映射到cache server上 </strong></p>
<p>现在cache server和对象都已经通过同一个hash算法映射到hash数值空间中了，接下来要考虑的就是如何将对象映射到cache server上面了。<br>在这个环形空间中，如果沿着顺时针方向从对象的key值出发，直到遇见一个cache server，那么就将该对象存储在这个cache server上，因为对象和cache server的hash值是固定的，因此这个cache server必然是唯一和确定的。这样不就找到了对象和cache server的映射方法了吗?! (程序实现时可以对hash环进行升序排序， 然后按顺时针从对象的key值出发，找到与这个key相邻的第一个大于key值的cache server hash值，则将这个key值映射到这个cache server上)</p>
<p>依然继续上面的例子(参见图3)，那么根据上面的方法，对象object1将被存储到cache server A上; object2和 object3 对应到 cache  server C; object4 对应到 cache server B; </p>
<p><strong> 5 考察cache server的变动 </strong><br>前面讲过，通过hash求余的方法带来的最大问题就在于不能满足单调性，当cache server有所变动时，存储在原位置上的cache数据失效了，就需要做相应的迁移, 进而对后台服务器造成巨大的冲击，现在就来分析一致性哈希算法,</p>
<p>5.1 移除cache server </p>
<p>假设cache server B 挂掉了, 根据上面讲到的映射方法，这时受影响的将仅是那些沿cache server B 逆时针遍历直到下一个cache server (cache server A)之间的对象，也即是本来映射到cache  server B上的那些对象。</p>
<p>因此这里仅需要变动对象object4，将其重新映射到cache server C上即可; 参见图4。</p>
<center><img src="/imgs/remove.jpg" alt="hash ring">图4 Cache server B被移除后的cache server映射</center>

<p>5.2 添加cache server</p>
<p>再考虑添加一台新的cache server D的情况，假设在这个环形hash空间中，cache server D被映射在对象object2和object3之间。这时受影响的将仅是那些沿cache server D逆时针遍历直到下一个cache server (cache server B)之间的对象(它们是也本来映射到cache server C上对象的一部分)，将这些对象重新映射到cache server D上即可。因此这里仅需要变动对象object2, 将其重新映射到cache server D上; 参见图5。</p>
<center><img src="/imgs/add.jpg" alt="hash ring">图5 添加cache server D后的映射关系</center>

<p><strong> 6 虚拟节点 </strong></p>
<p>考量Hash算法的另一个指标是<code>平衡性(Balance)</code>，定义如下:<br><strong> 平衡性 </strong> 是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用, hash算法并不是保证绝对的平衡，如果cache server较少的话，对象并不能被均匀的映射到cache server上，比如在上面的例子中，仅部署cache server A 和 cache server C的情况下，在4个对象中，cache server A仅存储了object1，而cache server C则存储了object2, object3和object4; 分布是很不均衡的。</p>
<p>为了解决这种情况, 一致性哈希引入了”虚拟节点”的概念, 它可以如下定义:</p>
<font color="red">“虚拟节点”(virtual node)是实际节点在hash空间的复制品(replica)，一实际个节点对应了若干个”虚拟节点”，这个对应个数也成为”复制个数”，”虚拟节点”在hash空间中以hash值排列。</font>

<p>仍以仅部署cache server A 和cache server C 的情况为例, 在图4中我们已经看到, cache server分布并不均匀。现在我们引入虚拟节点，并设置”复制个数”为2，这就意味着一共会存在4个”虚拟节点”, cache server A1, cache server A2代表了cache server A; cache server C1, cache server C2代表了cache server C; 假设一种比较理想的情况，参见图6,</p>
<center><img src="/imgs/virtual.jpg" alt="hash ring">图6 引入”虚拟节点”后的映射关系</center>

<p>此时, 对象到”虚拟节点”的映射关系为:</p>
<p>objec1-&gt;cache A2; objec2-&gt;cache A1; objec3-&gt;cache C1; objec4-&gt;cache C2; </p>
<p>因此对象object1和object2都被映射到了cache server A上，而object3和object4映射到了cache server C上; 平衡性有了很大提高。</p>
<p>引入”虚拟节点”后, 映射关系就从<code>{对象-&gt;节点}</code>转换到了<code>{对象-&gt;虚拟节点}</code>。查询物体所在cache server时的映射关系如图7所示,</p>
<center><img src="/imgs/map.jpg" alt="object to virtual node">图7 查询对象所在cache server</center>

<p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设cache server A 的IP地址为202.168.14.241。</p>
<p>引入”虚拟节点”前，计算cache server A的hash值:</p>
<p>Hash(“202.168.14.241”);</p>
<p>引入”虚拟节点”后，计算”虚拟节点”cache server A1和cache server A2的hash值:</p>
<p>Hash(“202.168.14.241-1-1”);  // cache server A1 [Hash(server_IP-virtual_node_id-physical-node-id)]</p>
<p>Hash(“202.168.14.241-2-1”);  // cache server A2 [Hash(server_IP-virtual_node_id-physical-node-id)]</p>
<h2 id="u7B97_u6CD5_u5B9E_u73B0"><a href="#u7B97_u6CD5_u5B9E_u73B0" class="headerlink" title="算法实现"></a>算法实现</h2><p>上面详细讲述了一致性哈希算法的原理，下面通过golang语言来实现一致性哈希算法，具体实现思想:<br>1.通过一致性哈希函数将这些cache server映射到一个哈希环上，并将这个哈希环按升序排序;<br>2.将待写入到cache server中的key-value值对象，可以用这个对象的key作为因子用上述同一个一致性哈希函数计算出一个hash值，然后按顺时针在哈希环上找到第一个大于这个hash值的cache server hash值;<br>3.通过找到的这个cache server hash值可以找到对应的cache server;<br>4.然后将上述的key-value对象存入到这个cache server中。 </p>
<p>具体实现过程大致可以分为一下几个步骤:</p>
<p>1.定义cache server节点实体, 用于计算cache server节点hash值的字符串;<br>2.定义一致性哈希结构，用于构建cache server的哈希环;<br>3.定义添加哈希节点的函数;<br>4.定义获取哈希节点的函数;<br>5.定义删除哈希节点的函数。</p>
<p>1.定义cache server节点实体,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id       <span class="typename">int</span></span><br><span class="line">  Ip       <span class="typename">string</span></span><br><span class="line">  Port     <span class="typename">int</span></span><br><span class="line">  HostName <span class="typename">string</span></span><br><span class="line">  Weight   <span class="typename">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面定义了一个cache server node的实体, 作用是用于计算代表cache server node的唯一hash值, 在本程序中将采用缓存服务器的Id, IP, Weight以及虚拟节点Id作为计算字符串，说明如下:</p>
<p><code>Id</code>: 缓存服务器节点id<br><code>Ip</code>: 缓存服务器ip<br><code>Port</code>: 缓存服务器port<br><code>HostName</code>: 缓存服务器主机名(unique)<br><code>Weight</code>: 缓存服务器权重</p>
<p>2.定义一致性哈希结构，</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Consistent <span class="keyword">struct</span> &#123;</span><br><span class="line">  Nodes     <span class="keyword">map</span>[<span class="typename">uint32</span>]Node</span><br><span class="line">  numReps   <span class="typename">int</span></span><br><span class="line">  Resources <span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">bool</span></span><br><span class="line">  ring      HashRing</span><br><span class="line">  sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义了一致性哈希结构，说明如下,</p>
<p><code>Nodes</code>: 用于保存所有的hash-cache server node 映射关系<br><code>numReps</code>: 复制个数, 用于设置每个物理节点所虚拟的个数，即每个物理节点最后虚拟出多少个节点个数<br><code>Resources</code>: 用于标识当前物理节点是否已经被映射过了<br><code>ring</code>: 是一个切片数组， 用于保存所有的虚拟节点，即上面<code>Nodes</code>中的所有<code>key</code>值，可以通过这个<code>key</code>值到<code>Nodes</code>中去取对应的cache server信息，这个切片数组是排序过的，可以想象成一个环，及所谓的hash 环。<br><code>sync.RWMutex</code>: 读写锁，全部数据操作一致性。</p>
<p>3.定义添加哈希节点函数, 用于构建哈希环<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (c *Consistent) Add(node *Node) <span class="typename">bool</span> &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := c.Resources[node.Id]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count := c.numReps * node.Weight</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">		str := c.joinStr(i, node)</span><br><span class="line">		c.Nodes[c.hashStr(str)] = *(node)</span><br><span class="line">	&#125;</span><br><span class="line">	c.Resources[node.Id] = <span class="constant">true</span></span><br><span class="line">	c.sortHashRing()</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述添加哈希节点过程其实就是在计算一个一个cache server node的hash值，并构建排序过的哈希环， 大致分为以下几步:<br>1.检查当前物理节点是否已经被映射到哈希环上了，没有则进入下一步，<br>2.根据权重值计算出本物理节点的最终虚拟节点个数，然后分别计算对应虚拟节点的hash值,保存到<code>Nodes</code>结构中，<br>3.构建哈希环并排序，</p>
<p>4.定义获取哈希节点的函数, 用于将待存储的热点值存入到对应的cache server上,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (c *Consistent) Get(key <span class="typename">string</span>) Node &#123;</span><br><span class="line">	c.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.RUnlock()</span><br><span class="line"></span><br><span class="line">	hash := c.hashStr(key)</span><br><span class="line">	hit_index := c.search(hash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.Nodes[c.ring[hit_index]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大致过程，<br>1.计算对象key的hash值，<br>2.根据上面计算的hash值，用二分搜索法到哈希环搜索自上述hash值起离它最近的一个cache server node hash值节点key，<br>3.根据查找到的cache server节点key, 返回<code>Nodes</code>结构中存储的cache sever信息，</p>
<p>5.定义删除哈希节点的函数, 当某个cache server 挂掉之后，用于删除这个节点(一般情况下不建议删除节点，而是将当前坏节点上的数据迁移到好的节点上)<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (c *Consistent) Remove(node *Node) &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := c.Resources[node.Id]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(c.Resources, node.Id)</span><br><span class="line"></span><br><span class="line">	count := c.numReps * node.Weight</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">		str := c.joinStr(i, node)</span><br><span class="line">		<span class="built_in">delete</span>(c.Nodes, c.hashStr(str))</span><br><span class="line">	&#125;</span><br><span class="line">	c.sortHashRing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大致过程，<br>1.判断待删除物理节点是否存在哈希环中，存在则删除，并进入下一步，<br>2.删除改物理节点映射在哈希环中的所有虚拟节点,<br>3.重新排序哈希环,</p>
<p>至此一致性哈希算法基本实现， 详细代码请参见 <a href="https://github.com/researchlab/experiments/tree/master/consistent_hash" target="_blank" rel="external">https://github.com/researchlab/experiments/tree/master/consistent_hash</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;存在一种场景, 当一个缓存服务由多个服务器组共同提供时, key应该路由到哪一个服务。这里假如采用最通用的方式取模求余: &lt;code&gt;key%N&lt;/code&gt;(N为服务器数目), 这样做均衡性没有什么问题, 但是当服务器数目发送增加或减少时, 分配方式则变为&lt;code&gt;key%(N+1)&lt;/code&gt;或&lt;code&gt;key%(N-1)&lt;/code&gt;。这里将会有大量的key失效迁移, 如果后端key对应的是有状态的存储数据,那么毫无疑问,这种做法将导致服务器间大量的数据迁移,从而造成服务的不稳定。解决思路，采用一致性哈希方法可以解决此问题。 &lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://www.grdtechs.com/categories/algorithm/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>linux too many open files 问题解决总结</title>
    <link href="http://www.grdtechs.com/2017/01/14/too-many-open-files-solution/"/>
    <id>http://www.grdtechs.com/2017/01/14/too-many-open-files-solution/</id>
    <published>2017-01-14T10:58:37.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>运行在Linux系统上的网络程序可能会出现”Too many open files”的异常情况，且常见于高并发访问文件系统，多线程网络连接等场景。<br><a id="more"></a></p>
<h2 id="u6982_u5FF5"><a href="#u6982_u5FF5" class="headerlink" title="概念"></a>概念</h2><p>程序经常访问的文件、socket等在Linux中都是指的文件file，系统需要记录每个当前访问file的name、location、access authority等相关信息，这样的一个实体被称为file entry。<code>open files table</code>存储这些file entry，以数组的形式线性管理。文件描述符(file descriptor)是作为<code>进程</code>到<code>open files table</code>的指针，也就是<code>open files table</code>的下标索引，将每个进程与它所访问的文件关联起来了。 </p>
<center><img src="/imgs/too-many-files.jpg" alt="too many open files theory"></center>

<p> 每个进程中都有一个<code>file descriptor table</code>管理当前进程所访问(open or create)的所有文件file，文件描述符关联着<code>open files table</code>中文件的file entry。对于<code>open files table</code>能容纳多少file entry, 可由Linux系统配置<code>open files table</code>的文件限制，如果超过配置值，就会拒绝其它文件操作的请求，并抛出Too many open files异常。这种限制有系统级和用户级之分。 </p>
<ul>
<li><p>系统级：<br>  系统级设置对所有用户有效。可通过两种方式查看系统最大文件限制<br>  1  cat /proc/sys/fs/file-max<br>  2  sysctl -a 查看结果中fs.file-max这项的配置数量<br>  如果需要增加配置数量就修改/etc/sysctl.conf文件，配置fs.file-max属性，如果属性不存在就添加, 配置完成后使用sysctl -p来通知系统启用这项配置 </p>
</li>
<li><p>用户级：<br>  Linux限制每个登录用户的可连接文件数。可通过<code>ulimit -n</code>来查看当前有效设置。如果想修改这个值就使用<code>ulimit -n &lt;setting number&gt;</code>命令。<br>  对于文件描述符增加的比例，资料推荐是以2的幂次为参考。如当前文件描述符数量是1024，可增加到2048，如果不够，可设置到4096，依此类推。<br>  在出现Too many open files问题后，首先得找出主要原因。最大的可能是打开的文件或是socket没有正常关闭。为了定位问题是否由目标网络进程引起，通过目标网络程序进程号查看当前进程占用文件描述符情况： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -p <span class="variable">$target_pid</span> <span class="comment">#每个文件描述符的具体属性</span></span><br><span class="line">lsof -p <span class="variable">$target_pid</span> | wc <span class="operator">-l</span>  <span class="comment">#当前目标网络进程file descriptor table中FD的总量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u89E3_u51B3_u65B9_u6848_u603B_u7ED3"><a href="#u89E3_u51B3_u65B9_u6848_u603B_u7ED3" class="headerlink" title="解决方案总结"></a>解决方案总结</h2><p>方案一:</p>
<p>查看系统许可的最大文件限制， 如果不够可以修改此值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root nginx]<span class="comment"># cat /proc/sys/fs/file-max</span></span><br><span class="line"><span class="number">8096</span></span><br></pre></td></tr></table></figure></p>
<p>文件系统最大可打开文件数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root nginx]<span class="comment"># ulimit -n</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure></p>
<p>程序限制只能打开1024个文件</p>
<p>使用[root nginx]# ulimit -n 8096调整一下<br>或者永久调整打开文件数 可在启动文件/etc/rc.d/rc.local末尾添加（在/etc/sysctl.conf末尾添加fs.file-max=xxx无效）<br>ulimit -n 8096 </p>
<p>方案二:</p>
<p>Linux内核有时会报告<code>Too many open files</code>，起因是file-max默认值（8096）太小, 要解决这个问题，可以root身份执行下列命令（或将它们加入/etc/rcS.d/*下的init脚本。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"65536"</span>  &gt; /proc/sys/fs/file-max  <span class="comment"># 适用于2.2和2.4版内核</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"131072"</span> &gt; /proc/sys/fs/inode-max <span class="comment"># 仅适用于2.2版内核</span></span><br></pre></td></tr></table></figure>
<p>方案三:</p>
<p>办法是修改操作系统的打开文件数量限制，方法如下:</p>
<p>1.按照最大打开文件数量的需求设置系统，并且通过检查/proc/sys/fs/file-max文件来确认最大打开文件数已经被正确设置。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure>
<p>如果设置值太小， 修改文件/etc/sysctl.conf的变量到合适的值。 这样会在每次重启之后生效。(如果设置值够大，跳过下步)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="number">2048</span> &gt; /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure>
<p>编辑文件/etc/sysctl.conf，整体修改如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kernel2.6之后的内核版本添加如下配置：                                                                                                                                                                          </span></span><br><span class="line">net.nf_conntrack_max = <span class="number">3276800</span>                                                                                                                                                                                  </span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = <span class="number">1200</span>                                                                                                                                                       </span><br><span class="line">                                                                                                                                                                                                                </span><br><span class="line"><span class="comment">#当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭                                                                                                                               </span></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span>                                                                                                                                                                                     </span><br><span class="line"><span class="comment">#开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。                                                                                                                                                  </span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span>                                                                                                                                                                                     </span><br><span class="line"><span class="comment">#开启重用，将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；                                                                                                                                          </span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span>                                                                                                                                                                                       </span><br><span class="line"><span class="comment">#修改系統默认的 TIMEOUT 时间                                                                                                                                                                                    </span></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">25</span>                                                                                                                                                                                   </span><br><span class="line">net.ipv4.tcp_orphan_retries = <span class="number">1</span>                                                                                                                                                                                 </span><br><span class="line">net.ipv4.tcp_max_orphans = <span class="number">8192</span>                                                                                                                                                                                 </span><br><span class="line">net.ipv4.ip_<span class="built_in">local</span>_port_range = <span class="number">32768</span> <span class="number">61000</span>                                                                                                                                                                      </span><br><span class="line">                                                                                                                                                                                                                </span><br><span class="line"><span class="comment"># Disabled ipV6                                                                                                                                                                                                 </span></span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = <span class="number">1</span>                                                                                                                                                                              </span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = <span class="number">1</span>                                                                                                                                                                          </span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>2.在/etc/security/limits.conf文件中设置最大打开文件数，添加如下这行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* - nofile <span class="number">8192</span></span><br></pre></td></tr></table></figure>
<p>这行设置了每个用户的默认打开文件数为2048。注意<code>nofile</code>项有两个可能的限制措施。就是项下的hard和soft, 要使修改过的最大打开文件数生效，必须对这两种限制进行设定。 如果使用”-“字符设定, 则hard和soft设定会同时被设定。硬限制表明soft限制中所能设定的最大值。soft限制指的是当前系统生效的设置值。hard限制值可以被普通用户降低, 但是不能增加。soft限制不能设置的比hard限制更高。只有root用户才能够增加hard限制值。当增加文件限制描述，可以简单的把当前值双倍。 例: 如果你要提高默认值1024， 最好提高到2048， 如果还要继续增加， 就需要设置成4096。<br>另外一种情况是在创建索引的时候，也有两种可能，一种是合并因子太小，导致创建文件数量超过操作系统限制，这时可以修改合并因子，也可以修改操作系统的打开文件数限制；另外一种是合并因子受虚拟机内存的限制，无法调整到更大，而需要索引的doc数量又非常的大，这个时候就只能通过修改操作系统的打开文件数限制来解决了。</p>
<p>在此基础上，我还修改了以下一个配置文件</p>
<p>vim /etc/sysctl.conf, 添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Decrease the time default value for tcp_fin_timeout connection</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">30</span></span><br><span class="line"><span class="comment"># Decrease the time default value for tcp_keepalive_time connection</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = <span class="number">1800</span></span><br><span class="line"><span class="comment"># Turn off tcp_window_scaling</span></span><br><span class="line">net.ipv4.tcp_window_scaling = <span class="number">0</span></span><br><span class="line"><span class="comment"># Turn off the tcp_sack</span></span><br><span class="line">net.ipv4.tcp_sack = <span class="number">0</span></span><br><span class="line"><span class="comment">#Turn off tcp_timestamps</span></span><br><span class="line">net.ipv4.tcp_timestamps = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后 service network restart, 这些都和<code>TCP sockets</code>有关的优化。</p>
<p>另外需要在 /etc/rc.d/rc.local里添加已使得重启的时候生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"30"</span>&gt;/proc/sys/net/ipv4/tcp_fin_timeout</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1800"</span>&gt;/proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span>&gt;/proc/sys/net/ipv4/tcp_window_scaling</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span>&gt;/proc/sys/net/ipv4/tcp_sack</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span>&gt;/proc/sys/net/ipv4/tcp_timestamps</span><br></pre></td></tr></table></figure>
<p>因为不是所有的程序都在root下跑的，所有linux有对hard与soft open files的区分，普通用户受hard的限制，无论ulimit -n $数值调到多高，都跑不到 /etc/security/limits.conf里nofile的值。</p>
<p>这样的优化后 lsof -p $target_pid|wc -l可以跑到4千以上都不会抛出too many open files。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;运行在Linux系统上的网络程序可能会出现”Too many open files”的异常情况，且常见于高并发访问文件系统，多线程网络连接等场景。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://www.grdtechs.com/categories/DevOps/"/>
    
    
      <category term="linux" scheme="http://www.grdtechs.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>总结printf 格式化标识</title>
    <link href="http://www.grdtechs.com/2017/01/06/go-printf-format/"/>
    <id>http://www.grdtechs.com/2017/01/06/go-printf-format/</id>
    <published>2017-01-06T15:49:13.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>项目中总是时不时的要使用<code>fmt.Printf</code>或<code>fmt.Sprintf</code>来处理某些数据类型,总结一下常用的标识符用途及场景.</p>
<a id="more"></a>
<h2 id="u6807_u8BC6_u7B26_u7528_u9014_u53CA_u573A_u666F"><a href="#u6807_u8BC6_u7B26_u7528_u9014_u53CA_u573A_u666F" class="headerlink" title="标识符用途及场景"></a>标识符用途及场景</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line"><span class="comment">//Go 为常规 Go 值的格式化设计提供了多种打印方式。例如，这里打印了 point 结构体的一个实例。</span></span><br><span class="line">    p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, p) <span class="comment">// &#123;1 2&#125;</span></span><br><span class="line"><span class="comment">//如果值是一个结构体，%+v 的格式化输出内容将包括结构体的字段名。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, p) <span class="comment">// &#123;x:1 y:2&#125;</span></span><br><span class="line"><span class="comment">//%#v 形式则输出这个值的 Go 语法表示。例如，值的运行源代码片段。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, p) <span class="comment">// main.point&#123;x:1, y:2&#125;</span></span><br><span class="line"><span class="comment">//需要打印值的类型，使用 %T。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, p) <span class="comment">// main.point</span></span><br><span class="line"><span class="comment">//格式化布尔值是简单的。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, <span class="constant">true</span>)</span><br><span class="line"><span class="comment">//格式化整形数有多种方式，使用 %d进行标准的十进制格式化。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, <span class="number">123</span>)</span><br><span class="line"><span class="comment">//这个输出二进制表示形式。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">14</span>)</span><br><span class="line">这个输出给定整数的对应字符。</span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">33</span>)</span><br><span class="line">%x 提供十六进制编码。</span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>, <span class="number">456</span>)</span><br><span class="line"><span class="comment">//对于浮点型同样有很多的格式化选项。使用 %f 进行最基本的十进制格式化。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%f\n"</span>, <span class="number">78.9</span>)</span><br><span class="line"><span class="comment">//%e 和 %E 将浮点型格式化为（稍微有一点不同的）科学技科学记数法表示形式。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">123400000.0</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">123400000.0</span>)</span><br><span class="line"><span class="comment">//使用 %s 进行基本的字符串输出。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="string">"\"string\""</span>)</span><br><span class="line"><span class="comment">//像 Go 源代码中那样带有双引号的输出，使用 %q。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, <span class="string">"\"string\""</span>)</span><br><span class="line"><span class="comment">//和上面的整形数一样，%x 输出使用 base-16 编码的字符串，每个字节使用 2 个字符表示。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">"hex this"</span>)</span><br><span class="line"><span class="comment">//要输出一个指针的值，使用 %p。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;p)</span><br><span class="line"><span class="comment">//当输出数字的时候，你将经常想要控制输出结果的宽度和精度，可以使用在 % 后面使用数字来控制输出宽度。默认结果使用右对齐并且通过空格来填充空白部分。</span></span><br><span class="line">    fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>, <span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"><span class="comment">//你也可以指定浮点型的输出宽度，同时也可以通过 宽度.精度 的语法来指定输出的精度。</span></span><br><span class="line">    fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"><span class="comment">//要最对齐，使用 - 标志。</span></span><br><span class="line">    fmt.Printf(<span class="string">"|%-6.2f|%-6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"><span class="comment">//你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。这是基本的右对齐宽度表示。</span></span><br><span class="line">    fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br><span class="line"><span class="comment">//要左对齐，和数字一样，使用 - 标志。</span></span><br><span class="line">    fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br><span class="line"><span class="comment">//到目前为止，我们已经看过 Printf了，它通过 os.Stdout输出格式化的字符串。Sprintf 则格式化并返回一个字符串而不带任何输出。</span></span><br><span class="line">    s := fmt.Sprintf(<span class="string">"a %s"</span>, <span class="string">"string"</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"><span class="comment">//你可以使用 Fprintf 来格式化并输出到 io.Writers而不是 os.Stdout。</span></span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">"an %s\n"</span>, <span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;项目中总是时不时的要使用&lt;code&gt;fmt.Printf&lt;/code&gt;或&lt;code&gt;fmt.Sprintf&lt;/code&gt;来处理某些数据类型,总结一下常用的标识符用途及场景.&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>go实现缓存组件</title>
    <link href="http://www.grdtechs.com/2016/12/17/go-cache-component/"/>
    <id>http://www.grdtechs.com/2016/12/17/go-cache-component/</id>
    <published>2016-12-17T11:32:51.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>总结用golang从分析，设计到实现一个可用的缓存组件。<br><a id="more"></a></p>
<h2 id="u7F13_u5B58"><a href="#u7F13_u5B58" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li><p>为什么要设计缓存<br>  电脑的内存是以系统总线的时钟频率工作的，这个频率通常也就是CPU的外频(对于雷鸟、毒龙系列的处理器，由于在设计采用了DDR技术，CPU工作的外频为系统总线频率的两倍)。但是，CPU的工作频率(主频)是外频与倍频因子的乘积。这样一来，内存的工作频率就远低于CPU的工作频率了,造成的直接结果是：CPU在执行完一条指令后，常常需要”等待”一些时间才能再次访问内存，极大降了CPU工作效率。在这样一种情况下，Cache就应运而生,Cache是一种特殊的存储器，它由Cache 存储部件和Cache控制部件组成。Cache 存储部件一般采用与CPU同类型的半导体存储器件，存取速度比内存快几倍甚至十几倍。<br>  缓存(Cache)在计算机硬件中普遍存在。比如在CPU中就有一级缓存，二级缓存，甚至三级缓存。缓存的工作原理一般是CPU需要读取数据时，会首先从缓存中查找需要的数据，如果找到了就直接进行处理，如果没有找到则从内存中读取数据。缓存不仅仅存在于硬件中，在各种软件系统中也处处可见。比如在Web系统中，缓存存在于服务器端，客户端或者代理服务器中。广泛使用的CDN网络，也可以看作一个巨大的缓存系统。缓存在Web系统中的使用有很多好处，不仅可以减少网络流量，降低客户访问延迟，还可以减轻服务器负载。</p>
</li>
<li><p>缓存如何工作<br> 单颗CPU运行程序是一条指令一条指令地执行的，而且指令地址往往是连续的，意思就是说CPU在访问内存时，在较短的一段时间内往往集中于某个局部，这时候可能会碰到一些需要反复调用的子程序。电脑在工作时，把这些活跃的子程序存入比内存快得多的Cache中。CPU在访问内存时，首先判断所要访问的内容是否在Cache中，如果在，就称为<code>命中</code>，此时CPU直接从Cache中调用该内容；否则，就称为<code>不命中</code>，CPU只好去内存中调用所需的子程序或指令了。CPU不但可以直接从Cache中读出内容，也可以直接往其中写入内容。由于Cache的存取速率相当快，使得CPU的利用率大大提高，进而使整个系统的性能得以提升。<br> CPU通过地址映射Cache和主存关联起来，从而确定将要访问的主存的内容是否在缓存中，所谓映象问题是指如何确定Cache中的内容是主存中的哪一部分的拷贝，即必须应用某种函数把主存地址映象到Cache中定位，也称地址映象。当信息按这种方式装入Cache中后，执行程序时，应将主存地址变换为Cache地址，这个变换过程叫作地址变换。</p>
<ul>
<li>地址映象方式通常采用<code>直接映象</code>、<code>全相联映象</code>、<code>组相联映象</code>三种<ol>
<li><code>直接映像</code><br>是指每个主存页只能复制到某一固定的Cache页中。直接映像的规律是：将主存的2048页分为128组，每组有16页，分别与Cache的16页直接对应，即主存的第0页、第16页、第32页……只能映像到Cache的第0页。</li>
<li><code>全相联映像</code><br>全相联映像是指主存的每一页可以映像可以映像到Cache的任意一页。</li>
<li><code>组相联映像</code><br>组相联映像是直接映像与全相联映像的折中方案，它将Cache分为若干组，如8组；每组若干页，如2页；同时将主存分为若干组，如255组；每组内的页数与Cache的组数相同，如8页。组相联映像的规律是主存中的各页与Cache的组号有固定的映像关系，但可自由映像到对应的Cache组中的任意一页。即组间采用直接映像，而组内的页为全相联映像。</li>
</ol>
</li>
</ul>
</li>
<li><p>缓存更新机制<br>  当CPU访问Cache未命中时，应从主存中读取信息，同时写入Cache。若Cache未满，则直接写入；若Cache已满，则需要进行替换。替换机构由硬件组成，并按替换算法进行设计，其作用是指出替换的页号。常用的替换算法有<code>先进先出算法(FIFO)</code>和<code>近期最少使用算法(LRU)</code>。</p>
</li>
<li><p>缓存读/写操作</p>
</li>
</ul>
<ol>
<li><code>读操作</code><br>访存时，将主存地址同时送主存和Cache，一则启动对主存的读操作，二则在Cache中按映像方式从中获取Cache地址，并将主存标记与Cache标记比较：若相同，则访问命中，从Cache中读取数据。因为Cache速度比主存速度快，所以不等主存读操作结束，即可继续下一次访存操作；若不相同，则访问未命中，则从主存中读取数据，并考虑是否按某种替换算法更新Cache某页的内容。</li>
<li><code>写操作</code><br> 将数据写入主存有两种方法，<code>写回法</code>和<code>写直达法</code>。<br> <code>写回法</code>: 信息暂时只写入Cache，并用标志加以注明，直到该页内容需从Cache中替换出来时，才一次写入主存。优点是操作速度快，缺点是写回主存前，主存中没有这些内容，与Cache不一致，易造成错误。<br> <code>写直达法</code>: 信息在写入Cahce时也同时写入主存。优点是主存与Cache始终保持一致，但速度慢。</li>
</ol>
<p>目前已经存在很多高性能的缓存系统，比如Memcache，Redis等，尤其是Redis，现已经广泛用于各种Web服务中。既然有了这些功能完善的缓存系统，那为什么我们还需要自己实现一个缓存系统呢？这么做主要有两个原因，第一，通过动手实现我们可以了解缓存系统的工作原理，这也是老掉牙的理由了。第二，Redis 之类的缓存系统都是独立存在的，如果只是开发一个简单的应用还需要单独使用Redis服务器，难免会过于复杂。这时候如果有一个功能完善的软件包实现了这些功能，只需要引入这个软件包就能实现缓存功能，而不需要单独使用 Redis 服务器，就最好不过了。</p>
<h2 id="u7F13_u5B58_u7EC4_u4EF6_u8BBE_u8BA1"><a href="#u7F13_u5B58_u7EC4_u4EF6_u8BBE_u8BA1" class="headerlink" title="缓存组件设计"></a>缓存组件设计</h2><ul>
<li><p>缓存系统中，缓存的数据一般都存储在内存中，所以我们设计的缓存系统要以某一种方式管理内存中的数据。既然缓存数据是存储在内存中的，那如果系统停机，那数据岂不就丢失了吗？其实一般情况下，缓存系统还支持将内存中的数据写入到文件中，在系统再次启动时，再将文件中的数据加载到内存中，这样一来就算系统停机，缓存数据也不会丢失。</p>
</li>
<li><p>同时缓存系统还提供过期数据清理机制，也就是说缓存的数据项是有生存时间的，如果数据项过期，则数据项会从内存中被删除，这样一来热数据会一直存在，而冷数据则会被删除，也没有必要进行缓存。</p>
</li>
<li><p>缓存系统还需要对外提供操作的接口，这样系统的其他组件才能使用缓存。一般情况下，缓存系统需要支持<code>CRUD操作</code>，即创建(添加)，读取，更新和删除操作。</p>
<p>通过以上分析，可以总结出缓存系统需要有以下功能：</p>
<ol>
<li>缓存数据的存储;</li>
<li>过期数据项管理;</li>
<li>内存数据导出/导入;</li>
<li>提供CRUD接口. </li>
</ol>
</li>
</ul>
<h2 id="u7F13_u5B58_u7EC4_u4EF6_u5B9E_u73B0"><a href="#u7F13_u5B58_u7EC4_u4EF6_u5B9E_u73B0" class="headerlink" title="缓存组件实现"></a>缓存组件实现</h2><p>缓存数据需要存储在内存中，这样才可以被快速访问。那使用什么数据结构来存储数据项呢？一般情况下，我们使用哈希表来存储数据项，这样访问数据项将获得更好的性能。在golang语言中内建类型map已经实现了哈希表，所以可以直接将缓存数据项存储在map中。同时由于缓存系统需要支持过期数据清理，所以缓存数据项应该带有生存时间，这说明需要将缓存数据进行封装后，保存到缓存系统中。这样我们就需要先实现缓存数据项，其实现的代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    Object     <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 真正的数据项</span></span><br><span class="line">    Expiration <span class="typename">int64</span>       <span class="comment">// 生存时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数据项是否已经过期</span></span><br><span class="line"><span class="keyword">func</span> (item Item) Expired() <span class="typename">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> item.Expiration == <span class="number">0</span> &#123;</span><br><span class="line">	   <span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Now().UnixNano() &gt; item.Expiration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>Item</code>结构中， <ul>
<li><code>Object</code>: 用于存储任意类型的数据对象;</li>
<li><code>Expiration</code>: 字段则存储了该数据项的过期时间;</li>
<li><code>Expired()</code>方法: 用于检测当前缓存数据项是否过期，返回<code>false</code>表示过期, 其中数据项的过期时间，是<code>Unix时间戳</code>，单位是纳秒; 用<code>time</code>包实现一个<code>ticker</code>定期检查每一项数据项，如果发现数据项的过期时间小于当前时间，则调用删除方法将数据项从缓存系统中删除.</li>
</ul>
</li>
</ul>
<p>现在来设计实现缓存组件的结构， 代码如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 没有过期时间标志</span></span><br><span class="line">    NoExpiration time.Duration = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的过期时间</span></span><br><span class="line">    DefaultExpiration time.Duration = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    defaultExpiration time.Duration</span><br><span class="line">    items             <span class="keyword">map</span>[<span class="typename">string</span>]Item <span class="comment">// 缓存数据项存储在 map 中</span></span><br><span class="line">    mu                sync.RWMutex    <span class="comment">// 读写锁</span></span><br><span class="line">    gcInterval        time.Duration   <span class="comment">// 过期数据项清理周期</span></span><br><span class="line">    stopGc            <span class="keyword">chan</span> <span class="typename">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过期缓存数据项清理</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) gcLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(c.gcInterval)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            c.DeleteExpired()</span><br><span class="line">        <span class="keyword">case</span> &lt;-c.stopGc:</span><br><span class="line">            ticker.Stop()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ 删除缓存数据项</span><br><span class="line"><span class="keyword">func</span> (c *Cache) del(k <span class="typename">string</span>) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(c.items, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除过期数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) DeleteExpired() &#123;</span><br><span class="line">    now := time.Now().UnixNano()</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> c.items &#123;</span><br><span class="line">        <span class="keyword">if</span> v.Expiration &gt; <span class="number">0</span> &amp;&amp; now &gt; v.Expiration &#123;</span><br><span class="line">            c.del(k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>缓存组件结构<code>Cache</code>，<ul>
<li><code>NoExpiration</code>: 表示数据项永远不过期;</li>
<li><code>DefaultExpiration</code>: 后者表示数据项默认过期时间;</li>
<li><code>items</code>: 是一个<code>map</code>，用于存储缓存数据项;</li>
<li><code>mu</code>: 读写锁， 为保证缓存读写数据一致性，在相应操作前应加锁;</li>
<li><code>gcInterval</code>: 表示隔多久清理一次过期缓存数据;</li>
<li><code>gcLoop()方法</code>: 该方通过time.Ticker 定期执行<code>DeleteExpired()</code>方法，从而清理过期的数据项;通过监听c.stopGc通道，在必要的时候安全结束<code>gcLoop()</code>; </li>
</ul>
</li>
</ul>
<p>通过实现<code>Set</code>和<code>Add</code>方法向缓存系统中添加数据， 通过实现<code>Get</code>方法获取缓存数据,实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置缓存数据项，如果数据项存在则覆盖</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Set(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) &#123;</span><br><span class="line">	<span class="comment">//已省略添加过期时间逻辑</span></span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    c.items[k] = Item&#123;</span><br><span class="line">        Object:     v,</span><br><span class="line">        Expiration: e,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数据项, 没有锁操作</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) set(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) &#123;</span><br><span class="line">	<span class="comment">// to-do    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据项，如果找到数据项，还需要判断数据项是否已经过期</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) get(k <span class="typename">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="typename">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// to-do</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据项，如果数据项已经存在，则返回错误</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Add(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) error &#123;</span><br><span class="line">	<span class="comment">// to-do</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Get(k <span class="typename">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="typename">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// to-do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Set()与Add()的主要区别在于Set()方法将数据添加到缓存系统中时，如果数据项已经存在则会覆盖，而后者如果发现数据项已经存在则会发生报错，这样能避免缓存被错误的覆盖;</li>
<li>通过Set(), Add()和Get()来写入/读取缓存数据时，应注意加锁保证数据操作的一致性。</li>
</ul>
<p>除了向缓存系统中写入/读取缓存数据以外，还需要实现更新和删除缓存数据， 实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换一个存在的数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Replace(k <span class="typename">string</span>, v <span class="keyword">interface</span>&#123;&#125;, d time.Duration) error &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    _, found := c.get(k)</span><br><span class="line">    <span class="keyword">if</span> !found &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Item %s doesn't exist"</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line">    c.set(k, v, d)</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Delete(k <span class="typename">string</span>) &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.del(k)</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了是缓存数据在重启程序或系统后依然存在，则应将缓存数据持久化处理，本文方案提供将缓存数据写入本地文件的持久化操作，具体实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将缓存数据项写入到 io.Writer 中</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Save(w io.Writer) (err error) &#123;</span><br><span class="line">    enc := gob.NewEncoder(w)</span><br><span class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="constant">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"Error registering item types with Gob library"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> c.items &#123;</span><br><span class="line">        gob.Register(v.Object)</span><br><span class="line">    &#125;</span><br><span class="line">    err = enc.Encode(&amp;c.items)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据项到文件中</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) SaveToFile(file <span class="typename">string</span>) error &#123;</span><br><span class="line">    f, err := os.Create(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = c.Save(f); err != <span class="constant">nil</span> &#123;</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 io.Reader 中读取数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) Load(r io.Reader) error &#123;</span><br><span class="line">    dec := gob.NewDecoder(r)</span><br><span class="line">    items := <span class="keyword">map</span>[<span class="typename">string</span>]Item&#123;&#125;</span><br><span class="line">    err := dec.Decode(&amp;items)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="constant">nil</span> &#123;</span><br><span class="line">        c.mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> items &#123;</span><br><span class="line">            ov, found := c.items[k]</span><br><span class="line">            <span class="keyword">if</span> !found || ov.Expired() &#123;</span><br><span class="line">                c.items[k] = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中加载缓存数据项</span></span><br><span class="line"><span class="keyword">func</span> (c *Cache) LoadFile(file <span class="typename">string</span>) error &#123;</span><br><span class="line">    f, err := os.Open(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = c.Load(f); err != <span class="constant">nil</span> &#123;</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Save()</code>通过<code>gob</code>模块将二进制缓存数据转码写入到实现了io.Writer 接口的对象中;</li>
<li><code>Load()</code>则从<code>io.Reader</code>中读取二进制数据，然后通过<code>gob</code>模块将数据进行反序列化;</li>
<li><code>SaveToFile</code>和<code>LoadFile</code>则向指定的文件中写入和读取缓存数据.</li>
</ul>
<p>至此整个缓存系统基本实现，支持数据对象添加，删除，替换，和查询操作，同时还支持过期数据的删除。<br><a href="/">github-完整代码示例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;总结用golang从分析，设计到实现一个可用的缓存组件。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="cache" scheme="http://www.grdtechs.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>UML类图中符号定义,作用及区别总结</title>
    <link href="http://www.grdtechs.com/2016/11/23/uml-symbol-desc/"/>
    <id>http://www.grdtechs.com/2016/11/23/uml-symbol-desc/</id>
    <published>2016-11-23T11:47:43.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在UML的定义中，描述类和对象之间的关系，包括以下几种方式：依赖（<code>Dependency</code>）、关联（<code>Association</code>）、聚合（<code>Aggregation</code>）、组合（<code>Composition</code>）、泛化（<code>Generalization</code>）和实现（<code>Realization</code>）。现分别说明如下：<br><a id="more"></a></p>
<h2 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h2><p>类图基本符号可拆分为四类:<code>线</code>(<code>虚线</code>和<code>实线</code>)，<code>箭头</code>，<code>三角</code>(<code>空心右三角</code>和<code>实心右三角</code>)，<code>菱形</code>(<code>空心菱形</code>和<code>实心菱形</code>); 由这些基本的图形进行组合构成了类图的基本符号。这里要注意这几个符号的顺序，代表了类与类之间关系的耦合程度, 越向右耦合度越高。</p>
<p>由上述四类图形（<code>线</code>，<code>箭头</code>,<code>三角</code>,<code>菱形</code>)可构成以下类图中六类常用关系,</p>
<ol>
<li><code>虚线+箭头</code>是表示即<code>依赖</code>的关系;</li>
<li><code>实线+箭头</code>表示<code>关联</code>的关系;</li>
<li><code>虚线+空心右三角</code>表示<code>实现</code>接口;</li>
<li><code>实线+空心右三角</code>表示的是<code>泛化</code>，即<code>类的继承关系</code>;</li>
<li><code>实线+空心菱形</code>表示的是<code>聚合</code>的关系;</li>
<li><code>实线+实心菱形</code>则表示<code>组合</code>的关系。</li>
</ol>
<p>看类图的时候要注意, 类图的思想其实也还没有脱离面向对象的思想，以某个类为中心，有些线是射入的而有些线是射出的。射入的线表示的是这个类被哪些类所调用而射出的线则表示该类调用了哪些类，包括泛化，关联，依赖，聚合和组合四种关系。这类似于离散数学中有关图部分的描述。</p>
<ul>
<li>类(Class):使用三层矩形框表示<ol>
<li>第一层显示类的名称，如果是抽象类，则就用斜体显示;</li>
<li>第二层是字段和属性;</li>
<li>第三层是类的方法。 </li>
</ol>
</li>
</ul>
<blockquote>
<p>注意前面的符号，<code>+</code>表示public，<code>-</code>表示private，<code>#</code>表示protected, <code>~</code>表示package</p>
</blockquote>
<ul>
<li><p>接口:使用两层矩形框表示，与类图的区别主要是顶端有<code>&lt;&lt;interface&gt;&gt;</code>显示 </p>
<ol>
<li>第一行是接口名称; </li>
<li>第二行是接口方法。 </li>
</ol>
</li>
<li><p>继承类(extends):用空心三角形+实线来表示 </p>
</li>
<li><p>实现接口(implements):用空心三角形+虚线来表示 </p>
</li>
<li><p>关联(Association):用实线箭头来表示，例如:燕子与气候 </p>
</li>
<li><p>聚合(Aggregation):用空心的菱形+实线箭头来表示 </p>
<ol>
<li>聚合:表示一种弱的<code>拥有</code>关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，例如:公司和员工</li>
</ol>
</li>
<li><p>组合(Composition):用实心的菱形+实线箭头来表示 </p>
<ol>
<li>组合:部分和整体的关系，并且生命周期是相同的。例如:人与手 </li>
</ol>
</li>
<li><p>依赖(Dependency):用虚线箭头来表示，例如:动物与氧气 </p>
</li>
<li><p>基数:连线两端的数字表明这一端的类可以有几个实例，比如:一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用<code>n</code>来表示。关联、聚合、组合是有基数的</p>
</li>
</ul>
<p>下面详细阐述类图中六类常用关系,</p>
<h2 id="u4F9D_u8D56_uFF08Dependency_uFF09"><a href="#u4F9D_u8D56_uFF08Dependency_uFF09" class="headerlink" title="依赖（Dependency）"></a>依赖（<code>Dependency</code>）</h2><p>在uml中，<code>依赖</code>表示为<code>带箭头的虚线</code>，<code>箭头指向被依赖的元素</code>。是类与类之间的连接，表示为一个类依赖于另一个类的定义，其中一个类的变化将影响另一个类。依赖总是单向的，不应该存在双向依赖，这一点要特别注意。更具体的说，依赖可以理解为：<code>一个类（A）对不在其实例作用域内的另一个类或对象（B）的任何类型的引用</code>。大致包含以下几种情况：<br>（1）局部变量；<br>（2）方法的参数；<br>（3）静态方法的调用；</p>
<p>下面是依赖关系的uml示意图：<br><img src="/imgs/uml_dependency.png" alt="uml-dependency"></p>
<blockquote>
<p>1.综合上图，Class-A类的实现依赖Class-B类，即Class-A类可能要用到Class-B类的一些方法，即，要完成Class-A里的所有功能，一定要有Class-B类的某些方法协助才行.</p>
</blockquote>
<h2 id="u5173_u8054_uFF08Association_uFF09"><a href="#u5173_u8054_uFF08Association_uFF09" class="headerlink" title="关联（Association）"></a>关联（<code>Association</code>）</h2><p>在uml中，<code>关联</code>表示为<code>带箭头的实线</code>。关联可以是单向的，也可以是双向的, 还有自身关联是指拥有一个自身的引用。如果是双向关联，则可以表示为双向箭头，或者没有箭头,双向关联是指双方都拥有对方的引用, 都可以调用对方的公共属性和方法。一般来说，系统设计应表现为单向关联，这样利于维护。一个关联可以附加<code>多重性</code>的修饰符，表示两个类之间的数量关系。关联可以理解为：<code>一个类（A）持有另一个类或对象（B）</code>。具体表现为：</p>
<p>下面是关联关系的uml示例图：<br><img src="/imgs/uml_association.png" alt="uml-association"></p>
<blockquote>
<p>1.上面的关联表示，一个Employee持有(has)0个或多个TimeCard，从而可以调用其中的属性或方法，但Employee与TimeCard之间没有生命期的依赖。</p>
</blockquote>
<h2 id="u805A_u5408_uFF08Aggregation_uFF09"><a href="#u805A_u5408_uFF08Aggregation_uFF09" class="headerlink" title="聚合（Aggregation）"></a>聚合（<code>Aggregation</code>）</h2><p>在uml中，<code>聚合</code>表示为<code>空心的菱形箭头线</code>。<code>聚合关系</code>是关联关系的一种，表示一种<code>强</code>关联关系。对比<code>关联关系</code>，两个类是处于同一个层次的。而聚合关系，两个类处于不同的层次，强调了一个整体/局部的关系。例如一辆汽车有一个引擎，4个轮胎。在聚合关系中，体现了一种<code>弱拥有</code>的概念。也就是说，对象A拥有对象B，但B并不是A的组成部分。更具体的表现为，如果A由B聚合而成，则A包含B的全局对象，但B对象可以不在A对象创建时创建。回到前面的例子，汽车对象由轮胎对象聚合而成，但是轮胎对象的生命期并不受汽车对象的左右。当汽车对象销毁时，轮胎对象也可以单独存在！</p>
<p>下面是聚合关系的uml示意图：</p>
<p><img src="/imgs/uml_aggregation.png" alt="uml-aggregation"></p>
<blockquote>
<p>从代码上看，聚合和关联没有任何区别。这里仅仅体现一种概念上的含义。在创建ClassA的时候，不一定需要同时创建ClassB的实例。 表示ClassA由ClassB聚合而成，但ClassB可以独立存在。</p>
</blockquote>
<h2 id="u7EC4_u5408_uFF08Composition_uFF09"><a href="#u7EC4_u5408_uFF08Composition_uFF09" class="headerlink" title="组合（Composition）"></a>组合（<code>Composition</code>）</h2><p>在uml中，<code>组合</code>表示为<code>实心菱形箭头线</code>。组合也叫合成。合成关系强调了比聚合关系更加强的整体/部分的关联，例如人和四肢。和聚合关系所不同的是，在组合关系中，虽然局部不一定随着整体的销毁而销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。也就是说，组合关系中，局部的存活期一定是小于，最多是等于整体的存活期的。</p>
<p>下面是组合关系的uml示例图：</p>
<p><img src="/imgs/uml_composition.png" alt="uml-composition"> </p>
<h2 id="u6CDB_u5316_uFF08Generalization_uFF09"><a href="#u6CDB_u5316_uFF08Generalization_uFF09" class="headerlink" title="泛化（Generalization）"></a>泛化（<code>Generalization</code>）</h2><p><code>泛化也就是通常所谓的继承关系</code>，在uml中表示为一个<code>带空心三角的实线</code>。表示为is-a的关系，是对象间耦合度最大的一种关系，子类继承父类的所有细节，并可以在此基础上添加自己的特性。</p>
<p>下面是泛化关系的uml图：</p>
<p><img src="/imgs/uml_generalization.png" alt="uml-generalization"></p>
<h2 id="u5B9E_u73B0_uFF08Realization_uFF09"><a href="#u5B9E_u73B0_uFF08Realization_uFF09" class="headerlink" title="实现（Realization）"></a>实现（<code>Realization</code>）</h2><p>所谓<code>实现</code>就是<code>类对接口的定义实现</code>，表示类是接口所有特征和行为的实现。表现为<code>带箭头的虚线</code>。</p>
<p>下面的实现的uml图：</p>
<p><img src="/imgs/uml_realization.png" alt="uml-realization"></p>
<p>下面通过一副类图包含上述六类常用关系,</p>
<p><img src="/imgs/uml_all_class.png" alt="uml-all-class"></p>
<blockquote>
<ol>
<li>依赖: 动物依赖氧气，水.</li>
<li>关联: 当一个类知道另一个类时，可以用关联关系。现在企鹅需要知道气候的变化，了解气候的变化规律. </li>
<li>聚合: 雅群由单只大雅聚合而成，但是单只大雁可独立存在. </li>
<li>组合: 一只鸟包含两支翅膀,但是翅膀无法单独存活,即生命期在鸟的生命期内.</li>
<li>泛化: 泛化即继承,子类继承父类属性及方法,如大雁从鸟类继承而来.</li>
<li>实现: 类对接口的实现，如大雁类实现了飞翔接口的所有方法(飞),所以大雁类实现了飞翔这个接口.</li>
</ol>
<p>说明: 关联又可以分为聚合，组合，他们的主要区别体现在类和类之间关联的强度,聚合是一种较弱拥有的关联关系, 如雁群由单只大雁聚合而成，但不能强制要求单只大雁飞离雁群; 而组合是一种强拥有的聚合关系，如鸟有两支翅膀，但是单独把翅膀从鸟身上砍下来，它本身无法存活无法飞.</p>
</blockquote>
<h2 id="u5173_u8054_u53CA_u533A_u522B"><a href="#u5173_u8054_u53CA_u533A_u522B" class="headerlink" title="关联及区别"></a>关联及区别</h2><p>面向对象建模依赖、关联、聚合以及组合关系区别,</p>
<ol>
<li>语义<ul>
<li>依赖表达 <code>use a</code></li>
<li>关联表达 <code>has a</code></li>
<li>聚合表达 <code>owns a</code></li>
<li>组合表达 <code>is a part of</code></li>
</ul>
</li>
<li>四种联系是递进的，表示对象之间的联系越来越紧密</li>
<li>代码实现形式<ul>
<li><code>依赖</code>：一般对应局部变量，方法形参，静态方法调用表达</li>
<li><code>关联</code>：一般对应成员变量，有时也用方法形参的形式</li>
<li><code>聚合</code>：一般对应成员变量，聚合关系一般使用setter方法给成员变量赋值</li>
<li><code>组合</code>：一般来说，为了表示组合关系，常常会使用构造方法来达到初始化的目的</li>
</ul>
</li>
</ol>
<p>另一篇值得参考的文章:  <a href="http://www.jasongj.com/uml/class_diagram/" target="_blank" rel="external">UML(一) 类图详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在UML的定义中，描述类和对象之间的关系，包括以下几种方式：依赖（&lt;code&gt;Dependency&lt;/code&gt;）、关联（&lt;code&gt;Association&lt;/code&gt;）、聚合（&lt;code&gt;Aggregation&lt;/code&gt;）、组合（&lt;code&gt;Composition&lt;/code&gt;）、泛化（&lt;code&gt;Generalization&lt;/code&gt;）和实现（&lt;code&gt;Realization&lt;/code&gt;）。现分别说明如下：&lt;br&gt;
    
    </summary>
    
      <category term="go-pattern" scheme="http://www.grdtechs.com/categories/go-pattern/"/>
    
    
      <category term="uml" scheme="http://www.grdtechs.com/tags/uml/"/>
    
  </entry>
  
  <entry>
    <title>golang处理数据表中字段为空或NULL的情况</title>
    <link href="http://www.grdtechs.com/2016/11/23/go-dealwith-database-nullvalue/"/>
    <id>http://www.grdtechs.com/2016/11/23/go-dealwith-database-nullvalue/</id>
    <published>2016-11-23T11:40:54.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang是强类型语言，在赋值和解析过程中需要先定义好数据类型，否在会报类型错误，下面总结在处理数据库表时遇到字段为空或零值的情况<br><a id="more"></a></p>
<h2 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h2><p>假如存在如下没有指定<code>not null</code>的场合<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">"users"</span> (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">serial</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="string">"name"</span> <span class="built_in">text</span>,</span><br><span class="line">    <span class="string">"age"</span> <span class="built_in">integer</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<p>在<a href="https://github.com/researchlab/gorp" target="_blank" rel="external">gorp</a>中<code>insert</code>插入场合，可以直接赋零值即可，很方便.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbmap.Insert(</span><br><span class="line"> &amp;User&#123;Name: <span class="string">"John"</span>, Age: <span class="number">0</span>&#125;,　<span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"John" 2:0]</span></span><br><span class="line"> &amp;User&#123;Name: <span class="string">"John"</span>&#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"John" 2:0]</span></span><br><span class="line"> &amp;User&#123;Name: <span class="string">""</span>, Age: <span class="number">8</span>&#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"" 2:8]</span></span><br><span class="line"> &amp;User&#123;Age: <span class="number">30</span>&#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"" 2:30]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>在使用golang中零值与空值和NULL是不同的数据类型和值，需要加以判断，在数据库表中的NULL值字段可以用<code>database/sql</code>数据包中提供的<code>sql.NullString</code>，<code>sql.NullBool</code>等值类型进行判断后加以使用.</p>
<h2 id="u5982_u4F55_u4F7F_u7528"><a href="#u5982_u4F55_u4F7F_u7528" class="headerlink" title="如何使用"></a>如何使用</h2><p>可能存在NULL值的数据类型可以使用<code>sql.NullString</code>或<code>sql.NullBool</code>等来指定其类型.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Id <span class="typename">int</span> <span class="string">`db:id`</span></span><br><span class="line">    Name sql.NullString <span class="string">`db:name`</span></span><br><span class="line">    Age sql.NullInt64 <span class="string">`db:age`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>sql.NullString</code>，它的结构如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NullString <span class="keyword">struct</span> &#123;</span><br><span class="line">    String <span class="typename">string</span> </span><br><span class="line">    Valid  <span class="typename">bool</span> <span class="comment">// Valid is true if String is not NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>借助<code>.sql.NullString</code>这样的结构体就可以在<code>insert</code>时，通过设置<code>Valid</code>的值为<code>fasle</code>就可以表示此值为<code>null</code>值，这样在读取时如果为<code>false</code>就可以肯定此值为默认的空值了，具体操作如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbmap.Insert(</span><br><span class="line">    &amp;User&#123;</span><br><span class="line">      Name: sql.NullString&#123;<span class="string">"Mike"</span>, <span class="constant">true</span>&#125;,</span><br><span class="line">      Age: sql.NullInt64&#123;<span class="number">0</span>, <span class="constant">true</span>&#125;,</span><br><span class="line">    &#125;, <span class="comment">//  insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:"Mike" 2:0]</span></span><br><span class="line">    &amp;User&#123;</span><br><span class="line">      Name: sql.NullString&#123;<span class="string">""</span>, <span class="constant">false</span>&#125;,</span><br><span class="line">      Age: sql.NullInt64&#123;<span class="number">30</span>, <span class="constant">true</span>&#125;,</span><br><span class="line">    &#125;, <span class="comment">// insert into "users" ("id","name","age") values (default,$1,$2) returning Id; [1:&lt;nil&gt; 2:30]</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p>
<p>读取数据时，可以根据<code>valid</code>的值判断是否为设置的零值还是未被赋值操作.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">dbmap.Insert(</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">"Mike"</span>, <span class="constant">true</span>&#125;, Age: sql.NullInt64&#123;<span class="number">0</span>, <span class="constant">true</span>&#125;&#125;,</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">"John"</span>, <span class="constant">true</span>&#125;, Age: sql.NullInt64&#123;<span class="number">0</span>, <span class="constant">false</span>&#125;&#125;,</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">"John"</span>, <span class="constant">true</span>&#125;, Age: sql.NullInt64&#123;<span class="number">8</span>, <span class="constant">true</span>&#125;&#125;,</span><br><span class="line">    &amp;User&#123;Name: sql.NullString&#123;<span class="string">""</span>, <span class="constant">false</span>&#125;, Age: sql.NullInt64&#123;<span class="number">30</span>, <span class="constant">true</span>&#125;&#125;,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  users := []User&#123;&#125;</span><br><span class="line">  _, err := dbmap.Select(&amp;users, <span class="string">"select * from users"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">    spew.Dump(user)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 1,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) (len=4) "Mike",</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 0,</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 2,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) (len=4) "John",</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 0,</span><br><span class="line">  Valid: (bool) false</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 3,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) (len=4) "John",</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 8,</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">(main.User) &#123;</span><br><span class="line"> Id: (int) 4,</span><br><span class="line"> Name: (sql.NullString) &#123;</span><br><span class="line">  String: (string) "",</span><br><span class="line">  Valid: (bool) false</span><br><span class="line"> &#125;,</span><br><span class="line"> Age: (sql.NullInt64) &#123;</span><br><span class="line">  Int64: (int64) 30,</span><br><span class="line">  Valid: (bool) true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>在单次查询中根据<code>valid</code>的值作相应的零值判断处理, 方法如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s NullString</span><br><span class="line">err := db.QueryRow(<span class="string">"SELECT name FROM foo WHERE id=?"</span>, id).Scan(&amp;s)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> s.Valid &#123;</span><br><span class="line">   <span class="comment">// use s.String</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// NULL value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang是强类型语言，在赋值和解析过程中需要先定义好数据类型，否在会报类型错误，下面总结在处理数据库表时遇到字段为空或零值的情况&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>安装golang工具包软件</title>
    <link href="http://www.grdtechs.com/2016/11/19/go-install-binaries/"/>
    <id>http://www.grdtechs.com/2016/11/19/go-install-binaries/</id>
    <published>2016-11-19T00:18:37.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang tool chains 提供了很多好用的工具， 但是如果直接安装的话，大多数需要翻墙才能安装， 而且比较麻烦； 本文记录一种不需要翻墙就能顺利安装相应的工具的方法.</p>
<a id="more"></a>
<h2 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h2><p>不需要翻墙安装相应的golang tool chains，具体步骤如下:</p>
<ol>
<li><p>假设<code>GOPATH=/path/to/proj_go/</code>,在<code>/path/to/proj_go/src/</code>目录下新建<code>golang.org/x/</code>目录，进入<code>/path/to/proj_go/src/golang.org/x/</code>目录下载<code>tools</code>目录，下载命令如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/golang/tools.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>go install</code>命令直接安装相应的tools, 比如安装<code>guru</code>工具，<br>$cd <code>/path/to/proj_go/bin</code>目录， 然后安装<code>go install ../src/golang.org/x/tools/cmd/guru</code> 直接安装即可， </p>
</li>
<li><p>同样的方法也可以安装<code>tools</code>下任何工具.</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang tool chains 提供了很多好用的工具， 但是如果直接安装的话，大多数需要翻墙才能安装， 而且比较麻烦； 本文记录一种不需要翻墙就能顺利安装相应的工具的方法.&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang操作mysql使用总结</title>
    <link href="http://www.grdtechs.com/2016/11/11/go-use-mysql/"/>
    <id>http://www.grdtechs.com/2016/11/11/go-use-mysql/</id>
    <published>2016-11-11T13:21:16.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>Golang 提供了<code>database/sql</code>包用于对<code>SQL数据库</code>的访问, 作为操作数据库的入口对象<code>sql.DB</code>, 主要为我们提供了两个重要的功能:<br><a id="more"></a></p>
<ul>
<li>sql.DB 通过数据库驱动为我们提供管理底层数据库连接的打开和关闭操作.</li>
<li>sql.DB 为我们管理数据库连接池</li>
</ul>
<p>需要注意的是，sql.DB表示操作数据库的抽象访问接口,而非一个数据库连接对象;它可以根据driver打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果你没有把连接释放回连接池，会导致过多连接使系统资源耗尽。</p>
<h2 id="u64CD_u4F5Cmysql"><a href="#u64CD_u4F5Cmysql" class="headerlink" title="操作mysql"></a>操作mysql</h2><p><strong>1.导入mysql数据库驱动</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通常来说, 不应该直接使用驱动所提供的方法, 而是应该使用 sql.DB, 因此在导入 mysql 驱动时, 这里使用了匿名导入的方式(在包路径前添加 _), 当导入了一个数据库驱动后, 此驱动会自行初始化并注册自己到Golang的database/sql上下文中, 因此我们就可以通过 database/sql 包提供的方法访问数据库了.</p>
</blockquote>
<p><strong>2.连接数据库</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> DbWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//mysql data source name</span></span><br><span class="line">    Dsn <span class="typename">string</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    dbw := DbWorker&#123;</span><br><span class="line">        Dsn: <span class="string">"user:password@tcp(127.0.0.1:3306)/test"</span>,</span><br><span class="line">    &#125;	</span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>,</span><br><span class="line">        dbw.Dsn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过调用sql.Open函数返回一个<code>sql.DB指针</code>; sql.Open函数原型如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> Open(driverName, dataSourceName <span class="typename">string</span>) (*DB, error)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>driverName</code>: 使用的驱动名. 这个名字其实就是数据库驱动注册到 database/sql 时所使用的名字.</li>
<li><code>dataSourceName</code>:  数据库连接信息，这个连接包含了数据库的用户名, 密码, 数据库主机以及需要连接的数据库名等信息.</li>
</ul>
<blockquote>
<ol>
<li>sql.Open并不会立即建立一个数据库的网络连接, 也不会对数据库链接参数的合法性做检验, 它仅仅是初始化一个sql.DB对象. 当真正进行第一次数据库查询操作时, 此时才会真正建立网络连接; </li>
<li>sql.DB表示操作数据库的抽象接口的对象，但不是所谓的数据库连接对象，sql.DB对象只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法; </li>
<li>sql.Open返回的sql.DB对象是协程并发安全的.</li>
<li>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</li>
</ol>
</blockquote>
<p><strong>3.数据库基本操作</strong></p>
<p>数据库查询的一般步骤如下:</p>
<ol>
<li>调用 db.Query 执行 SQL 语句, 此方法会返回一个 Rows 作为查询的结果</li>
<li>通过 rows.Next() 迭代查询数据.</li>
<li>通过 rows.Scan() 读取每一行的值</li>
<li>调用 db.Close() 关闭查询</li>
</ol>
<p>现有<code>user</code>数据库表如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<font color="red">MySQL 5.5 之前， UTF8 编码只支持1-3个字节,从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，utf8mb4兼容utf8，所以能支持更多的字符集;关于emoji表情的话mysql的utf8是不支持，需要修改设置为utf8mb4，才能支持。</font>

</blockquote>
</blockquote>
<p>查询数据<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (dbw *DbWorker) QueryData() &#123;</span><br><span class="line">	dbw.QueryDataPre()</span><br><span class="line">	rows, err := dbw.Db.Query(<span class="string">`SELECT * From user where age &gt;= 20 AND age &lt; 30`</span>)</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			fmt.Printf(err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Name.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Name.String = <span class="string">""</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Age.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Age.Int64 = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"get data, id: "</span>, dbw.UserInfo.Id, <span class="string">" name: "</span>, dbw.UserInfo.Name.String, <span class="string">" age: "</span>, <span class="typename">int</span>(dbw.UserInfo.Age.Int64))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rows.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>rows.Scan 参数的顺序很重要, 需要和查询的结果的column对应. 例如 “SELECT * From user where age &gt;=20 AND age &lt; 30” 查询的行的 column 顺序是 “id, name, age” 和插入操作顺序相同, 因此 rows.Scan 也需要按照此顺序 rows.Scan(&amp;id, &amp;name, &amp;age), 不然会造成数据读取的错位.</li>
<li>因为golang是强类型语言，所以查询数据时先定义数据类型，但是查询数据库中的数据存在三种可能:存在值，存在零值，未赋值NULL 三种状态, 因为可以将待查询的数据类型定义为sql.Nullxxx类型，可以通过判断Valid值来判断查询到的值是否为赋值状态还是未赋值NULL状态.</li>
<li>每次db.Query操作后, 都建议调用rows.Close(). 因为 db.Query() 会从数据库连接池中获取一个连接, 这个底层连接在结果集(rows)未关闭前会被标记为处于繁忙状态。当遍历读到最后一条记录时，会发生一个内部EOF错误，自动调用rows.Close(),但如果提前退出循环，rows不会关闭，连接不会回到连接池中，连接也不会关闭, 则此连接会一直被占用. 因此通常我们使用 defer rows.Close() 来确保数据库连接可以正确放回到连接池中; 不过阅读源码发现rows.Close()操作是幂等操作，即一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同, 所以即便对已关闭的rows再执行close()也没关系.</li>
</ol>
</blockquote>
<p>单行查询<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="typename">string</span></span><br><span class="line">err = db.QueryRow(<span class="string">"select name from user where id = ?"</span>, <span class="number">1</span>).Scan(&amp;name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(name)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>err在Scan后才产生，上述链式写法是对的</li>
<li>需要注意Scan()中变量和顺序要和前面Query语句中的顺序一致，否则查出的数据会映射不一致.</li>
</ol>
</blockquote>
<p>插入数据<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (dbw *DbWorker) insertData() &#123;</span><br><span class="line">	ret, err := dbw.Db.Exec(<span class="string">`INSERT INTO user (name, age) VALUES ("xys", 23)`</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> LastInsertId, err := ret.LastInsertId(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"LastInsertId:"</span>, LastInsertId)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> RowsAffected, err := ret.RowsAffected(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"RowsAffected:"</span>, RowsAffected)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>db.Exec()</code>插入数据，通过返回的<code>err</code>可知插入失败的原因，通过返回的<code>ret</code>可以进一步查询本次插入数据影响的行数<code>RowsAffected</code>和最后插入的Id(如果数据库支持查询最后插入Id).</p>
<p><a href="https://github.com/researchlab/golearning/blob/master/sql/sql.go" target="_blank" rel="external">github完整代码示例</a></p>
<p><strong>4.预编译语句(Prepared Statement)</strong><br>预编译语句(PreparedStatement)提供了诸多好处, 因此我们在开发中尽量使用它. 下面列出了使用预编译语句所提供的功能:</p>
<ul>
<li>PreparedStatement 可以实现自定义参数的查询</li>
<li>PreparedStatement 通常来说, 比手动拼接字符串 SQL 语句高效.</li>
<li>PreparedStatement 可以防止SQL注入攻击</li>
</ul>
<p>一般用<code>Prepared Statements</code>和<code>Exec()</code>完成<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>操作。</p>
<p>下面是将上述案例用Prepared Statement 修改之后的完整代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"database/sql"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DbWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">	Dsn      <span class="typename">string</span></span><br><span class="line">	Db       *sql.DB</span><br><span class="line">	UserInfo userTB</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> userTB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="typename">int</span></span><br><span class="line">	Name sql.NullString</span><br><span class="line">	Age  sql.NullInt64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	dbw := DbWorker&#123;</span><br><span class="line">		Dsn: <span class="string">"root:123456@tcp(localhost:3306)/sqlx_db?charset=utf8mb4"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	dbw.Db, err = sql.Open(<span class="string">"mysql"</span>, dbw.Dsn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dbw.Db.Close()</span><br><span class="line"></span><br><span class="line">	dbw.insertData()</span><br><span class="line">	dbw.queryData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (dbw *DbWorker) insertData() &#123;</span><br><span class="line">	stmt, _ := dbw.Db.Prepare(<span class="string">`INSERT INTO user (name, age) VALUES (?, ?)`</span>)</span><br><span class="line">	<span class="keyword">defer</span> stmt.Close()</span><br><span class="line"></span><br><span class="line">	ret, err := stmt.Exec(<span class="string">"xys"</span>, <span class="number">23</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> LastInsertId, err := ret.LastInsertId(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"LastInsertId:"</span>, LastInsertId)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> RowsAffected, err := ret.RowsAffected(); <span class="constant">nil</span> == err &#123;</span><br><span class="line">		fmt.Println(<span class="string">"RowsAffected:"</span>, RowsAffected)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (dbw *DbWorker) QueryDataPre() &#123;</span><br><span class="line">	dbw.UserInfo = userTB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (dbw *DbWorker) queryData() &#123;</span><br><span class="line">	stmt, _ := dbw.Db.Prepare(<span class="string">`SELECT * From user where age &gt;= ? AND age &lt; ?`</span>)</span><br><span class="line">	<span class="keyword">defer</span> stmt.Close()</span><br><span class="line"></span><br><span class="line">	dbw.QueryDataPre()</span><br><span class="line"></span><br><span class="line">	rows, err := stmt.Query(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"insert data error: %v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			fmt.Printf(err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Name.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Name.String = <span class="string">""</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dbw.UserInfo.Age.Valid &#123;</span><br><span class="line">			dbw.UserInfo.Age.Int64 = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"get data, id: "</span>, dbw.UserInfo.Id, <span class="string">" name: "</span>, dbw.UserInfo.Name.String, <span class="string">" age: "</span>, <span class="typename">int</span>(dbw.UserInfo.Age.Int64))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rows.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		fmt.Printf(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<font color="red">db.Prepare()返回的statement使用完之后需要手动关闭，即defer stmt.Close()</font>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Golang 提供了&lt;code&gt;database/sql&lt;/code&gt;包用于对&lt;code&gt;SQL数据库&lt;/code&gt;的访问, 作为操作数据库的入口对象&lt;code&gt;sql.DB&lt;/code&gt;, 主要为我们提供了两个重要的功能:&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="mysql" scheme="http://www.grdtechs.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go编译生成更小的执行程序</title>
    <link href="http://www.grdtechs.com/2016/10/23/go-build-small-exec/"/>
    <id>http://www.grdtechs.com/2016/10/23/go-build-small-exec/</id>
    <published>2016-10-23T14:00:32.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>尽管go1.7.3编译生成的可执行程序已经很小了,但是通过编译参数控制还能编译出更小的可执行文件，总结如下,<br><a id="more"></a></p>
<h2 id="u52A0-ldflags_u53C2_u6570"><a href="#u52A0-ldflags_u53C2_u6570" class="headerlink" title="加-ldflags参数"></a>加-ldflags参数</h2><p>在程序编译的时候可以加上<code>-ldflags &quot;-s -w&quot;</code> 参数来优化编译程序, 其实通过去除部分连接和调试等信息来使得编译之后的执行程序更小,具体参数如下:</p>
<ul>
<li><code>-a</code> 强制编译所有依赖包</li>
<li><code>-s</code> 去掉符号表信息, panic时候的stack trace就没有任何文件名/行号信息了.</li>
<li><code>-w</code> 去掉DWARF调试信息，得到的程序就不能用gdb调试了</li>
</ul>
<p>如执行如下命令可得到优化编译过的<code>test</code>可执行程序:4.8M</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -ldflags -w test.go</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不建议s和w同时使用。</p>
</blockquote>
<h2 id="u4F7F_u7528upx"><a href="#u4F7F_u7528upx" class="headerlink" title="使用upx"></a>使用upx</h2><p>上面golang build 时加上<code>-ldflags</code>参数得到了比较小的可执行程序， 但是还可以通过<code>upx</code>这个开源，绿色，好用的压缩工具进行进一步压缩，首先其下载地址:<a href="http://upx.sourceforge.net/#downloadupx" target="_blank" rel="external">http://upx.sourceforge.net/#downloadupx</a></p>
<p>linux 系统选择下载:<code>upx-3.91-amd64_linux.tar.bz2</code> 即可, 然后 <code>tar -xvf upx-3.91-amd64_linux.tar.bz2</code> 进入到解压文件夹中将可执行文件<code>upx</code> 拷贝到<code>/usr/bin</code>就可以全局执行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv upx /usr/bin</span><br><span class="line">➜  <span class="built_in">test</span> git:(master) ✗ upx -<span class="number">9</span> -k <span class="built_in">test</span> </span><br><span class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</span><br><span class="line">                          Copyright (C) <span class="number">1996</span> - <span class="number">2013</span></span><br><span class="line">UPX <span class="number">3.91</span>        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep <span class="number">30</span>th <span class="number">2013</span></span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">   <span class="number">5024059</span> -&gt;   <span class="number">1552060</span>   <span class="number">30.89</span>%  linux/ElfAMD   <span class="built_in">test</span> </span><br><span class="line"></span><br><span class="line">Packed <span class="number">1</span> file.</span><br></pre></td></tr></table></figure></p>
<p>可以看到通过<code>upx</code>进一步压缩之后得到的程序大约只有1.5M了， 压缩比率达到了<code>30.89%</code>.<br>其中<code>-k</code>参数表示保留备份文件， <code>-9</code>代表最优压缩，<code>upx</code>总共有9档压缩,从<code>1</code>到<code>9</code> 其中 <code>-1</code>压缩速度最快.</p>
<p>再来看看下面编译之后的效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build test.go ---&gt; 得到的 <span class="built_in">test</span>  大约<span class="number">6.5</span>MB </span><br><span class="line">$ go build -ldflags -w ---&gt; 得到的 <span class="built_in">test</span> 大约<span class="number">4.8</span>MB</span><br><span class="line">$ upx -<span class="number">9</span> <span class="built_in">test</span>  ---&gt; 得到的 <span class="built_in">test</span> 大约 <span class="number">1.5</span>MB</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;尽管go1.7.3编译生成的可执行程序已经很小了,但是通过编译参数控制还能编译出更小的可执行文件，总结如下,&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mac vim7.3 升级到vim8.0</title>
    <link href="http://www.grdtechs.com/2016/10/16/mac-update-vim8-0/"/>
    <id>http://www.grdtechs.com/2016/10/16/mac-update-vim8-0/</id>
    <published>2016-10-16T23:08:56.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>将mac自带的vim7.3 升级到vim8.0<br><a id="more"></a></p>
<h2 id="u5347_u7EA7vim8-0"><a href="#u5347_u7EA7vim8-0" class="headerlink" title="升级vim8.0"></a>升级vim8.0</h2><ul>
<li><p>升级终端用得vim </p>
<blockquote>
<p>brew install vim –with-lua –with-override-system-vi</p>
</blockquote>
</li>
<li><p>升级GUI版本的vim</p>
<blockquote>
<p>brew install macvim –with-lua –with-override-system-vim</p>
</blockquote>
</li>
</ul>
<h2 id="brew_install__u4E0B_u8F7D_u6162"><a href="#brew_install__u4E0B_u8F7D_u6162" class="headerlink" title="brew install 下载慢"></a>brew install 下载慢</h2><p>用<code>brew install</code>发现下载vim8.0很慢， 解决方案是先去浏览器或用<code>wget</code>等其它方式下载好要安装的包，然后替换掉<code>brew cache</code>下的包即可。具体操作：</p>
<ul>
<li>找<code>brew cache</code> 目录<blockquote>
<p>brew cache<br>/Users/lihong/Library/Cache/Homebrew</p>
</blockquote>
</li>
</ul>
<p>可以看到上述目录中已经有一个<code>vim-8.00041.tar.gz.incomplete</code> 文件了， 将自己下载好的安装包也修改为和这个未完成文件的文件名一样，如修改为<code>vim-8.00041.tar.gz</code>. 然后,</p>
<blockquote>
<p>brew install vim –with-lua –with-override-system-vi</p>
</blockquote>
<ul>
<li><p>mac vim8.0 具体安装信息如下: </p>
<ul>
<li><p>install </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➜  ~ brew install vim --with-lua --with-override-system-vi</span><br><span class="line">==&gt; Using the sandbox</span><br><span class="line">==&gt; Downloading https://github.com/vim/vim/archive/v8.<span class="number">0.0041</span>.tar.gz</span><br><span class="line">==&gt; Downloading from https://codeload.github.com/vim/vim/tar.gz/v8.<span class="number">0.0041</span></span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; ./configure --prefix=/usr/<span class="built_in">local</span> --mandir=/usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span>/share/man --enable-multibyte --with-tlib=ncurses --enable-cscope --with-compiledby=Homebrew --enable-luainterp --enable-perlinterp --enable-pythoninterp --enable-</span><br><span class="line">==&gt; make</span><br><span class="line">==&gt; make install prefix=/usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span> STRIP=/usr/bin/<span class="literal">true</span></span><br><span class="line">🍺  /usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span>: <span class="number">1</span>,<span class="number">706</span> files, <span class="number">23.3</span>M, built <span class="keyword">in</span> <span class="number">5</span> minutes <span class="number">16</span> seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>:version</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:version</span><br><span class="line">VIM - Vi IMproved <span class="number">8.0</span> (<span class="number">2016</span> Sep <span class="number">12</span>, compiled Oct <span class="number">16</span> <span class="number">2016</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">47</span>)</span><br><span class="line">MacOS X (unix) version</span><br><span class="line">Included patches: <span class="number">1</span>-<span class="number">41</span></span><br><span class="line">Compiled by Homebrew</span><br><span class="line">Huge version without GUI.  Features included (+) or not (-):</span><br><span class="line">+acl             -clientserver    +cursorbind      +ex_extra        -gettext         +libcall         +mouse           +mouse_xterm     +persistent_undo +ruby            +tag_old_static  -toolbar         +wildmenu        -xterm_save</span><br><span class="line">+arabic          +clipboard       +cursorshape     +extra_search    -hangul_input    +linebreak       -mouseshape      +multi_byte      +postscript      +scrollbind      -tag_any_white   +user_commands   +windows</span><br><span class="line">+autocmd         +cmdline_compl   +dialog_con      +farsi           +iconv           +lispindent      +mouse_dec       +multi_lang      +printer         +signs           -tcl             +vertsplit       +writebackup</span><br><span class="line">-balloon_<span class="built_in">eval</span>    +cmdline_hist    +diff            +file_<span class="keyword">in</span>_path    +insert_expand   +listcmds        -mouse_gpm       -mzscheme        +profile         +smartindent     +termguicolors   +virtualedit     -X11</span><br><span class="line">-browse          +cmdline_info    +digraphs        +find_<span class="keyword">in</span>_path    +job             +localmap        -mouse_jsbterm   +netbeans_intg   +python          +startuptime     +terminfo        +visual          -xfontset</span><br><span class="line">++<span class="built_in">builtin</span>_terms  +comments        -dnd             +<span class="built_in">float</span>           +jumplist        +lua             +mouse_netterm   +num64           -python3         +statusline      +termresponse    +visualextra     -xim</span><br><span class="line">+byte_offset     +conceal         -ebcdic          +folding         +keymap          +menu            +mouse_sgr       +packages        +quickfix        -sun_workshop    +textobjects     +viminfo         -xpm</span><br><span class="line">+channel         +cryptv          +emacs_tags      -footer          +lambda          +mksession       -mouse_sysmouse  +path_extra      +reltime         +syntax          +timers          +vreplace        -xsmp</span><br><span class="line">+cindent         +cscope          +<span class="built_in">eval</span>            +fork()          +langmap         +modify_fname    +mouse_urxvt     +perl            +rightleft       +tag_binary      +title           +wildignore      -xterm_clipboard</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;将mac自带的vim7.3 升级到vim8.0&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://www.grdtechs.com/categories/DevOps/"/>
    
    
      <category term="vim8.0" scheme="http://www.grdtechs.com/tags/vim8-0/"/>
    
  </entry>
  
  <entry>
    <title>优雅的关闭ticker</title>
    <link href="http://www.grdtechs.com/2016/10/16/close-ticker-correctly/"/>
    <id>http://www.grdtechs.com/2016/10/16/close-ticker-correctly/</id>
    <published>2016-10-16T14:27:39.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在<code>ticker</code>和<code>goroutine</code>组合使用中当调用<code>ticker.Stop()</code>关闭<code>ticker</code>之后，相应的<code>goroutine</code>中的<code>ticker.C</code>并没有停掉，下面总结一种优雅的方式关闭<code>ticker</code>.<br><a id="more"></a></p>
<h2 id="u4F18_u96C5_u7684_u5173_u95EDticker"><a href="#u4F18_u96C5_u7684_u5173_u95EDticker" class="headerlink" title="优雅的关闭ticker"></a>优雅的关闭<code>ticker</code></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	Demo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Demo() &#123;</span><br><span class="line">	done := startTicker(PrintInfo)</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">12</span>) * time.Second)</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">1</span>) * time.Minute)</span><br><span class="line">	fmt.Println(<span class="string">"main finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> startTicker(f <span class="keyword">func</span>()) <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">		<span class="comment">//	ticker := time.NewTicker(5 * time.Minute)</span></span><br><span class="line">		<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				f()</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> PrintInfo() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过<code>startTicker</code>创建一个<code>ticker</code>, 当想要关闭这个<code>ticker</code>并同时退出对应<code>goroutine</code>中的<code>for</code>时，可以直接<code>close()</code>，发送<code>done</code>信号直接返回退出<code>startTicker</code>即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;ticker&lt;/code&gt;和&lt;code&gt;goroutine&lt;/code&gt;组合使用中当调用&lt;code&gt;ticker.Stop()&lt;/code&gt;关闭&lt;code&gt;ticker&lt;/code&gt;之后，相应的&lt;code&gt;goroutine&lt;/code&gt;中的&lt;code&gt;ticker.C&lt;/code&gt;并没有停掉，下面总结一种优雅的方式关闭&lt;code&gt;ticker&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="ticker" scheme="http://www.grdtechs.com/tags/ticker/"/>
    
  </entry>
  
  <entry>
    <title>Golang发送post表单请求</title>
    <link href="http://www.grdtechs.com/2016/09/07/go-postform/"/>
    <id>http://www.grdtechs.com/2016/09/07/go-postform/</id>
    <published>2016-09-07T16:00:32.000Z</published>
    <updated>2017-03-03T03:59:22.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang这边将<code>map</code>结构序列化通常采用<code>json.Marshal</code>和<code>json.Unmarshal</code>来做，但是在php server端还需要做<code>json</code>反序列化解析才能用， 用golang模拟表单提交, php server端则非常方便提取相应的数据字段.<br><a id="more"></a></p>
<h2 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h2><p>方法是利用golang<code>net/http</code>包提供的<code>PostForm</code>提交post表单提交。<code>ParseForm</code>解析<code>URL</code>中的查询字符串，并将解析结果更新到<code>r.Form</code>字段。对于<code>POST</code>或<code>PUT</code>请求，<code>ParseForm</code>还会将<code>body</code>当作表单解析，并将结果既更新到<code>r.PostForm</code>也更新到<code>r.Form</code>。解析结果中，<code>POST</code>或<code>PUT</code>请求主体要优先于<code>URL</code>查询字符串（同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被<code>MaxBytesReader</code>函数设定限制，其大小默认限制为开头10MB。</p>
<h2 id="http-Client_7B_7D-PostForm"><a href="#http-Client_7B_7D-PostForm" class="headerlink" title="http.Client{}.PostForm"></a>http.Client{}.PostForm</h2><p>利用<code>http.Client{}.PostForm</code>提交post表单。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">res, err := client.PostForm(<span class="string">"http://127.0.0.1:8091/postpage"</span>, url.Values&#123;</span><br><span class="line">	<span class="string">"key"</span>:   &#123;<span class="string">"this is client key"</span>&#125;,</span><br><span class="line">	<span class="string">"value"</span>: &#123;<span class="string">"this is client value"</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="http-PostForm"><a href="#http-PostForm" class="headerlink" title="http.PostForm"></a>http.PostForm</h2><p>直接用<code>http.PostForm</code>提交post表单。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"><span class="comment">//data := make(url.Values)</span></span><br><span class="line"><span class="comment">//data["key"] = []string&#123;"this is key"&#125;</span></span><br><span class="line"><span class="comment">//data["value"] = []string&#123;"this is value"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把post表单发送给目标服务器</span></span><br><span class="line">res, err := http.PostForm(<span class="string">"http://127.0.0.1:8091/postpage"</span>, url.Values&#123;</span><br><span class="line">	<span class="string">"key"</span>:   &#123;<span class="string">"this is url key"</span>&#125;,</span><br><span class="line">	<span class="string">"value"</span>: &#123;<span class="string">"this is url value"</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="u5BF9_u8868_u5355_u6570_u636E_u7684_u63D0_u53D6"><a href="#u5BF9_u8868_u5355_u6570_u636E_u7684_u63D0_u53D6" class="headerlink" title="对表单数据的提取"></a>对表单数据的提取</h2><p>server端对表单数据的提取<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受post请求， 然后打印表单中key和value字段的值</span></span><br><span class="line"><span class="keyword">if</span> r.Method == <span class="string">"POST"</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		key   <span class="typename">string</span> = r.PostFormValue(<span class="string">"key"</span>)</span><br><span class="line">		value <span class="typename">string</span> = r.PostFormValue(<span class="string">"value"</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/researchlab/golearning/tree/master/postform" target="_blank" rel="external">github示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang这边将&lt;code&gt;map&lt;/code&gt;结构序列化通常采用&lt;code&gt;json.Marshal&lt;/code&gt;和&lt;code&gt;json.Unmarshal&lt;/code&gt;来做，但是在php server端还需要做&lt;code&gt;json&lt;/code&gt;反序列化解析才能用， 用golang模拟表单提交, php server端则非常方便提取相应的数据字段.&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="form" scheme="http://www.grdtechs.com/tags/form/"/>
    
      <category term="post" scheme="http://www.grdtechs.com/tags/post/"/>
    
  </entry>
  
  <entry>
    <title>php7 安装redis扩展</title>
    <link href="http://www.grdtechs.com/2016/08/02/php7-redis-install/"/>
    <id>http://www.grdtechs.com/2016/08/02/php7-redis-install/</id>
    <published>2016-08-02T18:56:05.000Z</published>
    <updated>2017-03-03T03:59:22.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在<code>Ubuntu16.04</code>上， 安装<code>php7</code>的<code>redis</code>扩展, 记录安装过程。<br><a id="more"></a></p>
<h3 id="u5B89_u88C5phpredis"><a href="#u5B89_u88C5phpredis" class="headerlink" title="安装phpredis"></a>安装phpredis</h3><p><code>Redis</code>已经有了<code>PHP7</code>版本，可以从<code>github</code> 上获取项目克隆，然后手动切换到 <code>php7</code> 分支即可安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/phpredis/phpredis.git </span><br><span class="line">$ <span class="built_in">cd</span> phpredis/ </span><br><span class="line">$ git checkout php7 </span><br><span class="line">$ phpize </span><br><span class="line">$ ./configure </span><br><span class="line">$ make </span><br><span class="line">$ makeinstall</span><br></pre></td></tr></table></figure>
<p>如果没有安装php7.0-dev, 则没有安装 <code>phpize</code> , 可以直接<code>sudo apt install php7.0-dev</code> 安装即可。 </p>
<h2 id="u542F_u52A8_redis__u6269_u5C55"><a href="#u542F_u52A8_redis__u6269_u5C55" class="headerlink" title="启动 redis 扩展"></a>启动 redis 扩展</h2><p>光安装了还不够，我们还需要编辑PHP的配置文件来使扩展被加载才行， 打开配置文件<code>vim /etc/php/7.0/fpm/php .ini</code>, 在配置文件中添加如下语句：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=redis.so</span><br></pre></td></tr></table></figure></p>
<p>然后重启php服务,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/php7.<span class="number">0</span>-fpm restart</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;Ubuntu16.04&lt;/code&gt;上， 安装&lt;code&gt;php7&lt;/code&gt;的&lt;code&gt;redis&lt;/code&gt;扩展, 记录安装过程。&lt;br&gt;
    
    </summary>
    
      <category term="php" scheme="http://www.grdtechs.com/categories/php/"/>
    
    
      <category term="php_redis" scheme="http://www.grdtechs.com/tags/php-redis/"/>
    
      <category term="phpize" scheme="http://www.grdtechs.com/tags/phpize/"/>
    
  </entry>
  
</feed>
