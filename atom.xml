<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朴实的一线攻城狮</title>
  <subtitle>十年磨一剑，一步一步脚踏实地的耕种</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.grdtechs.com/"/>
  <updated>2016-11-23T06:28:51.134Z</updated>
  <id>http://www.grdtechs.com/</id>
  
  <author>
    <name>Lee Hong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go编译生成更小的执行程序</title>
    <link href="http://www.grdtechs.com/2016/10/23/go-build-small-exec/"/>
    <id>http://www.grdtechs.com/2016/10/23/go-build-small-exec/</id>
    <published>2016-10-23T14:00:32.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>尽管go1.7.3编译生成的可执行程序已经很小了,但是通过编译参数控制还能编译出更小的可执行文件，总结如下,<br><a id="more"></a></p>
<h2 id="u52A0-ldflags_u53C2_u6570"><a href="#u52A0-ldflags_u53C2_u6570" class="headerlink" title="加-ldflags参数"></a>加-ldflags参数</h2><p>在程序编译的时候可以加上<code>-ldflags &quot;-s -w&quot;</code> 参数来优化编译程序, 其实通过去除部分连接和调试等信息来使得编译之后的执行程序更小,具体参数如下:</p>
<ul>
<li><code>-a</code> 强制编译所有依赖包</li>
<li><code>-s</code> 去掉符号表信息, panic时候的stack trace就没有任何文件名/行号信息了.</li>
<li><code>-w</code> 去掉DWARF调试信息，得到的程序就不能用gdb调试了</li>
</ul>
<p>如执行如下命令可得到优化编译过的<code>test</code>可执行程序:4.8M</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -ldflags -w test.go</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不建议s和w同时使用。</p>
</blockquote>
<h2 id="u4F7F_u7528upx"><a href="#u4F7F_u7528upx" class="headerlink" title="使用upx"></a>使用upx</h2><p>上面golang build 时加上<code>-ldflags</code>参数得到了比较小的可执行程序， 但是还可以通过<code>upx</code>这个开源，绿色，好用的压缩工具进行进一步压缩，首先其下载地址:<a href="http://upx.sourceforge.net/#downloadupx" target="_blank" rel="external">http://upx.sourceforge.net/#downloadupx</a></p>
<p>linux 系统选择下载:<code>upx-3.91-amd64_linux.tar.bz2</code> 即可, 然后 <code>tar -xvf upx-3.91-amd64_linux.tar.bz2</code> 进入到解压文件夹中将可执行文件<code>upx</code> 拷贝到<code>/usr/bin</code>就可以全局执行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv upx /usr/bin</span><br><span class="line">➜  <span class="built_in">test</span> git:(master) ✗ upx -<span class="number">9</span> -k <span class="built_in">test</span> </span><br><span class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</span><br><span class="line">                          Copyright (C) <span class="number">1996</span> - <span class="number">2013</span></span><br><span class="line">UPX <span class="number">3.91</span>        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep <span class="number">30</span>th <span class="number">2013</span></span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">   <span class="number">5024059</span> -&gt;   <span class="number">1552060</span>   <span class="number">30.89</span>%  linux/ElfAMD   <span class="built_in">test</span> </span><br><span class="line"></span><br><span class="line">Packed <span class="number">1</span> file.</span><br></pre></td></tr></table></figure></p>
<p>可以看到通过<code>upx</code>进一步压缩之后得到的程序大约只有1.5M了， 压缩比率达到了<code>30.89%</code>.<br>其中<code>-k</code>参数表示保留备份文件， <code>-9</code>代表最优压缩，<code>upx</code>总共有9档压缩,从<code>1</code>到<code>9</code> 其中 <code>-1</code>压缩速度最快.</p>
<p>再来看看下面编译之后的效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build test.go ---&gt; 得到的 <span class="built_in">test</span>  大约<span class="number">6.5</span>MB </span><br><span class="line">$ go build -ldflags -w ---&gt; 得到的 <span class="built_in">test</span> 大约<span class="number">4.8</span>MB</span><br><span class="line">$ upx -<span class="number">9</span> <span class="built_in">test</span>  ---&gt; 得到的 <span class="built_in">test</span> 大约 <span class="number">1.5</span>MB</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;尽管go1.7.3编译生成的可执行程序已经很小了,但是通过编译参数控制还能编译出更小的可执行文件，总结如下,&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mac vim7.3 升级到vim8.0</title>
    <link href="http://www.grdtechs.com/2016/10/16/mac-update-vim8-0/"/>
    <id>http://www.grdtechs.com/2016/10/16/mac-update-vim8-0/</id>
    <published>2016-10-16T23:08:56.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>将mac自带的vim7.3 升级到vim8.0<br><a id="more"></a></p>
<h2 id="u5347_u7EA7vim8-0"><a href="#u5347_u7EA7vim8-0" class="headerlink" title="升级vim8.0"></a>升级vim8.0</h2><ul>
<li><p>升级终端用得vim </p>
<blockquote>
<p>brew install vim –with-lua –with-override-system-vi</p>
</blockquote>
</li>
<li><p>升级GUI版本的vim</p>
<blockquote>
<p>brew install macvim –with-lua –with-override-system-vim</p>
</blockquote>
</li>
</ul>
<h2 id="brew_install__u4E0B_u8F7D_u6162"><a href="#brew_install__u4E0B_u8F7D_u6162" class="headerlink" title="brew install 下载慢"></a>brew install 下载慢</h2><p>用<code>brew install</code>发现下载vim8.0很慢， 解决方案是先去浏览器或用<code>wget</code>等其它方式下载好要安装的包，然后替换掉<code>brew cache</code>下的包即可。具体操作：</p>
<ul>
<li>找<code>brew cache</code> 目录<blockquote>
<p>brew cache<br>/Users/lihong/Library/Cache/Homebrew</p>
</blockquote>
</li>
</ul>
<p>可以看到上述目录中已经有一个<code>vim-8.00041.tar.gz.incomplete</code> 文件了， 将自己下载好的安装包也修改为和这个未完成文件的文件名一样，如修改为<code>vim-8.00041.tar.gz</code>. 然后,</p>
<blockquote>
<p>brew install vim –with-lua –with-override-system-vi</p>
</blockquote>
<ul>
<li><p>mac vim8.0 具体安装信息如下: </p>
<ul>
<li><p>install </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">➜  ~ brew install vim --with-lua --with-override-system-vi</span><br><span class="line">==&gt; Using the sandbox</span><br><span class="line">==&gt; Downloading https://github.com/vim/vim/archive/v8.<span class="number">0.0041</span>.tar.gz</span><br><span class="line">==&gt; Downloading from https://codeload.github.com/vim/vim/tar.gz/v8.<span class="number">0.0041</span></span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; ./configure --prefix=/usr/<span class="built_in">local</span> --mandir=/usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span>/share/man --enable-multibyte --with-tlib=ncurses --enable-cscope --with-compiledby=Homebrew --enable-luainterp --enable-perlinterp --enable-pythoninterp --enable-</span><br><span class="line">==&gt; make</span><br><span class="line">==&gt; make install prefix=/usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span> STRIP=/usr/bin/<span class="literal">true</span></span><br><span class="line">🍺  /usr/<span class="built_in">local</span>/Cellar/vim/<span class="number">8.0</span>.<span class="number">0041</span>: <span class="number">1</span>,<span class="number">706</span> files, <span class="number">23.3</span>M, built <span class="keyword">in</span> <span class="number">5</span> minutes <span class="number">16</span> seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>:version</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:version</span><br><span class="line">VIM - Vi IMproved <span class="number">8.0</span> (<span class="number">2016</span> Sep <span class="number">12</span>, compiled Oct <span class="number">16</span> <span class="number">2016</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">47</span>)</span><br><span class="line">MacOS X (unix) version</span><br><span class="line">Included patches: <span class="number">1</span>-<span class="number">41</span></span><br><span class="line">Compiled by Homebrew</span><br><span class="line">Huge version without GUI.  Features included (+) or not (-):</span><br><span class="line">+acl             -clientserver    +cursorbind      +ex_extra        -gettext         +libcall         +mouse           +mouse_xterm     +persistent_undo +ruby            +tag_old_static  -toolbar         +wildmenu        -xterm_save</span><br><span class="line">+arabic          +clipboard       +cursorshape     +extra_search    -hangul_input    +linebreak       -mouseshape      +multi_byte      +postscript      +scrollbind      -tag_any_white   +user_commands   +windows</span><br><span class="line">+autocmd         +cmdline_compl   +dialog_con      +farsi           +iconv           +lispindent      +mouse_dec       +multi_lang      +printer         +signs           -tcl             +vertsplit       +writebackup</span><br><span class="line">-balloon_<span class="built_in">eval</span>    +cmdline_hist    +diff            +file_<span class="keyword">in</span>_path    +insert_expand   +listcmds        -mouse_gpm       -mzscheme        +profile         +smartindent     +termguicolors   +virtualedit     -X11</span><br><span class="line">-browse          +cmdline_info    +digraphs        +find_<span class="keyword">in</span>_path    +job             +localmap        -mouse_jsbterm   +netbeans_intg   +python          +startuptime     +terminfo        +visual          -xfontset</span><br><span class="line">++<span class="built_in">builtin</span>_terms  +comments        -dnd             +<span class="built_in">float</span>           +jumplist        +lua             +mouse_netterm   +num64           -python3         +statusline      +termresponse    +visualextra     -xim</span><br><span class="line">+byte_offset     +conceal         -ebcdic          +folding         +keymap          +menu            +mouse_sgr       +packages        +quickfix        -sun_workshop    +textobjects     +viminfo         -xpm</span><br><span class="line">+channel         +cryptv          +emacs_tags      -footer          +lambda          +mksession       -mouse_sysmouse  +path_extra      +reltime         +syntax          +timers          +vreplace        -xsmp</span><br><span class="line">+cindent         +cscope          +<span class="built_in">eval</span>            +fork()          +langmap         +modify_fname    +mouse_urxvt     +perl            +rightleft       +tag_binary      +title           +wildignore      -xterm_clipboard</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;将mac自带的vim7.3 升级到vim8.0&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://www.grdtechs.com/categories/DevOps/"/>
    
    
      <category term="vim8.0" scheme="http://www.grdtechs.com/tags/vim8-0/"/>
    
  </entry>
  
  <entry>
    <title>优雅的关闭ticker</title>
    <link href="http://www.grdtechs.com/2016/10/16/close-ticker-correctly/"/>
    <id>http://www.grdtechs.com/2016/10/16/close-ticker-correctly/</id>
    <published>2016-10-16T14:27:39.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在<code>ticker</code>和<code>goroutine</code>组合使用中当调用<code>ticker.Stop()</code>关闭<code>ticker</code>之后，相应的<code>goroutine</code>中的<code>ticker.C</code>并没有停掉，下面总结一种优雅的方式关闭<code>ticker</code>.<br><a id="more"></a></p>
<h2 id="u4F18_u96C5_u7684_u5173_u95EDticker"><a href="#u4F18_u96C5_u7684_u5173_u95EDticker" class="headerlink" title="优雅的关闭ticker"></a>优雅的关闭<code>ticker</code></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	Demo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Demo() &#123;</span><br><span class="line">	done := startTicker(PrintInfo)</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">12</span>) * time.Second)</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">1</span>) * time.Minute)</span><br><span class="line">	fmt.Println(<span class="string">"main finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> startTicker(f <span class="keyword">func</span>()) <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">		<span class="comment">//	ticker := time.NewTicker(5 * time.Minute)</span></span><br><span class="line">		<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				f()</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> PrintInfo() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过<code>startTicker</code>创建一个<code>ticker</code>, 当想要关闭这个<code>ticker</code>并同时退出对应<code>goroutine</code>中的<code>for</code>时，可以直接<code>close()</code>，发送<code>done</code>信号直接返回退出<code>startTicker</code>即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;ticker&lt;/code&gt;和&lt;code&gt;goroutine&lt;/code&gt;组合使用中当调用&lt;code&gt;ticker.Stop()&lt;/code&gt;关闭&lt;code&gt;ticker&lt;/code&gt;之后，相应的&lt;code&gt;goroutine&lt;/code&gt;中的&lt;code&gt;ticker.C&lt;/code&gt;并没有停掉，下面总结一种优雅的方式关闭&lt;code&gt;ticker&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="ticker" scheme="http://www.grdtechs.com/tags/ticker/"/>
    
  </entry>
  
  <entry>
    <title>Golang发送post表单请求</title>
    <link href="http://www.grdtechs.com/2016/09/07/go-postform/"/>
    <id>http://www.grdtechs.com/2016/09/07/go-postform/</id>
    <published>2016-09-07T16:00:32.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang这边将<code>map</code>结构序列化通常采用<code>json.Marshal</code>和<code>json.Unmarshal</code>来做，但是在php server端还需要做<code>json</code>反序列化解析才能用， 用golang模拟表单提交, php server端则非常方便提取相应的数据字段.<br><a id="more"></a></p>
<h2 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h2><p>方法是利用golang<code>net/http</code>包提供的<code>PostForm</code>提交post表单提交。<code>ParseForm</code>解析<code>URL</code>中的查询字符串，并将解析结果更新到<code>r.Form</code>字段。对于<code>POST</code>或<code>PUT</code>请求，<code>ParseForm</code>还会将<code>body</code>当作表单解析，并将结果既更新到<code>r.PostForm</code>也更新到<code>r.Form</code>。解析结果中，<code>POST</code>或<code>PUT</code>请求主体要优先于<code>URL</code>查询字符串（同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被<code>MaxBytesReader</code>函数设定限制，其大小默认限制为开头10MB。</p>
<h2 id="http-Client_7B_7D-PostForm"><a href="#http-Client_7B_7D-PostForm" class="headerlink" title="http.Client{}.PostForm"></a>http.Client{}.PostForm</h2><p>利用<code>http.Client{}.PostForm</code>提交post表单。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">res, err := client.PostForm(<span class="string">"http://127.0.0.1:8091/postpage"</span>, url.Values&#123;</span><br><span class="line">	<span class="string">"key"</span>:   &#123;<span class="string">"this is client key"</span>&#125;,</span><br><span class="line">	<span class="string">"value"</span>: &#123;<span class="string">"this is client value"</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="http-PostForm"><a href="#http-PostForm" class="headerlink" title="http.PostForm"></a>http.PostForm</h2><p>直接用<code>http.PostForm</code>提交post表单。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"><span class="comment">//data := make(url.Values)</span></span><br><span class="line"><span class="comment">//data["key"] = []string&#123;"this is key"&#125;</span></span><br><span class="line"><span class="comment">//data["value"] = []string&#123;"this is value"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把post表单发送给目标服务器</span></span><br><span class="line">res, err := http.PostForm(<span class="string">"http://127.0.0.1:8091/postpage"</span>, url.Values&#123;</span><br><span class="line">	<span class="string">"key"</span>:   &#123;<span class="string">"this is url key"</span>&#125;,</span><br><span class="line">	<span class="string">"value"</span>: &#123;<span class="string">"this is url value"</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="u5BF9_u8868_u5355_u6570_u636E_u7684_u63D0_u53D6"><a href="#u5BF9_u8868_u5355_u6570_u636E_u7684_u63D0_u53D6" class="headerlink" title="对表单数据的提取"></a>对表单数据的提取</h2><p>server端对表单数据的提取<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受post请求， 然后打印表单中key和value字段的值</span></span><br><span class="line"><span class="keyword">if</span> r.Method == <span class="string">"POST"</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		key   <span class="typename">string</span> = r.PostFormValue(<span class="string">"key"</span>)</span><br><span class="line">		value <span class="typename">string</span> = r.PostFormValue(<span class="string">"value"</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/researchlab/golearning/tree/master/postform" target="_blank" rel="external">github示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang这边将&lt;code&gt;map&lt;/code&gt;结构序列化通常采用&lt;code&gt;json.Marshal&lt;/code&gt;和&lt;code&gt;json.Unmarshal&lt;/code&gt;来做，但是在php server端还需要做&lt;code&gt;json&lt;/code&gt;反序列化解析才能用， 用golang模拟表单提交, php server端则非常方便提取相应的数据字段.&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="form" scheme="http://www.grdtechs.com/tags/form/"/>
    
      <category term="post" scheme="http://www.grdtechs.com/tags/post/"/>
    
  </entry>
  
  <entry>
    <title>php7 安装redis扩展</title>
    <link href="http://www.grdtechs.com/2016/08/02/php7-redis-install/"/>
    <id>http://www.grdtechs.com/2016/08/02/php7-redis-install/</id>
    <published>2016-08-02T18:56:05.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在<code>Ubuntu16.04</code>上， 安装<code>php7</code>的<code>redis</code>扩展, 记录安装过程。<br><a id="more"></a></p>
<h3 id="u5B89_u88C5phpredis"><a href="#u5B89_u88C5phpredis" class="headerlink" title="安装phpredis"></a>安装phpredis</h3><p><code>Redis</code>已经有了<code>PHP7</code>版本，可以从<code>github</code> 上获取项目克隆，然后手动切换到 <code>php7</code> 分支即可安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/phpredis/phpredis.git </span><br><span class="line">$ <span class="built_in">cd</span> phpredis/ </span><br><span class="line">$ git checkout php7 </span><br><span class="line">$ phpize </span><br><span class="line">$ ./configure </span><br><span class="line">$ make </span><br><span class="line">$ makeinstall</span><br></pre></td></tr></table></figure>
<p>如果没有安装php7.0-dev, 则没有安装 <code>phpize</code> , 可以直接<code>sudo apt install php7.0-dev</code> 安装即可。 </p>
<h2 id="u542F_u52A8_redis__u6269_u5C55"><a href="#u542F_u52A8_redis__u6269_u5C55" class="headerlink" title="启动 redis 扩展"></a>启动 redis 扩展</h2><p>光安装了还不够，我们还需要编辑PHP的配置文件来使扩展被加载才行， 打开配置文件<code>vim /etc/php/7.0/fpm/php .ini</code>, 在配置文件中添加如下语句：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=redis.so</span><br></pre></td></tr></table></figure></p>
<p>然后重启php服务,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/php7.<span class="number">0</span>-fpm restart</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;Ubuntu16.04&lt;/code&gt;上， 安装&lt;code&gt;php7&lt;/code&gt;的&lt;code&gt;redis&lt;/code&gt;扩展, 记录安装过程。&lt;br&gt;
    
    </summary>
    
      <category term="php" scheme="http://www.grdtechs.com/categories/php/"/>
    
    
      <category term="php_redis" scheme="http://www.grdtechs.com/tags/php-redis/"/>
    
      <category term="phpize" scheme="http://www.grdtechs.com/tags/phpize/"/>
    
  </entry>
  
  <entry>
    <title>php中mvc模式使用总结(一)</title>
    <link href="http://www.grdtechs.com/2016/07/30/php-mvc-1/"/>
    <id>http://www.grdtechs.com/2016/07/30/php-mvc-1/</id>
    <published>2016-07-30T16:34:45.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>尽管MVC(model view controller pattern)模式在<code>PHP</code>web开发中很受欢迎，但是网上很难找到一套代码简单又能清楚阐述<code>PHP MVC</code>模式的案例，本文希望通过理论和代码实践简单阐述<code>PHP MVC</code>模式。</p>
<a id="more"></a>
<p><code>MVC</code>模式在应用中分为<code>Model</code>, <code>View</code> 和 <code>Controller</code>三模块:</p>
<p><code>Model</code>负责处理数据; 主要负责数据有关的业务处理及存储读取工作。</p>
<p><code>View</code>负责将<code>Model</code>层的数据按一定的格式样式展现给用户。</p>
<p><code>Controller</code>负责将<code>Model</code>层和<code>View</code>层联系起来，<code>Controller</code>层响应用户的请求，并将请求业务分发给<code>Model</code>层相应的业务逻辑处理，然后将处理数据再返回给<code>View</code>层展示。 </p>
<p><code>MVC</code>三者之间的关系如图所示:</p>
<center><br><img src="/imgs/mvc-collaboration.png" alt="MVC pattern Diagram"><br></center>

<p>本文设计的<code>MVC</code>demo目录如下</p>
<center><br><img src="/imgs/mvc-structure.png" alt="mvc structure"><br></center>

<h2 id="Controller__u5C42"><a href="#Controller__u5C42" class="headerlink" title="Controller 层"></a>Controller 层</h2><p><code>Controller</code>层可是<code>MVC</code>的入口，接收一个用户请求，解析请求发送给<code>Model</code>层，调用<code>Model</code>层处理业务，接收<code>Model</code>层返回的数据结果，并将数据发送给展示层。<code>Controller</code>层是<code>Model</code>层和<code>View</code>层之间的连接纽带;小的框架中<code>Model</code>层和<code>View</code>层是包含在<code>Controller</code>层中。应用程序中一般会以<code>index.php</code>作为程序的入口，<code>index.php</code>会将用户的所有请求直接转发到<code>Controller</code>层,由<code>Controller</code>层进行相应的处理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.php file </span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">"controller/Controller.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$controller</span> = <span class="keyword">new</span> Controller();</span><br><span class="line"><span class="variable">$controller</span>-&gt;invoke();</span><br></pre></td></tr></table></figure>
<p>在本例中<code>Controller</code>层只有一个函数和一个构造函数。构造函数示例化一个<code>Model</code>类的实例;当<code>Controller</code>对接收的<code>req</code>解析之后，需要决定调用<code>Model</code>层相应的业务逻辑进行处理，然后将<code>Model</code>层返回的处理数据分发给<code>view</code>层展示。需要知道的是<code>Controller</code>层不是知道<code>data</code>如何处理的，也不知道页面是如何生成的。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//controller/Controller.php file</span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">"model/Model.php"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$model</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="variable">$this</span>-&gt;model = <span class="keyword">new</span> Model();	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="keyword">isset</span>(!_GET[<span class="string">'book'</span>]))&#123;</span><br><span class="line">			<span class="variable">$books</span> = <span class="variable">$this</span>-&gt;model-&gt;getBookList();</span><br><span class="line">			<span class="keyword">include</span> <span class="string">'view/booklist.php'</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// show the requested book</span></span><br><span class="line">			<span class="variable">$book</span> = <span class="variable">$this</span>-&gt;model-&gt;getBook(<span class="variable">$_GET</span>[<span class="string">'book'</span>]);</span><br><span class="line">			<span class="keyword">include</span> <span class="string">'view/viewbook.php'</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MVC</code>时序图</p>
<center><br><img src="/imgs/mvc-sequence1.png" alt="MVC Sequence Diagram"><br></center>

<h2 id="Model__u548C_Entity__u7C7B"><a href="#Model__u548C_Entity__u7C7B" class="headerlink" title="Model 和 Entity 类"></a>Model 和 Entity 类</h2><p><code>Model</code>层表示应用程序中的数据和逻辑，通常称之为业务逻辑; 通常表示为如下:</p>
<ul>
<li><p>存储，删除， 更新应用程序的数据。通常包括数据库方面的操作, 也可以按照一定的协议格式封装数据然后再通过调用第三方web服务或APIs进行相应的数据处理。</p>
</li>
<li><p>封装应用程序的业务逻辑;实现应用程序的所有业务逻辑。通常人们会错误的应用程序的一些业务逻辑实现写入到<code>Controller</code>层或<code>View</code>层中， 这是一种错误的或者说不规范的做法。 </p>
</li>
</ul>
<p>本例中，<code>Model</code>层主要由<code>Model</code>类和<code>Book</code>类组成。<code>Book</code>类是一个实体类，应该暴露给<code>View</code>层。在一个好的<code>MVC</code>模式设计中，<code>Model</code>层中只有<code>Entity</code>类应该暴露接口供<code>View</code>层调用。这样做的唯一目的就是保持数据,因为<code>Entity</code>类中的对象可以通过<code>xml</code>或<code>json</code>数据块替换。在上述的示例中，<code>Model</code>层返回了一个具体的<code>book</code>实例信息，或者一个<code>books</code>list:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//model/Model.php file</span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">"model/Book.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//here goes some hardcoded values to simulate the database</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">			<span class="string">"Jungle Book"</span>=&gt; <span class="keyword">new</span> Book(<span class="string">"Jungle Book"</span>, <span class="string">"R.Kipling"</span>, <span class="string">"A classic book."</span>),</span><br><span class="line">			<span class="string">"Moonwalker"</span>=&gt; <span class="keyword">new</span> Book(<span class="string">"Moonwalker"</span>, <span class="string">"J.Walker"</span>,<span class="string">""</span>),</span><br><span class="line">			<span class="string">"PHP for Dummies"</span>=&gt; <span class="keyword">new</span> Book(<span class="string">"PHP for Dummies"</span>, <span class="string">"Some Smart Guy"</span>,<span class="string">""</span>)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBook</span><span class="params">(<span class="variable">$title</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// we use the previous function to get all the books and then we return the requested one.</span></span><br><span class="line">		<span class="comment">// in a real life scenario this will be done through a db select command.</span></span><br><span class="line">		<span class="variable">$allBooks</span> = <span class="variable">$this</span>-&gt;getBookList();</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$allBooks</span>[<span class="variable">$title</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在真实场景中，<code>Model</code>层负责将所有的实体和类中的数据持久化到数据库，<code>Model</code>层中的类封装所有的业务逻辑。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//model/Book.php file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$title</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$author</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$description</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(<span class="variable">$title</span>, <span class="variable">$author</span>, <span class="variable">$description</span>)</span></span>&#123;</span><br><span class="line">		<span class="variable">$this</span>-&gt;title = <span class="variable">$title</span>;</span><br><span class="line">		<span class="variable">$this</span>-&gt;author = <span class="variable">$author</span>;</span><br><span class="line">		<span class="variable">$this</span>-&gt;description = <span class="variable">$description</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View_u5C42"><a href="#View_u5C42" class="headerlink" title="View层"></a>View层</h2><p><code>View</code>层负责将<code>Model</code>层返回的数据按照一定样式格式化呈现给用户。<code>Model</code>层返回的数据可以是简单的对象类型，也可以是xml, json等复杂的数据类型。</p>
<p><code>View</code>层对于类似的展示逻辑应提取为模板，便于复用<code>View</code>层代码的同时有利于维护 。<code>Controller</code>层通常通过<code>Entity</code>类中的主<code>Entity</code>实例对象将<code>Model</code>层返回的数据转发给<code>View</code>层中特定的展示元素。</p>
<p>在本例中<code>View</code>层包含展示单个<code>book</code>信息和展示所有<code>book</code>信息两个文件</p>
<h3 id="viewbook-php"><a href="#viewbook-php" class="headerlink" title="viewbook.php"></a>viewbook.php</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="php"><span class="preprocessor">&lt;?php</span></span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'Title:'</span> . <span class="variable">$book</span>-&gt;title . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'Author:'</span> . <span class="variable">$book</span>-&gt;author . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'Description:'</span> . <span class="variable">$book</span>-&gt;description . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">	<span class="preprocessor">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="booklist-php"><a href="#booklist-php" class="headerlink" title="booklist.php"></a>booklist.php</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">tbody</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Title<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Author<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">tbody</span>&gt;</span>	</span><br><span class="line">		<span class="php"><span class="preprocessor">&lt;?php</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">foreach</span>(<span class="variable">$books</span> <span class="keyword">as</span> <span class="variable">$title</span> =&gt; <span class="variable">$book</span>)&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'&lt;tr&gt;&lt;td&gt;&lt;a href="index.php?book="'</span> . <span class="variable">$book</span>-&gt;title .<span class="string">'"&gt;'</span>.<span class="variable">$book</span>-&gt;title .<span class="string">'&lt;/a&gt;&lt;/td&gt;&lt;td&gt;'</span>.<span class="variable">$book</span>-&gt;author.<span class="string">'&lt;/td&gt;&lt;td&gt;'</span>.<span class="variable">$book</span>-&gt;description.<span class="string">'&lt;/td&gt;&lt;/tr&gt;'</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="preprocessor">?&gt;</span></span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至此本demo分析实现完毕，<a href="https://github.com/researchlab/CodeSnippets/tree/master/php_wrk/simple_mvc" target="_blank" rel="external">github示例代码</a></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Model</code>层和<code>View</code>层分开使得构建应用程序更加容易</li>
<li><code>Model</code>层和<code>View</code>层可以根据项目需要其中一层构成<code>MV</code>或<code>CV</code>模式</li>
<li>可以对<code>MVC</code>模式中每个层进行单独的测试和调试</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;尽管MVC(model view controller pattern)模式在&lt;code&gt;PHP&lt;/code&gt;web开发中很受欢迎，但是网上很难找到一套代码简单又能清楚阐述&lt;code&gt;PHP MVC&lt;/code&gt;模式的案例，本文希望通过理论和代码实践简单阐述&lt;code&gt;PHP MVC&lt;/code&gt;模式。&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://www.grdtechs.com/categories/php/"/>
    
    
      <category term="mvc" scheme="http://www.grdtechs.com/tags/mvc/"/>
    
      <category term="php" scheme="http://www.grdtechs.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>浏览器刷新后input输入框依旧保留原值不被清空</title>
    <link href="http://www.grdtechs.com/2016/07/10/browse-refresh-saveinputolderval/"/>
    <id>http://www.grdtechs.com/2016/07/10/browse-refresh-saveinputolderval/</id>
    <published>2016-07-10T18:22:43.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>html页面中的input框如果在浏览器刷新前有值，怎么在刷新后依然保留这个值不被清空呢？下面用<code>setCookie</code>的方案来解决这个问题.<br><a id="more"></a><br>首选判断input框中有值时,<code>setcookie</code>, 每次刷新浏览器时，读取<code>Cookie</code>值,如果存在<code>Cookie</code>值，则用此值初始化input值。</p>
<h2 id="u7EAFjs_u5B9E_u73B0"><a href="#u7EAFjs_u5B9E_u73B0" class="headerlink" title="纯js实现"></a>纯js实现</h2><h3 id="u8BBE_u7F6ECookie"><a href="#u8BBE_u7F6ECookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* @cname  cookie name </span><br><span class="line">* @cvalue cookie value </span><br><span class="line">* @ exdays cookie expires(天)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">cname,cvalue,exdays</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(<span class="built_in">document</span>.cookie || navigator.cookieEnabled))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'浏览器 cookie 未打开!'</span>);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">	d.setTime(d.getTime()+(exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line">	<span class="keyword">var</span> expires = <span class="string">"expires="</span>+d.toGMTString();</span><br><span class="line">	<span class="built_in">document</span>.cookie = cname+<span class="string">"="</span>+cvalue+<span class="string">"; "</span>+expires;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u83B7_u53D6Cookie"><a href="#u83B7_u53D6Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = cname + <span class="string">"="</span>;</span><br><span class="line">	<span class="keyword">var</span> ca = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ca.length; i++) </span><br><span class="line">	  &#123;</span><br><span class="line">	  <span class="keyword">var</span> c = ca[i].trim();</span><br><span class="line">	  <span class="keyword">if</span> (c.indexOf(name)==<span class="number">0</span>) <span class="keyword">return</span> c.substring(name.length,c.length);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>cname</code> 获取相应的cookie值， cookie不存在就返回空字符串.</p>
<h3 id="checkCookie"><a href="#checkCookie" class="headerlink" title="checkCookie"></a>checkCookie</h3><p>可以将判断Cookie是否存在的下一步处理逻辑封装到<code>checkCookie</code>方法中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> user=getCookie(<span class="string">"username"</span>);</span><br><span class="line">	<span class="keyword">if</span> (user!=<span class="string">""</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'user'</span>, user);	</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	  &#123;</span><br><span class="line">	  <span class="keyword">if</span> (user!=<span class="string">""</span> &amp;&amp; user!=<span class="literal">null</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	    setCookie(<span class="string">"username"</span>,user,<span class="number">3000</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53E6_u4E00_u79CD_u65B9_u5F0F_u662F_u501F_u52A9jQuery_u5B9E_u73B0"><a href="#u53E6_u4E00_u79CD_u65B9_u5F0F_u662F_u501F_u52A9jQuery_u5B9E_u73B0" class="headerlink" title="另一种方式是借助jQuery实现"></a>另一种方式是借助jQuery实现</h2><p>首选引入jquery相应的库</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://apps.bdimg.com/libs/jquery.cookie/1.4.1/jquery.cookie.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="u521B_u5EFACookie"><a href="#u521B_u5EFACookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h2><p>如创建一个名为“example”，值为“foo”的cookie：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure></p>
<p>要设置cookie的有效期，可以设置expires值，如设置cookie的过期时间为10天：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;expires:<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>设置cookie一小时后过期：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookietime = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line">cookietime.setTime(date.getTime() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));<span class="comment">//coockie保存一小时 </span></span><br><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;expires:cookietime&#125;);</span><br></pre></td></tr></table></figure>
<p>要设置cookie的保存路径，可以设置path值，如设置路径为根目录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;path:<span class="string">"/"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>如果要设置路径为/admin，则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>, <span class="string">"foo"</span>,&#123;path:<span class="string">"/admin"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="u83B7_u53D6cookie_u503C"><a href="#u83B7_u53D6cookie_u503C" class="headerlink" title="获取cookie值"></a>获取cookie值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="u5220_u9664Cookie"><a href="#u5220_u9664Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h2><p>使用jQuery删除cookie，只需要将cookie的值为null，注意如果设置值为空的字符串时，并不能删除cookie，只是将cookie值清空而已。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">"example"</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.cookie(<span class="string">'the_cookie'</span>, <span class="string">''</span>, &#123; expires: -<span class="number">1</span> &#125;); <span class="comment">// 删除 cookie</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/researchlab/CodeSnippets" target="_blank" rel="external">github源码demo</a></p>
<ul>
<li>js-setcookie.html</li>
<li>jquery-setcookie.html</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>cookie是基于域名来储存的, cookie具有不同域名下储存不可共享的特性。 这也是cookie支持设置<code>path</code>和<code>domain</code>的作用之一。<br>所以要测试cookie是否生效，需要放到测试服务器上或者本地localhost服务器上才会生效。<strong><font color="red">单纯的本地一个html页面打开是无效的。</font></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;html页面中的input框如果在浏览器刷新前有值，怎么在刷新后依然保留这个值不被清空呢？下面用&lt;code&gt;setCookie&lt;/code&gt;的方案来解决这个问题.&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.grdtechs.com/categories/javascript/"/>
    
    
      <category term="getcookie" scheme="http://www.grdtechs.com/tags/getcookie/"/>
    
      <category term="setcookie" scheme="http://www.grdtechs.com/tags/setcookie/"/>
    
  </entry>
  
  <entry>
    <title>go http client/server 设置cookie小结</title>
    <link href="http://www.grdtechs.com/2016/07/10/go-setcookie/"/>
    <id>http://www.grdtechs.com/2016/07/10/go-setcookie/</id>
    <published>2016-07-10T16:51:56.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>Go</code>web开发中，经常需要设置获取cookies, 不管是从client端设置获取还是server设置获取，其实都差不多，下面就总结一下常用的方法。<br><a id="more"></a></p>
<h2 id="golang_u4E2Dcookie__u8BE6_u7EC6_u5B9A_u4E49"><a href="#golang_u4E2Dcookie__u8BE6_u7EC6_u5B9A_u4E49" class="headerlink" title="golang中cookie 详细定义"></a>golang中cookie 详细定义</h2><p>golang 官方文档中对<code>Cookie</code>结构的定义<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="typename">string</span></span><br><span class="line">    Value      <span class="typename">string</span></span><br><span class="line">    Path       <span class="typename">string</span></span><br><span class="line">    Domain     <span class="typename">string</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="typename">string</span></span><br><span class="line">    <span class="comment">// MaxAge=0表示未设置Max-Age属性</span></span><br><span class="line">    <span class="comment">// MaxAge&lt;0表示立刻删除该cookie，等价于"Max-Age: 0"</span></span><br><span class="line">    <span class="comment">// MaxAge&gt;0表示存在Max-Age属性，单位是秒</span></span><br><span class="line">    MaxAge   <span class="typename">int</span></span><br><span class="line">    Secure   <span class="typename">bool</span></span><br><span class="line">    HttpOnly <span class="typename">bool</span></span><br><span class="line">    Raw      <span class="typename">string</span></span><br><span class="line">    Unparsed []<span class="typename">string</span> <span class="comment">// 未解析的“属性-值”对的原始文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Cookie</code>代表一个出现在<code>HTTP回复的头域</code>中<code>Set-Cookie头的值里</code>或者<code>HTTP请求的头域</code>中Cookie头的值里的HTTP cookie。</p>
<ul>
<li><p><code>Expires</code> – 过期时间。指定cookie的生命期。具体是值是过期日期。如果想让cookie的存在期限超过当前浏览器会话时间，就必须使用这个属性。当过了到期日期时，浏览器就可以删除cookie文件，没有任何影响。</p>
</li>
<li><p><code>Path</code> – 路径。指定与cookie关联的WEB页。值可以是一个目录，或者是一个路径。如果/head/index.html 建立了一个cookie，那么在/head/目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个cookie。这就是说，在/head/stories/articles 里的任何页面都可以访问/head/index.html建立的cookie。但是，如果/zdnn/ 需要访问/head/index.html设置的cookes，该怎么办?这时，我们要把cookies的path属性设置成“/”。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享cookies。现在看另一个例子：如果想让 /head/filters/ 和/head/stories/共享cookies，就要把path设成“/head”。</p>
</li>
<li><p><code>Domain</code> – 域。指定关联的WEB服务器或域。值是域名，比如goaler.com。这是对path路径属性的一个延伸。如果我们想让dev.mycompany.com 能够访问bbs.mycompany.com设置的cookies，该怎么办? 我们可以把domain属性设置成“mycompany.com”，并把path属性设置成“/”。FYI：不能把cookies域属性设置成与设置它的服务器的所在域不同的值。</p>
</li>
<li><p><code>Secure</code> – 安全。指定cookie的值通过网络如何在用户和WEB服务器之间传递。这个属性的值或者是“secure”，或者为空。缺省情况下，该属性为空，也就是使用不安全的HTTP连接传递数据。如果一个 cookie 标记为secure，那么，它与WEB服务器之间就通过HTTPS或者其它安全协议传递数据。不过，设置了secure属性不代表其他人不能看到你机器本地保存的cookie。换句话说，把cookie设置为secure，只保证cookie与WEB服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。</p>
</li>
<li><p><code>HttpOnly</code>属性,如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</p>
</li>
<li><p><code>secure</code>属性是防止信息在传递的过程中被监听捕获后信息泄漏，<code>HttpOnly</code>属性的目的是防止程序获取cookie后进行攻击。</p>
</li>
</ul>
<p><strong> 参考更多 </strong></p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="external">中文维基 - Cookie</a></li>
<li><a href="https://en.wikipedia.org/wiki/HTTP_cookie#Session_management" target="_blank" rel="external">英文维基 - Http-Cookie</a></li>
</ul>
<h2 id="client__u7AEF_u8BBE_u7F6Ecookie"><a href="#client__u7AEF_u8BBE_u7F6Ecookie" class="headerlink" title="client 端设置cookie"></a>client 端设置cookie</h2><p>客户端设置cookie,很简单<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client  set cookie</span></span><br><span class="line">cookie := http.Cookie&#123;Name: <span class="string">"clientcookieid"</span>, Value: <span class="string">"121"</span>, Expires: time.Now().Add(<span class="number">111</span> * time.Second)&#125;</span><br><span class="line">req.AddCookie(&amp;cookie)</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.AddCookie(&amp;http.Cookie&#123;</span><br><span class="line">	Name:    <span class="string">"clientcookieid2"</span>,</span><br><span class="line">	Value:   <span class="string">"id2"</span>,</span><br><span class="line">	Expires: time.Now().Add(<span class="number">111</span> * time.Second),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="server_u7AEF_u63A5_u6536cookie"><a href="#server_u7AEF_u63A5_u6536cookie" class="headerlink" title="server端接收cookie"></a>server端接收cookie</h2><p>后端接收cookie有两种方式,如果是指定cookie的名字，只要取得1个或少数几个cookie, 可以用如下方式获取<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_cookie, _ := r.Cookie(<span class="string">"clientcookieid"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, client_cookie)</span><br><span class="line">fmt.Println(client_cookie.Name, clinet_cookie.Value) <span class="comment">// 通过点运算符获取client_cookie的属性</span></span><br></pre></td></tr></table></figure></p>
<p>如果指定了多个cookie值对，则可以通过迭代的方式访问<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> r.Cookies() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="server_u7AEF_u8BBE_u7F6Ecookie"><a href="#server_u7AEF_u8BBE_u7F6Ecookie" class="headerlink" title="server端设置cookie"></a>server端设置cookie</h2><p>server端设置cookie 和client端设置cookie类似，不同的是 server端用的是<code>http.SetCookie</code>, 而client端用的是<code>req.AddCookie</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http.SetCookie(w, &amp;http.Cookie&#123;</span><br><span class="line">	Name:    <span class="string">"servercookie"</span>,</span><br><span class="line">	Value:   <span class="string">"servercookievalue"</span>,</span><br><span class="line">	Expires: time.Now().Add(<span class="number">111</span> * time.Second),</span><br><span class="line">&#125;)</span><br><span class="line">http.SetCookie(w, &amp;http.Cookie&#123;</span><br><span class="line">	Name:    <span class="string">"servercookie2"</span>,</span><br><span class="line">	Value:   <span class="string">"servercookievalue2"</span>,</span><br><span class="line">	Expires: time.Now().Add(<span class="number">111</span> * time.Second),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="client__u7AEF_u63A5_u6536cookie"><a href="#client__u7AEF_u63A5_u6536cookie" class="headerlink" title="client 端接收cookie"></a>client 端接收cookie</h2><p>golang client端接收cookie 只能通过迭代的方式获取<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> resp.Cookies() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/researchlab/golearning/tree/master/setcookie" target="_blank" rel="external">完整示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;web开发中，经常需要设置获取cookies, 不管是从client端设置获取还是server设置获取，其实都差不多，下面就总结一下常用的方法。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="net/http" scheme="http://www.grdtechs.com/tags/net-http/"/>
    
      <category term="setcookie" scheme="http://www.grdtechs.com/tags/setcookie/"/>
    
  </entry>
  
  <entry>
    <title>html 美化输出 json 字符串</title>
    <link href="http://www.grdtechs.com/2016/06/17/jsonfmt/"/>
    <id>http://www.grdtechs.com/2016/06/17/jsonfmt/</id>
    <published>2016-06-17T10:55:21.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>json</code>字符串在html用js美化输出使用总结。<br><a id="more"></a></p>
<h2 id="JSON-stringify_28_29_u51FD_u6570_u539F_u578B"><a href="#JSON-stringify_28_29_u51FD_u6570_u539F_u578B" class="headerlink" title="JSON.stringify()函数原型"></a>JSON.stringify()函数原型</h2><p><strong>语法：</strong><br>　　<code>JSON.stringify(value [, replacer] [, space])</code></p>
<p><code>value</code>：是必选字段。就是你输入的对象，比如数组，类等。<br><code>replacer</code>：这个是可选的。它又分为2种方式，一种是数组，第二种是方法。<br>　　情况一：<code>replacer</code>为数组时，通过后面的实验可以知道，它是和第一个参数<code>value</code>有关系的。一般来说，系列化后的结果是通过键值对来进行表示的。 所以，如果此时第二个参数的值在第一个存在，那么就以第二个参数的值做<code>key</code>，第一个参数的值为<code>value</code>进行表示，如果不存在，就忽略。</p>
<p>　　情况二：<code>replacer</code>为方法时，那很简单，就是说把系列化后的每一个对象（记住是每一个）传进方法里面进行处理。 </p>
<p><code>space</code>：就是用什么来做分隔符的。<br>　　1）如果省略的话，那么显示出来的值就没有分隔符，直接输出来 。<br>　　2）如果是一个数字的话，那么它就定义缩进几个字符，当然如果大于10 ，则默认为10，因为最大值为10。<br>　　3）如果是一些转义字符，比如<code>\t</code>，表示回车，那么它每行一个回车。<br>　　4）如果仅仅是字符串，就在每行输出值的时候把这些字符串附加上去。当然，最大长度也是10个字符。 </p>
<h2 id="JSON-stringify_28_29__u5B9E_u4F8B"><a href="#JSON-stringify_28_29__u5B9E_u4F8B" class="headerlink" title="JSON.stringify() 实例"></a>JSON.stringify() 实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>html美化输出json字符串<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">'text/css'</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">pre</span> <span class="rules">&#123;<span class="rule"><span class="attribute">outline</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">5px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.string</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> green</span></span>; &#125;</span></span><br><span class="line"><span class="class">.number</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> darkorange</span></span>; &#125;</span></span><br><span class="line"><span class="class">.boolean</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> blue</span></span>; &#125;</span></span><br><span class="line"><span class="class">.null</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> magenta</span></span>; &#125;</span></span><br><span class="line"><span class="class">.key</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>; &#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">pre</span> <span class="attribute">id</span>=<span class="value">"output"</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">pre</span> <span class="attribute">id</span>=<span class="value">"output2"</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;a:<span class="number">1</span>, <span class="string">'b'</span>:<span class="string">'foo'</span>, c:[<span class="literal">false</span>,<span class="literal">null</span>, &#123;d:&#123;e:<span class="number">1.3e5</span>&#125;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 最简单的输出</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj, <span class="literal">undefined</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'output'</span>).innerHTML = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 带高亮的输出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">highLight</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">			 json = json.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>).replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">			  <span class="keyword">return</span> json.replace(<span class="regexp">/("(\\u[a-zA-Z0-9]&#123;4&#125;|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match</span>) </span>&#123;</span><br><span class="line">				     <span class="keyword">var</span> cls = <span class="string">'number'</span>;</span><br><span class="line">				     <span class="keyword">if</span> (<span class="regexp">/^"/</span>.test(match)) &#123;</span><br><span class="line">				         <span class="keyword">if</span> (<span class="regexp">/:$/</span>.test(match)) &#123;</span><br><span class="line">				             cls = <span class="string">'key'</span>;</span><br><span class="line">				         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				             cls = <span class="string">'string'</span>;</span><br><span class="line">				         &#125;</span><br><span class="line">				     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/true|false/</span>.test(match)) &#123;</span><br><span class="line">				         cls = <span class="string">'boolean'</span>;</span><br><span class="line">				     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/null/</span>.test(match)) &#123;</span><br><span class="line">				         cls = <span class="string">'null'</span>;</span><br><span class="line">				     &#125;</span><br><span class="line">				     <span class="keyword">return</span> <span class="string">'&lt;span class="'</span> + cls + <span class="string">'"&gt;'</span> + match + <span class="string">'&lt;/span&gt;'</span>;</span><br><span class="line">				 &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> person = &#123;</span><br><span class="line">			 name: <span class="string">"Hello Kitty"</span>,</span><br><span class="line">			 sex: <span class="string">"男"</span>,</span><br><span class="line">			 age: <span class="number">20</span>,</span><br><span class="line">			 child: [</span><br><span class="line">			 	&#123;</span><br><span class="line">			 		name: <span class="string">"Hello"</span>,</span><br><span class="line">					sex: <span class="string">"男"</span>,</span><br><span class="line">					age: <span class="number">10</span>,</span><br><span class="line">					toy:[<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">			 	&#125;,</span><br><span class="line">			 	&#123;</span><br><span class="line">			 		name: <span class="string">"Kitty"</span>,</span><br><span class="line">					sex: <span class="string">"女"</span>,</span><br><span class="line">					age: <span class="number">8</span>,</span><br><span class="line">					toy:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">			 	&#125;</span><br><span class="line">			 ]</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(person, <span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment">//document.getElementById('output2').innerHTML = syntaxHighlight(str);</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'output2'</span>).innerHTML = highLight(str);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述示例的效果如图:</p>
<center><img src="/imgs/jsonfmt.png" alt="jsonformat"></center>

<p><a href="https://github.com/researchlab/CodeSnippets/blob/master/json.html" target="_blank" rel="external">详见github示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;json&lt;/code&gt;字符串在html用js美化输出使用总结。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.grdtechs.com/categories/javascript/"/>
    
    
      <category term="html" scheme="http://www.grdtechs.com/tags/html/"/>
    
      <category term="json" scheme="http://www.grdtechs.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>golang 格式化时间总结</title>
    <link href="http://www.grdtechs.com/2016/06/14/go-time-summary/"/>
    <id>http://www.grdtechs.com/2016/06/14/go-time-summary/</id>
    <published>2016-06-14T14:05:28.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>golang</code> 中经常需要格式化时间和日期来满足不同的业务需求,下面总结格式化时间日期中遇到的问题。<br><a id="more"></a></p>
<h2 id="golang_time_u5305__u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316_u5B9A_u4E49"><a href="#golang_time_u5305__u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316_u5B9A_u4E49" class="headerlink" title="golang time包 时间日期格式化定义"></a>golang time包 时间日期格式化定义</h2><p>go 的time package 提供了time.Format函数，用来对时间进行格式化输出;类似的还有time.Parse用来解析字符串类型的时间到time.Time。这是两个互逆的函数。</p>
<p><strong> 下面看<code>golang</code>中<code>time</code>包对于时间的详细定义 </strong></p>
<ul>
<li>月份 1,01,Jan,January</li>
<li>日　 2,02,_2</li>
<li>时　 3,03,15,PM,pm,AM,am</li>
<li>分　 4,04</li>
<li>秒　 5,05</li>
<li>年　 06,2006</li>
<li>时区 -07,-0700,Z0700,Z07:00,-07:00,MST</li>
<li>周几 Mon,Monday</li>
</ul>
<p><strong> 比如小时的表示(原定义是下午3时，也就是15时) </strong></p>
<ul>
<li>3 用12小时制表示，去掉前导0</li>
<li>03 用12小时制表示，保留前导0</li>
<li>15 用24小时制表示，保留前导0</li>
<li>03pm 用24小时制am/pm表示上下午表示，保留前导0</li>
<li>3pm 用24小时制am/pm表示上下午表示，去掉前导0</li>
</ul>
<p><strong> 又比如月份 </strong></p>
<ul>
<li>1 数字表示月份，去掉前导0</li>
<li>01 数字表示月份，保留前导0</li>
<li>Jan 缩写单词表示月份</li>
<li>January 全单词表示月份</li>
</ul>
<h2 id="u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316"><a href="#u65F6_u95F4_u65E5_u671F_u683C_u5F0F_u5316" class="headerlink" title="时间日期格式化"></a>时间日期格式化</h2><ul>
<li>本地当期时间</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now()) <span class="comment">//2016-07-14 14:27:28.214512532 +0800 CST</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间格式化</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now().Format(<span class="string">"3:04:05.000 PM Mon Jan"</span>))            <span class="comment">// 2:27:05.702 PM Thu Jul</span></span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-_2 3:04:05.000 PM Mon Jan"</span>)) <span class="comment">// 2016-07-14 2:54:11.442 PM Thu Jul</span></span><br><span class="line">fmt.Println(time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))  <span class="comment">// 2016-07-14 14:54:11.442239513 +0800 CST</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地当前时间戳(10位)</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now().Unix()) <span class="comment">//1468479251</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地当前时间戳(19位)</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now().UnixNano()) <span class="comment">//1468480006774460462</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间戳转时间 </li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Unix(<span class="number">1389058332</span>, <span class="number">0</span>).Format(<span class="string">"2006-01-02 15:04:05"</span>)) <span class="comment">//2014-01-07 09:32:12</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间转时间戳</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Date(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">4</span>, <span class="number">0</span>, time.Local).Unix())</span><br></pre></td></tr></table></figure>
<ul>
<li>时间转换为UTC时间和本地时间( UTC:零时区 +0000， China: 东八区 +0800)</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dateStr := <span class="string">"2016-07-14 14:24:51"</span> </span><br><span class="line">timestamp1, _ := time.Parse(<span class="string">"2006-01-02 15:04:05"</span>, dateStr)</span><br><span class="line">timestamp2, _ := time.ParseInLocation(<span class="string">"2006-01-02 15:04:05"</span>, dateStr, time.Local)</span><br><span class="line">fmt.Println(timestamp1, timestamp2)               <span class="comment">//2016-07-14 14:24:51 +0000 UTC 2016-07-14 14:24:51 +0800 CST </span></span><br><span class="line">fmt.Println(timestamp1.Unix(), timestamp2.Unix()) <span class="comment">//1468506291 1468477491 </span></span><br><span class="line"></span><br><span class="line">now := time.Now()                </span><br><span class="line">year, mon, day := now.UTC().Date()</span><br><span class="line">hour, min, sec := now.UTC().Clock()</span><br><span class="line">zone, _ := now.UTC().Zone()     </span><br><span class="line">fmt.Printf(<span class="string">"UTC 时间是 %d-%d-%d %02d:%02d:%02d %s\n"</span>,         </span><br><span class="line">    year, mon, day, hour, min, sec, zone) <span class="comment">// UTC 时间是 2016-7-14 07:06:46 UTC</span></span><br><span class="line">                                                           </span><br><span class="line">year, mon, day = now.Date()</span><br><span class="line">hour, min, sec = now.Clock()</span><br><span class="line">zone, _ = now.Zone()</span><br><span class="line">fmt.Printf(<span class="string">"本地时间是 %d-%d-%d %02d:%02d:%02d %s\n"</span>,</span><br><span class="line">    year, mon, day, hour, min, sec, zone) <span class="comment">// 本地时间是 2016-7-14 15:06:46 CST</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;golang&lt;/code&gt; 中经常需要格式化时间和日期来满足不同的业务需求,下面总结格式化时间日期中遇到的问题。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="time" scheme="http://www.grdtechs.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>Go Vendoring Tools 使用总结</title>
    <link href="http://www.grdtechs.com/2016/05/24/comparison-of-Go-Vendoring-Tools/"/>
    <id>http://www.grdtechs.com/2016/05/24/comparison-of-Go-Vendoring-Tools/</id>
    <published>2016-05-24T14:03:36.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>golang1.5版本开始支持第三方包到依赖管理,当多个项目在同一个<code>GOPATH</code>下，每个项目包含到第三方包通过<code>go get</code>命令都会<code>get</code>到<code>GOPATH</code>下到<code>src</code>目录中，而不是各个项目的文件夹中，这就导致第三方包的不同版本不能同时被<code>GOPATH</code>下到多个项目使用，从<code>golang</code>需要设置<code>GOPATH</code>来看,<code>golang</code>其实把每个项目当作一个个独立的第三包来看待。<br><a id="more"></a><br>关于<code>golang</code>包管理工具的topic, 在<code>golang</code>的官方wiki要有一篇总结对比的文章:<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="external">PackageManagementTools</a>。下面主要就项目中用过的<code>godep</code>,<code>govendor</code>,<code>glide</code>做一个简要的对比分析。</p>
<h2 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h2><p><a href="https://github.com/tools/godep" target="_blank" rel="external">godep</a> helps build packages reproducibly by fixing their dependencies.</p>
<p><strong>前置条件</strong></p>
<ul>
<li>项目处在<code>GOPATH</code>下</li>
<li>项目能被<code>go install</code>通过</li>
<li>项目能被<code>go test</code>通过</li>
</ul>
<p><strong>包初始化管理</strong><br>在项目根目录下执行<code>godep save</code>命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ godep save</span><br></pre></td></tr></table></figure></p>
<p>会在项目根目录下生成两个文件夹: </p>
<p><code>Godeps</code>目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  Godeps tree</span><br><span class="line">.</span><br><span class="line">├── Godeps.json</span><br><span class="line">└── Readme</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">2</span> files</span><br><span class="line">➜  Godeps cat Godeps.json </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"ImportPath"</span>: <span class="string">"yaml"</span>,</span><br><span class="line">	<span class="string">"GoVersion"</span>: <span class="string">"go1.6"</span>,</span><br><span class="line">	<span class="string">"GodepVersion"</span>: <span class="string">"v70"</span>,</span><br><span class="line">	<span class="string">"Packages"</span>: [</span><br><span class="line">		<span class="string">"./..."</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">"Deps"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"ImportPath"</span>: <span class="string">"gopkg.in/yaml.v2"</span>,</span><br><span class="line">			<span class="string">"Rev"</span>: <span class="string">"a83829b6f1293c91addabc89d0571c246397bbf4"</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vendor</code>目录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  vendor tree</span><br><span class="line">.</span><br><span class="line">└── gopkg.in</span><br><span class="line">    └── yaml.v2</span><br><span class="line">        ├── apic.go</span><br><span class="line">        ├── decode.go</span><br><span class="line">        ├── emitterc.go</span><br><span class="line">        ├── encode.go</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── LICENSE.libyaml</span><br><span class="line">        ├── parserc.go</span><br><span class="line">        ├── readerc.go</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── resolve.go</span><br><span class="line">        ├── scannerc.go</span><br><span class="line">        ├── sorter.go</span><br><span class="line">        ├── writerc.go</span><br><span class="line">        ├── yaml.go</span><br><span class="line">        ├── yamlh.go</span><br><span class="line">        └── yamlprivateh.go</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">16</span> files</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>godep</code>把第三包的版本依赖信息记录在<code>Godeps.json</code>下，并且把第三包完整拷贝一份到<code>vendor</code>下面。通过对<code>Godeps.json</code>文件进行版本管理即可以管理整个项目的第三方包依赖信息。</p>
<p><strong>添加新包</strong><br>方法一：</p>
<p>go get 把新增的第三方包get到<code>GOPATH</code>的<code>src</code>目录下，然后再执行<code>godep save</code></p>
<p>方法二：</p>
<p>godep get <url> 同样是把第三方包get到<code>GOPATH</code>的<code>src</code>下，然后再执行<code>godep save</code></url></p>
<p>可以看到<code>godep</code>只是把第三方包进行单独到依赖管理，而新增到第三包还是会被get到<code>GOPATH</code>中, 如果多个项目用同一个第三包的不同版本时，显然不能满足。</p>
<p><strong>更新包</strong><br><code>godep</code>通过<code>godep update</code> 更新制定的第三包以及<code>golang</code>的版本。</p>
<h2 id="govendor"><a href="#govendor" class="headerlink" title="govendor"></a>govendor</h2><p><a href="https://github.com/kardianos/govendor" target="_blank" rel="external">govendor</a> Uses the go1.5+ vendor folder. Multiple workflows supported, single tool.</p>
<p><strong>Quick Start</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setup your project.</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"my project in GOPATH"</span></span><br><span class="line">govendor init</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add existing GOPATH files to vendor.</span></span><br><span class="line">govendor add +external</span><br><span class="line"></span><br><span class="line"><span class="comment"># View your work.</span></span><br><span class="line">govendor list</span><br><span class="line"></span><br><span class="line"><span class="comment"># Look at what is using a package</span></span><br><span class="line">govendor list -v fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a specific version or revision to fetch</span></span><br><span class="line">govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</span><br><span class="line">govendor fetch golang.org/x/net/context@v1   <span class="comment"># Get latest v1.*.* tag or branch.</span></span><br><span class="line">govendor fetch golang.org/x/net/context@=v1  <span class="comment"># Get the tag or branch named "v1".</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Update a package to latest, given any prior version constraint</span></span><br><span class="line">govendor fetch golang.org/x/net/context</span><br></pre></td></tr></table></figure>
<p><strong>Sub-commands</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">init     Create the <span class="string">"vendor"</span> folder and the <span class="string">"vendor.json"</span> file.</span><br><span class="line">    list     List and filter existing dependencies and packages.</span><br><span class="line">    add      Add packages from <span class="variable">$GOPATH</span>.</span><br><span class="line">    update   Update packages from <span class="variable">$GOPATH</span>.</span><br><span class="line">    remove   Remove packages from the vendor folder.</span><br><span class="line">    status   Lists any packages missing, out-of-date, or modified locally.</span><br><span class="line">    fetch    Add new or update vendor folder packages from remote repository.</span><br><span class="line">    sync     Pull packages into vendor folder from remote repository with revisions</span><br><span class="line">                 from vendor.json file.</span><br><span class="line">    migrate  Move packages from a legacy tool to the vendor folder with metadata.</span><br><span class="line">    get      Like <span class="string">"go get"</span> but copies dependencies into a <span class="string">"vendor"</span> folder.</span><br><span class="line">    license  List discovered licenses <span class="keyword">for</span> the given status or import paths.</span><br><span class="line">    shell    Run a <span class="string">"shell"</span> to make multiple sub-commands more efficent <span class="keyword">for</span> large</span><br><span class="line">                 projects.</span><br><span class="line"></span><br><span class="line">    go tool commands that are wrapped:</span><br><span class="line">      `+&lt;status&gt;` package selection may be used with them</span><br><span class="line">    fmt, build, install, clean, <span class="built_in">test</span>, vet, generate</span><br></pre></td></tr></table></figure>
<p><strong>Status</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+<span class="built_in">local</span>    (l) packages <span class="keyword">in</span> your project</span><br><span class="line">    +external (e) referenced packages <span class="keyword">in</span> GOPATH but not <span class="keyword">in</span> current project</span><br><span class="line">    +vendor   (v) packages <span class="keyword">in</span> the vendor folder</span><br><span class="line">    +std      (s) packages <span class="keyword">in</span> the standard library</span><br><span class="line"></span><br><span class="line">    +unused   (u) packages <span class="keyword">in</span> the vendor folder, but unused</span><br><span class="line">    +missing  (m) referenced packages but not found</span><br><span class="line"></span><br><span class="line">    +program  (p) package is a main package</span><br><span class="line"></span><br><span class="line">    +outside  +external +missing</span><br><span class="line">    +all      +all packages</span><br></pre></td></tr></table></figure>
<p>可以看到<code>govendor init</code>之后会在根目录下生成一个<code>vendor</code>文件夹 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  yaml tree <span class="operator">-d</span></span><br><span class="line">.</span><br><span class="line">└── vendor</span><br><span class="line">    ├── github.com</span><br><span class="line">    │   └── cihub</span><br><span class="line">    │       └── seelog</span><br><span class="line">    └── gopkg.in</span><br><span class="line">        └── yaml.v2</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> directories</span><br><span class="line">➜  yaml cat vendor/vendor.json </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"comment"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="string">"ignore"</span>: <span class="string">"test"</span>,</span><br><span class="line">	<span class="string">"package"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"checksumSHA1"</span>: <span class="string">"Nc93Ubautl47L3RP6x4lTY+ud68="</span>,</span><br><span class="line">			<span class="string">"path"</span>: <span class="string">"github.com/cihub/seelog"</span>,</span><br><span class="line">			<span class="string">"revision"</span>: <span class="string">"cedd97ac8c6c2ec413a97864185f9510fb1775cc"</span>,</span><br><span class="line">			<span class="string">"revisionTime"</span>: <span class="string">"2016-05-20T13:10:56Z"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"checksumSHA1"</span>: <span class="string">"+OgOXBoiQ+X+C2dsAeiOHwBIEH0="</span>,</span><br><span class="line">			<span class="string">"path"</span>: <span class="string">"gopkg.in/yaml.v2"</span>,</span><br><span class="line">			<span class="string">"revision"</span>: <span class="string">"a83829b6f1293c91addabc89d0571c246397bbf4"</span>,</span><br><span class="line">			<span class="string">"revisionTime"</span>: <span class="string">"2016-03-01T20:40:22Z"</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="string">"rootPath"</span>: <span class="string">"yaml"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>govendor fetch &lt;url1&gt; &lt;url2&gt;</code>新增的第三方包直接被get到根目录的<code>vendor</code>文件夹下,不会与其它的项目混用第三方包，完美避免多个项目同用同一个第三方包的不同版本问题。</p>
<p>只需要对<code>vendor/vendor.json</code>进行版本控制，即可对第三包依赖关系进行控制。</p>
<h2 id="glide"><a href="#glide" class="headerlink" title="glide"></a>glide</h2><p><a href="https://github.com/Masterminds/glide" target="_blank" rel="external">Glide</a> Vendor Package Management for Golang.</p>
<p><strong>Usage</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  yaml glide --help</span><br><span class="line">USAGE:</span><br><span class="line">   glide [global options] <span class="built_in">command</span> [<span class="built_in">command</span> options] [arguments...]</span><br><span class="line"></span><br><span class="line">	create, init	Initialize a new project, creating a glide.yaml file</span><br><span class="line">    get			Install one or more packages into `vendor/` and add dependency to glide.yaml.</span><br><span class="line">    remove, rm		Remove a package from the glide.yaml file, and regenerate the lock file.</span><br><span class="line">    import		Import files from other dependency management systems.</span><br><span class="line">    name		Print the name of this project.</span><br><span class="line">    novendor, nv	List all non-vendor paths <span class="keyword">in</span> a directory.</span><br><span class="line">    rebuild		Rebuild (<span class="string">'go build'</span>) the dependencies</span><br><span class="line">    install, i		Install a project<span class="string">'s dependencies</span><br><span class="line">    update, up		Update a project'</span>s dependencies</span><br><span class="line">    tree		Tree prints the dependencies of this project as a tree.</span><br><span class="line">    list		List prints all dependencies that the present code references.</span><br><span class="line">    info		Info prints information about this project</span><br><span class="line">    about		Learn about Glide</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --yaml, -y <span class="string">"glide.yaml"</span>	Set a YAML configuration file.</span><br><span class="line">   --quiet, -q			Quiet (no info or debug messages)</span><br><span class="line">   --debug			Print Debug messages (verbose)</span><br><span class="line">   --home <span class="string">"/home/dev/.glide"</span>	The location of Glide files [<span class="variable">$GLIDE_HOME</span>]</span><br><span class="line">   --no-color			Turn off colored output <span class="keyword">for</span> <span class="built_in">log</span> messages</span><br><span class="line">   --help, -h			show <span class="built_in">help</span></span><br><span class="line">   --version, -v		<span class="built_in">print</span> the version</span><br></pre></td></tr></table></figure>
<p><code>glide</code>    通过<code>glide create</code>或<code>glide init</code>命令初始化第三方包管理，会在项目根目录下生成一个<code>glide.yaml</code>，这个文件记录用到的第三方包的依赖关系，支持编辑修改。<br><code>glide</code>通过<code>glide install</code>, 会把所有缺少的第三方包都下载到<code>vendor</code>文件夹下，并且会在<code>glide.yaml</code>中添加所有依赖的第三方包名称，在<code>glide.lock</code>文件中记录具体的版本管理信息。</p>
<p><strong>glide install</strong></p>
<p>When you want to install the specific versions from the glide.lock file use glide install.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ glide install</span><br></pre></td></tr></table></figure>
<p>This will read the <code>glide.lock</code> file and install the commit id specific versions there.</p>
<p>When the glide.lock file doesn’t tie to the <code>glide.yaml</code> file, such as there being a change, it will provide a warning. Running glide up will recreate the <code>glide.lock</code> file when updating the dependency tree.</p>
<p>If no glide.lock file is present glide install will perform an update and generate a lock file.</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>godep</code>,<code>govendor</code>,<code>glide</code> 都可以很好的进行包管理。<code>govendor</code>,<code>glide</code>提供的可操作命令更丰富。</li>
<li><code>godep</code> 会在根目录生成<code>Godeps</code>和<code>vendor</code>两个文件夹; <code>govendor</code>把所有信息都生成在<code>vendor</code>目录下; <code>glide</code> 会在根目录下生成<code>glide.yaml</code>, <code>glide.lock</code>文件及<code>vendor</code>目录; 从<code>简洁度</code>和<code>尽量不污染项目</code>来看，<code>govendor</code>最优，<code>glide</code>次之。</li>
<li><p><code>godep</code>, <code>govendor</code>, <code>glide</code> 都提供get 第三方包的命令，但是 <code>glide</code>的<code>glide install</code> 最为方便， 并且直接把第三方包get到本项目的vendor目录下，并且<code>glide</code>提供的<code>便捷</code>命令也丰富。</p>
</li>
<li><p><strong> 在生产项目中推荐使用<code>govendor</code>, 更简洁; 在试验项目中推荐试用<code>glide</code>, 更方便。</strong></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;golang1.5版本开始支持第三方包到依赖管理,当多个项目在同一个&lt;code&gt;GOPATH&lt;/code&gt;下，每个项目包含到第三方包通过&lt;code&gt;go get&lt;/code&gt;命令都会&lt;code&gt;get&lt;/code&gt;到&lt;code&gt;GOPATH&lt;/code&gt;下到&lt;code&gt;src&lt;/code&gt;目录中，而不是各个项目的文件夹中，这就导致第三方包的不同版本不能同时被&lt;code&gt;GOPATH&lt;/code&gt;下到多个项目使用，从&lt;code&gt;golang&lt;/code&gt;需要设置&lt;code&gt;GOPATH&lt;/code&gt;来看,&lt;code&gt;golang&lt;/code&gt;其实把每个项目当作一个个独立的第三包来看待。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="glide" scheme="http://www.grdtechs.com/tags/glide/"/>
    
      <category term="godep" scheme="http://www.grdtechs.com/tags/godep/"/>
    
      <category term="govendor" scheme="http://www.grdtechs.com/tags/govendor/"/>
    
      <category term="vendoring" scheme="http://www.grdtechs.com/tags/vendoring/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动构建Hexo静态博客</title>
    <link href="http://www.grdtechs.com/2016/05/08/travis-ci-deploy-hexo-blog/"/>
    <id>http://www.grdtechs.com/2016/05/08/travis-ci-deploy-hexo-blog/</id>
    <published>2016-05-08T21:48:40.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。<code>Travis CI</code>就是一个在线的、分布式的持续集成服务，用来构建及测试在GitHub托管的代码。利用Travis CI 会在每一次push后生成一个虚拟机来执行事先安排好的自动构建任务，从来进行发布。本文就要用<code>Travis CI</code>来自动构建<code>Hexo</code>博客。<br><a id="more"></a></p>
<h2 id="u5B89_u88C5Hexo"><a href="#u5B89_u88C5Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ul>
<li>安装cnpm</li>
</ul>
<blockquote>
<p>注意：npm因为qiang的原因，经常会出问题，我换成了taobao的cmpn镜像，taobao的cnpm镜像这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
</blockquote>
<p>安装命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>
<ul>
<li>安装Hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>启动本地的服务器看下是否安装成功<code>hexo s</code>，浏览器打开<a href="http://localhost:4000。" target="_blank" rel="external">http://localhost:4000。</a></p>
<p>到目前为止，Hexo安装完毕，如何配置及发布到<code>github</code>上托管，请参考<a href="http://www.grdtechs.com/2016/01/15/hexo-blog-1/">用Hexo+github搭建本站</a>。本文重点记录如何用<code>Travis CI</code> 自动构建<code>Hexo</code>博客。</p>
<h2 id="u90E8_u7F72Travis_CI"><a href="#u90E8_u7F72Travis_CI" class="headerlink" title="部署Travis CI"></a>部署Travis CI</h2><p>目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。</p>
<ul>
<li>持续集成的概念</li>
</ul>
<p>持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，每人每天可能集成一次，甚至多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。</p>
<p>自动构建工具则是持续集成的一种出色实践。代码提交后，由软件自动完成代码的测试、构建，并将过程中状态与构建物产出才是持续集成的意义。</p>
<ul>
<li>为什么使用</li>
</ul>
<p>Travis CI本身已经是很好的自动构建的工具，而这里使用的原因，本质上是因为Hexo本身并不能进行多人合作。Hexo的hexo generate和hexo deploy会自动渲染并提交到GitHub上，所以当你从别的电脑上clone的时候，clone下来的是渲染好的html的文章。就算我在两个电脑上同时搭建了环境，但是每次渲染的时候只会渲染本地的markdown文章，依然不能进行同步。有些人选择了使用百度云进行同步，每次写之前下载下来并覆盖，就能进行同步。不否认，这个方法对于一个人写博客，在工作和家的电脑还算是比较方便的，因为始终是一个人进行操作。而我们的博客是多人共同写的，所以说会存在各种冲突问题，于是想到了用Travis CI。</p>
<center><img src="/imgs/travis-hexo-flowing.png" alt="travis-hexo-flowing"></center>

<p>从上述流程中分析下思路：<br>前提：我们在之前博客搭建的repo下面，新建一个blog的分支，这个分支用来进行环境代码的备份，并且配置出<code>.travis.yml</code>进行自动化构建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User - push -&gt; branch blog</span><br></pre></td></tr></table></figure>
<p>将代码push到在GitHub上的博客中的blog分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dev repo - sync -&gt; Travis CI</span><br></pre></td></tr></table></figure>
<p>在branch blog中配置<code>.travis.yml</code>文件，在Travis CI中开启branch blog的同步开关，并启用<code>Build only if .travis.yml is present</code>项，这样能在repo中有多个branch时，让Travis CI只构建放置了<code>.travis.yml</code>文件的<code>branch</code>。</p>
<ul>
<li>Travis CI - build and push -&gt; Pages repo</li>
</ul>
<p><code>Travis CI</code> 的自动化构建完全依靠唯一的<code>.travis.yml</code>脚本文件。需要在此文件中添加构建环境、构建Hexo、生成博客及后续push到Pages repo的全部脚本。</p>
<ul>
<li>生成SSH Key<br>要做到<code>Travis CI</code>向<code>Pages repo</code>自动推送就必须用到<code>Github SSH Key</code>，这样做的目的是免去Hexo部署时候输入密码的步骤。生成SSH Key的操作参照GitHub的官网即可：<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="external">Github SSH Key</a>。<br>这样会得到<code>id_rsa.pub</code>和<code>id_rsa</code>两个秘钥，我们将<code>id_rsa.pub</code>添加到了<code>github</code>，下面要加密<code>id_rsa</code>这个私钥并且上传到<code>Travis</code>。</li>
</ul>
<p><strong> 注意：</strong> <font color="red">这个SSH key不应该是你账号的全局SSH Key，这样Travis CI就获得了你所有代码库的提交权限。仅仅只需要把SSH Key添加到当前repo的setting中的key下面即可。</font></p>
<p>即将<code>id_rsa.pub</code>秘钥添加到当前项目<code>researchlab.github.io</code>下<code>Settings</code>下的<code>Deploy keys</code>中，如图:</p>
<center><img src="/imgs/deploy_keys.png" alt="deploy_keys"></center>

<blockquote>
<p>记得要将 <code>Allow write access</code> 的选项选上，这样 Travis CI 才能获得 push 代码的权限。 </p>
</blockquote>
<ul>
<li>Travis CI 环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp ~/.ssh/id_rsa / <span class="comment">#将上一步得到的`id_rsa`复制到当前blog根目录下</span></span><br><span class="line">$ vim .travis.yml <span class="comment">#创建.travis.yml</span></span><br><span class="line">$ gem install travis <span class="comment">#安装Travis CI</span></span><br><span class="line">$ travis login --auto <span class="comment">#登录Travis CI，需要输入GitHub的账号密码</span></span><br><span class="line">$ travis encrypt-file ssh_key --add <span class="comment">#加密私钥并上传至Travis 注意这里的 ssh_key 要换成上面私钥的名称，即: travis encrypt-file id_rsa</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>:<br>gem 的官方源经常被qiang, 所以要注意更换gem sources,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gem sources <span class="comment">#查看原有的官方源</span></span><br><span class="line">gem <span class="built_in">source</span> -r https://rubygems.org/ <span class="comment"># 删除 rubygems 官方源</span></span><br><span class="line">gem <span class="built_in">source</span> <span class="operator">-a</span> http://mirrors.aliyun.com/rubygems/   <span class="comment"># 添加aliyun 源</span></span><br><span class="line">gem install travis --no-rdoc --no-ri --verbose  <span class="comment"># 安装Travis</span></span><br></pre></td></tr></table></figure></p>
<p><strong>生成提示</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">encrypting id_rsa <span class="keyword">for</span> researchlab/researchlab.github.io</span><br><span class="line">storing result as id_rsa.enc</span><br><span class="line">storing secure env variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Make sure to add id_rsa.enc to the git repository.</span><br><span class="line">Make sure not to add id_rsa to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure>
<p>生成加密过得新秘钥<code>id_rsa.enc</code>, 并自动将branch blog中git的信息及解密秘钥的相关信息添加到<code>.travis.yml</code>中。<strong> 然后手动删除私钥文件<code>id_rsa</code>， 以保证代码仓库的安全。</strong></p>
<ul>
<li>SSH的设置<br>在当前目录下新建文件ssh_config，内容为</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure>
<p>修改.travis.yml中的命令，指定openssl解密后的生成位置，xxxxxxxxxx部分就是你的解密参数，不要去改动它。<br>即将<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- openssl aes-<span class="number">256</span>-cbc -K <span class="variable">$encrypted_xxxxxxxxxx_key</span> -iv <span class="variable">$encrypted_xxxxxxxxxx_iv</span></span><br><span class="line">	-in id_rsa.enc -out id_rsa <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- openssl aes-<span class="number">256</span>-cbc -K <span class="variable">$encrypted_xxxxxxxxxx_key</span> -iv <span class="variable">$encrypted_xxxxxxxxxx_iv</span></span><br><span class="line">  -in id_rsa.enc -out ~/.ssh/id_rsa <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改目录权限<br>紧接着在.travis.yml中修改目录权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- chmod <span class="number">600</span> ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<ul>
<li>将密钥加入系统<br>紧接着在.travis.yml中将密钥加入系统</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">- ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<ul>
<li>修改git信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- cp ssh_config ~/.ssh/config</span><br><span class="line">- git config --global user.name <span class="string">"username"</span></span><br><span class="line">- git config --global user.email username@example.com</span><br></pre></td></tr></table></figure>
<ul>
<li>添加分支信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - blog</span><br></pre></td></tr></table></figure>
<ul>
<li>配置Hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">install:</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">- npm install hexo --save</span><br><span class="line">- npm install</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo g </span><br><span class="line">- hexo d</span><br></pre></td></tr></table></figure>
<p>这样就完成了<code>.travis.yml</code>的设置，这里是我的源文件<code>.travis.yml</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: node_js&#10;node_js:&#10;- &#39;0.12&#39;&#10;branches:&#10;  only:&#10;  - blog&#10;before_install:&#10;- openssl aes-256-cbc -K $encrypted_xxxxxxxxxx_key-iv $encrypted_xxxxxxxxxx_iv&#10;  -in id_rsa.enc -out ~/.ssh/id_rsa -d&#10;- chmod 600 ~/.ssh/id_rsa&#10;- eval $(ssh-agent)&#10;- ssh-add ~/.ssh/id_rsa&#10;- cp ssh_config ~/.ssh/config&#10;- git config --global user.name &#34;researchlab&#34;&#10;- git config --global user.email leehongitrd@163.com &#10;- git clone -b master git@github.com:researchlab/researchlab.github.io.git deploy_git&#10;install:&#10;- npm install hexo-cli -g&#10;- npm install&#10;- npm install hexo-generator-feed --save&#10;- npm install hexo-deployer-git --save&#10;script:&#10;- hexo clean&#10;- hexo g&#10;- hexo d</span><br></pre></td></tr></table></figure>
<p>这个时候应该将其push到blog分支,然后就可以了。</p>
<h2 id="u9047_u5230Authentication_failed"><a href="#u9047_u5230Authentication_failed" class="headerlink" title="遇到Authentication failed"></a>遇到Authentication failed</h2><p>提交之后，发现<code>Travis-ci</code> 每次到<code>hexo d</code> 这一步时就报错了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed <span class="keyword">for</span> <span class="string">'https://github.com/researchlab/researchlab.github.io.git/'</span></span><br><span class="line">FATAL Something<span class="string">'s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for '</span>https://github.com/researchlab/researchlab.github.io.git/<span class="string">'</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/home/travis/build/researchlab/researchlab.github.io/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:110:17)</span><br><span class="line">    at maybeClose (child_process.js:1019:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (child_process.js:1091:5)</span><br><span class="line">FATAL remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for '</span>https://github.com/researchlab/researchlab.github.io.git/<span class="string">'</span><br><span class="line">Error: remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for '</span>https://github.com/researchlab/researchlab.github.io.git/<span class="string">'</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/home/travis/build/researchlab/researchlab.github.io/node_modules/hexo-deployer-git/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:110:17)</span><br><span class="line">    at maybeClose (child_process.js:1019:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (child_process.js:1091:5)</span><br><span class="line">The command "hexo d" exited with 2.</span><br><span class="line">cache.2</span><br><span class="line">store build cache</span><br><span class="line">0.00s</span><br><span class="line">2.99schanges detected, packing new archive</span><br><span class="line">FAILED: tar -Pzcf /home/travis/.casher/push.tgz </span><br><span class="line">tar: Cowardly refusing to create an empty archive</span><br><span class="line">Try `tar --help'</span> or `tar --usage<span class="string">' for more information.</span><br><span class="line">uploading archive</span><br><span class="line">failed to upload cache</span><br><span class="line">curl: Can'</span>t open <span class="string">'/home/travis/.casher/push.tgz'</span>!</span><br><span class="line">curl: try <span class="string">'curl --help'</span> or <span class="string">'curl --manual'</span> <span class="keyword">for</span> more information</span><br><span class="line">Done. Your build exited with <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<p>这是因为hexo 根目录下的 <code>_config.yml</code>中配置问题导致的：<br>把如下配置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Deployment&#10;## Docs: https://hexo.io/docs/deployment.html&#10;deploy:&#10;  type: git&#10;  repository: https://github.com/researchlab/researchlab.github.io.git&#10;  branch: master</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Deployment&#10;## Docs: https://hexo.io/docs/deployment.html&#10;deploy:&#10;  type: git&#10;  repository: git@github.com:researchlab/researchlab.github.io.git&#10;  branch: master</span><br></pre></td></tr></table></figure>
<p>问题即解决！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前，自动化构建、持续集成的理念在整个计算行业非常的流行，大家更愿意去使用自动化代替手动，从而提高效率。&lt;code&gt;Travis CI&lt;/code&gt;就是一个在线的、分布式的持续集成服务，用来构建及测试在GitHub托管的代码。利用Travis CI 会在每一次push后生成一个虚拟机来执行事先安排好的自动构建任务，从来进行发布。本文就要用&lt;code&gt;Travis CI&lt;/code&gt;来自动构建&lt;code&gt;Hexo&lt;/code&gt;博客。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.grdtechs.com/categories/Hexo/"/>
    
    
      <category term="Blog" scheme="http://www.grdtechs.com/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://www.grdtechs.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>gin中使用设置cookie过期时间总结</title>
    <link href="http://www.grdtechs.com/2016/03/29/gin-setcookie/"/>
    <id>http://www.grdtechs.com/2016/03/29/gin-setcookie/</id>
    <published>2016-03-29T01:48:56.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>可以操作<code>Cookie</code>的<code>Http</code>头有两个:<code>Set-Cookie</code>和<code>Cookie</code>。<code>Set-Cookie</code>由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个<code>Cookie</code>。<code>Cookie</code>头由客户端发送，包含在<code>HTTP</code>请求的头部中。<br><a id="more"></a></p>
<font color="red"><strong>注意：<br>1.只有cookie的domain和path与请求的URL匹配才会发送这个cookie;<br>2.客户端发送cookie信息给服务器只发送键-值对到服务器，cookie的属性是不会发送给服务器的。</strong></font>

<h2 id="u8BD5_u9A8C_u9700_u6C42"><a href="#u8BD5_u9A8C_u9700_u6C42" class="headerlink" title="试验需求"></a>试验需求</h2><p>1.服务器给客户端设置cookie，并设置过期时间，客户端每次请求服务器时如果cookie没有过期，则服务器将cookie相应的value 加1并重设cookie, 如果cookie 过期，则重新设置cookie让value 从0开始计数。</p>
<h2 id="u8BD5_u9A8C_u4EE3_u7801"><a href="#u8BD5_u9A8C_u4EE3_u7801" class="headerlink" title="试验代码"></a>试验代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Use(Counter()) <span class="comment">//这个是每个请求都会执行Counter()这个方法，</span></span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/counter"</span>, <span class="keyword">func</span>(c *gin.Context) &#123;</span><br><span class="line">		<span class="keyword">if</span> cookie, err := c.Request.Cookie(<span class="string">"counter"</span>); err == <span class="constant">nil</span> &#123;</span><br><span class="line">			c.String(http.StatusOK, cookie.Expires.String())</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			http.SetCookie(c.Writer, &amp;http.Cookie&#123;</span><br><span class="line">				Name:    <span class="string">"counter"</span>,</span><br><span class="line">				Value:   <span class="string">""</span>,</span><br><span class="line">				Expires: time.Now().Add(<span class="number">10</span> * time.Second),</span><br><span class="line">			&#125;)</span><br><span class="line">			c.String(http.StatusOK, <span class="string">"SetCookie ok"</span>)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">"server start from 8010"</span>)</span><br><span class="line">	r.Run(<span class="string">":8010"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Counter() gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">func</span>(c *gin.Context) &#123;</span><br><span class="line">		<span class="keyword">if</span> cookie, err := c.Request.Cookie(<span class="string">"counter"</span>); err == <span class="constant">nil</span> &#123;</span><br><span class="line">			value := cookie.Value</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(value) == <span class="number">0</span> &#123;</span><br><span class="line">				cookie.Value = <span class="string">"0"</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> v, err := strconv.Atoi(value); err == <span class="constant">nil</span> &#123;</span><br><span class="line">					i := v + <span class="number">1</span></span><br><span class="line">					cookie.Value = fmt.Sprintf(<span class="string">"%d"</span>, i)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			http.SetCookie(c.Writer, cookie)</span><br><span class="line">			<span class="comment">//before request</span></span><br><span class="line">			c.Next()</span><br><span class="line">			<span class="comment">//after request</span></span><br><span class="line">			c.String(http.StatusOK, <span class="string">" counter:"</span>+cookie.Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4EE3_u7801_u5206_u6790"><a href="#u4EE3_u7801_u5206_u6790" class="headerlink" title="代码分析"></a>代码分析</h2><p>上述代码中<code>r.Use(Counter())</code>表示客户端每次发送一个请求给服务器，都会执行<code>Counter()</code>这个函数。比如客户端发送一个<code>http://localhost:8010/counter</code>的请求给服务器，则具体的处理流程为：先执行<code>Counter()</code>函数中的<code>c.Next()</code>前面的代码，当执行到<code>c.Next()</code>时， 先去执行<code>r.GET(&quot;/counter&quot;,func(c *gin.Context) {xxx}</code>中<code>xxx</code>程序体，当<code>xxx</code>程序体执行完之后，再执行<code>Counter()</code>函数中<code>c.Next()</code>之后的程序体，然后整个请求执行完毕。</p>
<p>回到上面的试验需求，第一次请求时没有cookie，此时服务器设置cookie并设置过期时间，第二次请求时如果还没有过期则在Counter中就能查到cookie,此时通过<code>Counter()</code>重新设置cookie, 但是注意：这里设置的cookie，因为Name与之前的cookie是一样的，所以此次设置的cookie的属性会覆盖之前的cookie的属性，因为此次只是改变cookie的value，而没有设置cookie的属性，所以此次设置cookie没有过期时间可言了。所以上述的试验需求是不合理的。或者说可以通过<code>redis</code>的操作去实现，但是不能仅靠设置<code>cookie</code>来实现这个需求。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><strong>服务器发送cookie给客户端</strong><br> 从服务器端，发送cookie给客户端，是对应的Set-Cookie。包括了对应的cookie的名称，值，以及各个属性。<br> 例如：<br>Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.169it.com; HttpOnly<br>Set-Cookie: made_write_conn=1295214458; Path=/; Domain=.169it.com<br>Set-Cookie: reg_fb_gate=deleted; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Path=/; Domain=.169it.com; HttpOnly</p>
<p><strong>从客户端把cookie发送到服务器</strong><br> 从客户端发送cookie给服务器的时候，是不发送cookie的各个属性的，而只是发送对应的名称和值。<br> 例如：<br>GET /spec.html HTTP/1.1<br>Host: www.example.org<br>Cookie: name=value; name2=value2<br>Accept: <em>/</em>  </p>
<font color="red">除了name=value对以外，我们还可以设置Cookie其他属性以支持更丰富的Cookie需求，<strong>这些属性通常是浏览器用来判断如何对待cookie，何时删除、屏蔽或者如何发送name-value对给Server。也就是说无论我们设置了某个cookie的多少属性，这些Cookie属性是不会被浏览器发送回给Server的。包括设置的过期时间也不会发送到服务器端</strong></font>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;可以操作&lt;code&gt;Cookie&lt;/code&gt;的&lt;code&gt;Http&lt;/code&gt;头有两个:&lt;code&gt;Set-Cookie&lt;/code&gt;和&lt;code&gt;Cookie&lt;/code&gt;。&lt;code&gt;Set-Cookie&lt;/code&gt;由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个&lt;code&gt;Cookie&lt;/code&gt;。&lt;code&gt;Cookie&lt;/code&gt;头由客户端发送，包含在&lt;code&gt;HTTP&lt;/code&gt;请求的头部中。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="gin" scheme="http://www.grdtechs.com/tags/gin/"/>
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="setcookie" scheme="http://www.grdtechs.com/tags/setcookie/"/>
    
  </entry>
  
  <entry>
    <title>golang类型转换(指定精度/四舍五入)</title>
    <link href="http://www.grdtechs.com/2016/03/24/go-type-convert/"/>
    <id>http://www.grdtechs.com/2016/03/24/go-type-convert/</id>
    <published>2016-03-24T02:06:54.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>Go</code>的数据类型很多都需要显示转换才能使用,比如<code>string</code>转<code>float64</code>指定精度等。转换中常用到的第三方包为<code>strconv</code>和<code>math</code>包。<br><a id="more"></a></p>
<h2 id="u6574_u578B_u8F6C_u5B57_u7B26_u4E32"><a href="#u6574_u578B_u8F6C_u5B57_u7B26_u4E32" class="headerlink" title="整型转字符串"></a>整型转字符串</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strconv.Itoa(i) <span class="comment">//方法1</span></span><br><span class="line">strconv.FormatInt(<span class="typename">int64</span>(i),<span class="number">10</span>) <span class="comment">//方法2</span></span><br></pre></td></tr></table></figure>
<h2 id="u5B57_u7B26_u4E32_u8F6C_u6574_u578B"><a href="#u5B57_u7B26_u4E32_u8F6C_u6574_u578B" class="headerlink" title="字符串转整型"></a>字符串转整型</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strconv.Atoi(s) <span class="comment">//方法1</span></span><br><span class="line">strconv.ParseInt(s,<span class="number">10</span>,<span class="number">0</span>) <span class="comment">//方法2</span></span><br></pre></td></tr></table></figure>
<h2 id="bytes_u8F6Cfloat64"><a href="#bytes_u8F6Cfloat64" class="headerlink" title="bytes转float64"></a>bytes转float64</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> bytesToFloat64(bytes []<span class="typename">byte</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	bits := binary.LittleEndian.Uint64(bytes)</span><br><span class="line">	<span class="keyword">return</span> math.Float64frombits(bits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="float64_u8F6Cbytes"><a href="#float64_u8F6Cbytes" class="headerlink" title="float64转bytes"></a>float64转bytes</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> float64ToBytes(input <span class="typename">float64</span>) []<span class="typename">byte</span> &#123;</span><br><span class="line">	bits := math.Float64bits(input)</span><br><span class="line">	bytes := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number">8</span>) <span class="comment">//这里表示[]uint8, 所以用了 8</span></span><br><span class="line">	binary.LittleEndian.PutUint64(bytes,bits)</span><br><span class="line">	<span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="float64_u8F6Cstring"><a href="#float64_u8F6Cstring" class="headerlink" title="float64转string"></a>float64转string</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> FloatToStr(num <span class="typename">float64</span>, floatPartLen <span class="typename">int</span>) <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.FormatFloat(num,<span class="string">'f'</span>,floatPartLen,<span class="number">64</span>) <span class="comment">//这里64改为32，则表示float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string_u8F6Cfloat64"><a href="#string_u8F6Cfloat64" class="headerlink" title="string转float64"></a>string转float64</h2><p><code>string</code>转<code>float64</code> 这里有两种方法，都支持指定精度。<strong> 注意：所有数字要在表现层显示最好转换为字符串传送给表现层，如果用于后端计算则转换为数字即可。比如：数字2.10 如果用保持5位数字精度显示： 那么 数字2.10 显示为：2.1, 而将2.10转换为字符串同时保持5位精度，则显示为: 2.10000。但是它们都是转换为了5位精度的，只是显示的时候，数字2.10000 直接显示为2.1了， 所以要显示精度则转换为字符串，要用于计算则转换为数字。</strong></p>
<p>方法1： 只支持指定精度<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> strToFloat64(str <span class="typename">string</span>, <span class="built_in">len</span> <span class="typename">int</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	lenstr := <span class="string">"%."</span> + strconv.Itoa(<span class="built_in">len</span>) + <span class="string">"f"</span></span><br><span class="line">	value,_ := strconv.ParseFloat(str,<span class="number">64</span>)</span><br><span class="line">	nstr := fmt.Sprintf(lenstr,value)</span><br><span class="line">	val,_ := strconv.ParseFloat(nstr,<span class="number">64</span>)</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法2：支持指定精度，支持是否四舍五入<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> strToFloat64Round(str <span class="typename">string</span>, prec <span class="typename">int</span>, round <span class="typename">bool</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	f,_ := strconv.ParseFloat(str,<span class="number">64</span>)</span><br><span class="line">	<span class="keyword">return</span> Precision(f,prec,round)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Precision(f <span class="typename">float64</span>, prec <span class="typename">int</span>, round <span class="typename">bool</span>) <span class="typename">float64</span> &#123;</span><br><span class="line">	pow10_n := math.Pow10(prec)</span><br><span class="line">	<span class="keyword">if</span> round &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Trunc(f + <span class="number">0.5</span>/pow10_n)*pow10_n) / pow10_n	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> math.Trunc((f)*pow10_n) / pow10_n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体请参考[<a href="https://github.com/researchlab/golearning/blob/master/base/convert.go" target="_blank" rel="external">示例代码</a>]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;的数据类型很多都需要显示转换才能使用,比如&lt;code&gt;string&lt;/code&gt;转&lt;code&gt;float64&lt;/code&gt;指定精度等。转换中常用到的第三方包为&lt;code&gt;strconv&lt;/code&gt;和&lt;code&gt;math&lt;/code&gt;包。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 设计模式之observer使用总结</title>
    <link href="http://www.grdtechs.com/2016/02/26/observer-pattern-in-go-md/"/>
    <id>http://www.grdtechs.com/2016/02/26/observer-pattern-in-go-md/</id>
    <published>2016-02-26T00:40:11.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>观察者(<code>Observer</code>)设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。观察者模式将观察者和被观察的对象分离开,体现了面向对象设计中一个对象只做一件事情的原则，提高了应用程序的可维护性和重用性。<br><a id="more"></a></p>
<h2 id="u5B9E_u73B0_u89C2_u5BDF_u8005_u6A21_u5F0F"><a href="#u5B9E_u73B0_u89C2_u5BDF_u8005_u6A21_u5F0F" class="headerlink" title="实现观察者模式"></a>实现观察者模式</h2><p>观察者模式有很多实现方式，从根本上说，该模式必须包含两个角色：观察者(Observer)和被观察对象(Subject)。</p>
<p><center><img src="/imgs/observer_pattern.jpg" alt="observer_pattern"></center></p>
<ul>
<li><p>观察者<br>观察者（<code>Observer</code>）将自己注册到被观察对象（<code>Subject</code>）中，被观察对象将观察者存放在一个容器（<code>Container</code>）里。</p>
</li>
<li><p>被观察<br>被观察对象(<code>Subject</code>)发生了某种变化，从容器中得到所有注册过的观察者，将变化通知观察者(<code>notifyObservers</code>)。</p>
</li>
<li><p>撤销观察<br>观察者告诉被观察者要撤销观察，被观察者从容器中将观察者去除。<br><strong>观察者将自己注册到被观察者的容器中时，被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口。</strong>这样的优点是：假定程序中还有别的观察者，那么只要这个观察者也是相同的接口实现即可。一个被观察者可以对应多个观察者，当被观察者发生变化的时候，它可以将消息一一通知给所有的观察者。基于接口，而不是具体的实现——这一点为程序提供了更大的灵活性。<br>下面通过构建一个股民(<code>Observer</code>)和他们关注的某支具体股票(<code>Subject</code>)案例分析,<br>首先观察者(<code>Observer</code>)要能注册/注销到某个被观察者(<code>Subject</code>)中，同时被观察者(<code>Subject</code>)发送变化时要能够通知到依赖它的观察者(<code>Observer</code>),由此我们需要声明一个被观察者(<code>Subject</code>)的接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subject被观察者接口</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">	Attach(Observer)</span><br><span class="line">	Detach(Observer)</span><br><span class="line">	Notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>遵循被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口的原则，当被观察者(<code>Subject</code>)因自身改变通知观察者(<code>Observer</code>)改变时，应提供一个观察者(<code>Observer</code>)接口供被观察者(<code>Subject</code>)调用:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer观察者</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Update(Subject, <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口设计好之后，就需要通过具体的对象来实现这些接口，在这个案例中假定股民关注的是中国石油这只股票，那么股票就是观察者(<code>Observer</code>),而中国石油股票则是被观察者(<code>Subject</code>),具体结构如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体observer观察者</span></span><br><span class="line"><span class="keyword">type</span> Investors <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/*投资人*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体subject被观察者</span></span><br><span class="line"><span class="keyword">type</span> ChinaPetroleum <span class="keyword">struct</span> &#123;</span><br><span class="line">	oblist []Observer <span class="comment">//注册者链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;观察者(&lt;code&gt;Observer&lt;/code&gt;)设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。观察者模式将观察者和被观察的对象分离开,体现了面向对象设计中一个对象只做一件事情的原则，提高了应用程序的可维护性和重用性。&lt;br&gt;
    
    </summary>
    
      <category term="go-pattern" scheme="http://www.grdtechs.com/categories/go-pattern/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="observer" scheme="http://www.grdtechs.com/tags/observer/"/>
    
  </entry>
  
  <entry>
    <title>golang 设计模式之singleton使用总结</title>
    <link href="http://www.grdtechs.com/2016/02/25/singleton-pattern-in-go/"/>
    <id>http://www.grdtechs.com/2016/02/25/singleton-pattern-in-go/</id>
    <published>2016-02-25T17:01:43.000Z</published>
    <updated>2016-11-23T06:28:51.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>golang</code> 1.5版本之后默认设置<code>GOMAXPROCS</code>值为当前计算机真实核心数，使得<code>goroutines</code>从默认的<code>单线程内并发执行</code>变成了默认的（真实核心数支持的）的<code>多线程内并行</code>执行。多线程并行执行<code>goroutines</code>需要考虑并行执行过程中引入的<code>线程安全问题</code>。<br><a id="more"></a></p>
<h2 id="u5355_u7EBF_u7A0Bsingleton_u6A21_u578B"><a href="#u5355_u7EBF_u7A0Bsingleton_u6A21_u578B" class="headerlink" title="单线程singleton模型"></a>单线程singleton模型</h2><p>单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。先摘取一个在实际工作项目中碰到的singleton模型代码:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="constant">nil</span> &#123;</span><br><span class="line">       instance = &amp;singleton&#123;&#125;   <span class="comment">// 没有考虑线程安全 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>singleton</code>设计代码在见过的几个<code>golang</code>项目中都是这么写的，如果这段代码放在<code>golang</code>1.5版本之前默认的单线程场景下运行显然是没什么问题的。<code>golang</code>1.5版本之后默认是启动多核并行执行<code>goroutines</code>的，如果上述代码放在<code>golang</code>1.5版本之后，如果程序开启n个<code>goroutines</code>初始化一个<code>singleton</code>对象, 显然会初始化成功最少一个最多n个<code>singleton</code>对象，从而会存在潜在的多个单例实例对象了，也就不可能保证这个<code>singleton</code>对象全局唯一性了，那后继采用<code>singleton</code>对象进行全局唯一性操作时势必会造成数据不一致的问题。如果场景中但个<code>goroutines</code>执行时间短的话，会使得调试更难。</p>
<h2 id="u91C7_u7528_u4E92_u65A5_u9501_u673A_u5236"><a href="#u91C7_u7528_u4E92_u65A5_u9501_u673A_u5236" class="headerlink" title="采用互斥锁机制"></a>采用互斥锁机制</h2><p>面对上述线程安全问题，一般会考虑到用锁机制(<code>Mutex</code>)来解决因线程安全引入的数据不一致问题，采用锁机制如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu Sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">    mu.Lock()                    <span class="comment">// singleton实例对象操作之后，锁就是多余的了 </span></span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="constant">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码可以看到，引入锁机制<code>Sync.Mutex</code>后，能够保证多线程并行执行<code>goroutines</code>创建的<code>singleton</code>实例对象是唯一的，但是当这个<code>singleton</code>实例对象被初始化创建之后，再次并行来创建<code>singleton</code>实例对象时，其实已经不再需要锁了，因为已经存在了一个创建好的<code>singleton</code>实例对象，所以直接返回即可;但是因为锁机制的存在，使得再次创建<code>singleton</code>实例对象时，还是需要先获取锁，然后在判断处理，多线程执行中这种锁竞争使得多线程的并行执行变成了多线程的串行执行，这显然会使程序丧失并行执行带来的性能提升。在一个高度并行的程序中，这样显示会是抑制程序性能提升的一个瓶颈。</p>
<h2 id="u91C7_u7528_u53CC_u91CD_u68C0_u67E5_u9501_u673A_u5236"><a href="#u91C7_u7528_u53CC_u91CD_u68C0_u67E5_u9501_u673A_u5236" class="headerlink" title="采用双重检查锁机制"></a>采用双重检查锁机制</h2><p>在<code>C++</code>等编程语言中，为了同时保证最小锁和线程安全通常采用的方法是<code>双重检查锁(Check-Lock-Check)</code>机制，也表述为<code>DCL(Double Check Lock)</code>。<code>双重检查锁</code>机制的伪代码一般是下面的这种形式:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> check() &#123;</span><br><span class="line">    lock() &#123;</span><br><span class="line">       <span class="keyword">if</span> check() &#123;</span><br><span class="line">           <span class="comment">// 锁安全代码 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实对这个<code>singleton</code>实例对象来说，只有在第一次创建实例的时候才需要同步，所以为了减少同步，先check一下，判断<code>singleton</code>实例对象是否为空，如果为空，表示是第一使用这个<code>singleton</code>实例对象，那就锁住它，new一个<code>singleton</code>实例，下次另一个线程来<code>GetInstance</code>的时候，看到这个<code>singleton</code>实例对象不为空，就表示已经创建过一个实例了，那就可以直接得到这个实例，避免再次锁。这是第一个 check的作用。 </p>
<p>第二个check是解决锁竞争情况下的问题，假设现在两个线程来请求<code>GetInstance</code>，A、B线程同时发现<code>singleton</code>实例对象为空，因为我们在第一次check方法上没有加锁，然后A线程率先获得锁，进入同步代码块，new了一个<code>singleton</code>实例对象，之后释放锁，接着B线程获得了这个锁，发现<code>singleton</code>实例对象已经被创建了，就直接释放锁，退出同步代码块。所以这就是<code>Check-Lock-Check</code>; 将上面的<code>singleton</code>实例用<code>Check-Lock-Check</code>机制实现如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="constant">nil</span> &#123; </span><br><span class="line">        mu.Lock()</span><br><span class="line">        <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> instance == <span class="constant">nil</span> &#123;</span><br><span class="line">	            instance = &amp;singleton&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的<code>Check-Lock-Check</code>机制,的确可以解决锁竟争的问题，但是这种方法不管是否<code>singleton</code>实例对象是否已创建，每次都要执行两次check才是一个完整的判断，那有没有方法使得只要一次check就可以完成对<code>singleton</code>实例对象是否存在的检查呢？ 有！通过<code>golang</code>的<code>sync/atomic</code>包提供的原子性操作可以更高效的完成这个检查，改进代码如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync/atomic"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialized <span class="typename">uint32</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> atomic.LoadUInt32(&amp;initialized) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initialized == <span class="number">0</span> &#123;</span><br><span class="line">         instance = &amp;singleton&#123;&#125;</span><br><span class="line">         atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改进之后的代码通过设置一个标志操作，使得<code>singleton</code>实例对象创建之后，直接通过原子操作读取标志字段的值判断返回已经存在的实例，连锁操作及其后面的代码都略过了。</p>
<h2 id="u91C7_u7528atomic_u8FDB_u4E00_u6B65_u7B80_u5316"><a href="#u91C7_u7528atomic_u8FDB_u4E00_u6B65_u7B80_u5316" class="headerlink" title="采用atomic进一步简化"></a>采用atomic进一步简化</h2><p>上面通过<code>Check-Lock-Check</code>机制改进之后似乎没有什么可做的了，先不急，来看看<code>golang</code>原生标准包<code>sync</code>包中对<code>Once</code>实现的源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	m    Mutex</span><br><span class="line">	done <span class="typename">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do calls the function f if and only if Do is being called for the</span></span><br><span class="line"><span class="comment">// first time for this instance of Once. In other words, given</span></span><br><span class="line"><span class="comment">//	var once Once</span></span><br><span class="line"><span class="comment">// if once.Do(f) is called multiple times, only the first call will invoke f,</span></span><br><span class="line"><span class="comment">// even if f has a different value in each invocation.  A new instance of</span></span><br><span class="line"><span class="comment">// Once is required for each function to execute.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do is intended for initialization that must be run exactly once.  Since f</span></span><br><span class="line"><span class="comment">// is niladic, it may be necessary to use a function literal to capture the</span></span><br><span class="line"><span class="comment">// arguments to a function to be invoked by Do:</span></span><br><span class="line"><span class="comment">//	config.once.Do(func() &#123; config.init(filename) &#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because no call to Do returns until the one call to f returns, if f causes</span></span><br><span class="line"><span class="comment">// Do to be called, it will deadlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, Do considers it to have returned; future calls of Do return</span></span><br><span class="line"><span class="comment">// without calling f.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">func</span> (o *Once) Do(f <span class="keyword">func</span>()) &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> &#123; <span class="comment">// &lt;-- Check</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow-path.</span></span><br><span class="line">	o.m.Lock()                           <span class="comment">// &lt;-- Lock</span></span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;                     <span class="comment">// &lt;-- Check</span></span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们之前其实是借鉴了<code>golang</code>原生标准包<code>sync</code>中对<code>Once</code>实现对源码，那既然标准包中已经实现了这个<code>Check-Lock-Check</code>机制，那我们直接调用<code>sync</code>包提供<code>once.Do()</code>方法对某个方法只进行一次性调用：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">once.Do(<span class="keyword">func</span>() &#123;</span><br><span class="line">	 <span class="comment">// perform safe initialization here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么下面是根据<code>sync</code>包提供的<code>sync.Once</code>改进的获取<code>singleton</code>实例对象最终优化版本:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GetInstance() *singleton &#123;</span><br><span class="line">    once.Do(<span class="keyword">func</span>() &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此使用<code>sync</code>包提供的<code>sync.Once</code>实现获取<code>singleton</code>实例对象可以说是最安全有效又简洁的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;golang&lt;/code&gt; 1.5版本之后默认设置&lt;code&gt;GOMAXPROCS&lt;/code&gt;值为当前计算机真实核心数，使得&lt;code&gt;goroutines&lt;/code&gt;从默认的&lt;code&gt;单线程内并发执行&lt;/code&gt;变成了默认的（真实核心数支持的）的&lt;code&gt;多线程内并行&lt;/code&gt;执行。多线程并行执行&lt;code&gt;goroutines&lt;/code&gt;需要考虑并行执行过程中引入的&lt;code&gt;线程安全问题&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="go-pattern" scheme="http://www.grdtechs.com/categories/go-pattern/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="singleton" scheme="http://www.grdtechs.com/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>golang 并发安全性案例分析</title>
    <link href="http://www.grdtechs.com/2016/02/24/go-concurrency-security/"/>
    <id>http://www.grdtechs.com/2016/02/24/go-concurrency-security/</id>
    <published>2016-02-24T21:47:55.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p><code>golang</code> 在1.5版本之前默认只使用一个核心来跑所有的<code>goroutines</code>,即<code>GOMAXPROCS</code>默认设置为1, ,即是串行执行<code>goroutines</code>,在1.5版本后，<code>GOMAXPROCS</code>默认设置为当前计算机真实的核心线程数，即是在并行执行<code>goroutines</code>。<br><a id="more"></a></p>
<h2 id="u5E76_u884C_u6267_u884C_u5B89_u5168_u6027_u6848_u4F8B_u5206_u6790"><a href="#u5E76_u884C_u6267_u884C_u5B89_u5168_u6027_u6848_u4F8B_u5206_u6790" class="headerlink" title="并行执行安全性案例分析"></a>并行执行安全性案例分析</h2><p>利用计算机多核处理的特性，并行执行能成倍的提高程序的性能,但同时也带入了数据安全性问题，下面看一个在线银行转账的案例:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">		Cash <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (u *User) sendCash(to *User, amount <span class="typename">int</span>) <span class="typename">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> u.Cash &lt; amount &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */</span></span><br><span class="line">	time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	u.Cash = u.Cash - amount</span><br><span class="line">	to.Cash = to.Cash + amount</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	me := User&#123;Cash: <span class="number">500</span>&#125;</span><br><span class="line">	you := User&#123;Cash: <span class="number">500</span>&#125;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">		me.sendCash(&amp;you, <span class="number">50</span>) <span class="comment">//转账</span></span><br><span class="line">		fmt.Fprintf(w, <span class="string">"I have $%d\n"</span>, me.Cash)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"You have $%d\n"</span>, you.Cash)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Total transferred: $%d\n"</span>, (you.Cash - <span class="number">500</span>))</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个通用的Go Web应用，定义User数据结构，sendCash是在两个User之间转账的服务，这里使用的是net/http 包，我们创建了一个简单的Http服务器，然后将请求路由到转账50元的sendCash方法，在正常操作下，代码会如我们预料一样运行，每次转移50美金，一旦一个用户的账户余额达到0美金，就不能再进行转出钞票了，因为没有钱了，但是，如果我们很快地发送很多请求，这个程序会继续转出很多钱，导致账户余额为负数。</p>
<p>这是课本上经常谈到的竞争情况race condition，在这个代码中，账户余额的检查是与从账户中取钱操作分离的，我们假想一下，如果一个请求刚刚完成账户余额检查，但是还没有取钱，也就是没有减少账户余额数值；而另外一个请求线程同时也检查账户余额，发现账户余额还没有剩为零（结果两个请求都一起取钱，导致账户余额为负数），这是典型的”check-then-act”竞争情况。这是很普遍存在的 并发 bug。</p>
<h2 id="u7528_u9501_u89E3_u51B3_u7ADF_u6001_u6570_u636E_u5B89_u5168_u95EE_u9898"><a href="#u7528_u9501_u89E3_u51B3_u7ADF_u6001_u6570_u636E_u5B89_u5168_u95EE_u9898" class="headerlink" title="用锁解决竟态数据安全问题"></a>用锁解决竟态数据安全问题</h2><p>那么我们如何解决呢？我们肯定不能移除检查操作，而是确保检查和取钱两个动作之间没有任何其他操作发生，其他语言是使用锁，当账户进行更新时，锁住禁止同时有其他线程操作，确保一次只有一个进程操作，也就是排斥锁Mutex。,下面用<code>golang</code>自带的<code>sync</code>包实现对转账判断及数据操作过程的加锁：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">		Cash <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transferLock *sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (u *User) sendCash(to *User, amount <span class="typename">int</span>) <span class="typename">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">	transferLock.Lock() <span class="comment">//对转账操作进行加锁</span></span><br><span class="line">	<span class="keyword">defer</span> transferLock.Unlock() <span class="comment">//转账结束后解锁释放资源</span></span><br><span class="line">	<span class="keyword">if</span> u.Cash &lt; amount &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */</span></span><br><span class="line">	time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	u.Cash = u.Cash - amount</span><br><span class="line">	to.Cash = to.Cash + amount</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	me := User&#123;Cash: <span class="number">500</span>&#125;</span><br><span class="line">	you := User&#123;Cash: <span class="number">500</span>&#125;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">		me.sendCash(&amp;you, <span class="number">50</span>) <span class="comment">//转账</span></span><br><span class="line">		fmt.Fprintf(w, <span class="string">"I have $%d\n"</span>, me.Cash)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"You have $%d\n"</span>, you.Cash)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Total transferred: $%d\n"</span>, (you.Cash - <span class="number">500</span>))</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5229_u7528Channel_2C_u66F4_u597D_u7684_u5B9E_u73B0_u5E76_u53D1"><a href="#u5229_u7528Channel_2C_u66F4_u597D_u7684_u5B9E_u73B0_u5E76_u53D1" class="headerlink" title="利用Channel,更好的实现并发"></a>利用Channel,更好的实现并发</h2><p>但是锁的问题很显然降低了<code>程序并发的性能</code>，锁是并发设计的最大敌人，在Go中推荐使用通道<code>Channel</code>，能够使用事件循环event loop机制更灵活地实现并发;通过委托一个后台协程监听通道，当通道中有数据时，立即进行转账操作，因为协程是顺序地读取通道中的数据，也就是巧妙地回避了竞争情况，没有必要使用任何状态变量防止<code>并发</code>竞争了。 具体示例:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cash <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Transfer <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sender    *User</span><br><span class="line">	Recipient *User</span><br><span class="line">	Amount    <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> sendCashHandler(transferchan <span class="keyword">chan</span> Transfer) &#123;</span><br><span class="line">	<span class="keyword">var</span> val Transfer</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		val = &lt;-transferchan</span><br><span class="line">		val.Sender.sendCash(val.Recipient, val.Amount)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (u *User) sendCash(to *User, amount <span class="typename">int</span>) <span class="typename">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> u.Cash &lt; amount &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="constant">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */</span></span><br><span class="line">	time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	u.Cash = u.Cash - amount</span><br><span class="line">	to.Cash = to.Cash + amount</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	me := User&#123;Cash: <span class="number">500</span>&#125;</span><br><span class="line">	you := User&#123;Cash: <span class="number">500</span>&#125;</span><br><span class="line">	transferchan := <span class="built_in">make</span>(<span class="keyword">chan</span> Transfer)</span><br><span class="line">	<span class="keyword">go</span> sendCashHandler(transferchan)</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">		transfer := Transfer&#123;Sender: &amp;me, Recipient: &amp;you, Amount: <span class="number">50</span>&#125;</span><br><span class="line">		transferchan &lt;- transfer</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"I have $%d\n"</span>, me.Cash)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"You have $%d\n"</span>, you.Cash)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Total transferred: $%d\n"</span>, (you.Cash - <span class="number">500</span>))</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":8080"</span>, <span class="constant">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码创建了比较可靠的系统从而避免了<code>并发</code>竞争，但是我们会带来另外一个安全问题：<code>DoS(Denial of Service服务拒绝)</code>，如果我们的转账操作慢下来，那么不断进来的请求需要等待进行转账操作的那个协程从通道中读取新数据，但是这个线程忙于照顾转账操作，没有闲功夫读取通道中新数据，这个情况会导致系统容易遭受<code>DoS攻击</code>，外界只要发送大量请求就能让系统停止响应。</p>
<h2 id="u796D_u51FAselect__u8FDB_u4E00_u6B65_u63D0_u5347_u6027_u80FD"><a href="#u796D_u51FAselect__u8FDB_u4E00_u6B65_u63D0_u5347_u6027_u80FD" class="headerlink" title="祭出select 进一步提升性能"></a>祭出select 进一步提升性能</h2><p>一些基础机制比如buffered channel可以处理这种情况，但是buffered channel是有内存上限的，不足够保存所有请求数据，优化解决方案是使用Go杰出的<code>select</code>语句：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	 transfer := Transfer&#123;Sender: &amp;me, Recipient: &amp;you, Amount: <span class="number">50</span>&#125;</span><br><span class="line">	 <span class="comment">/*转账*/</span></span><br><span class="line">	 result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)</span><br><span class="line">	 <span class="keyword">go</span> <span class="keyword">func</span>(transferchan <span class="keyword">chan</span>&lt;- Transfer, transfer Transfer, result <span class="keyword">chan</span>&lt;- <span class="typename">int</span>) &#123;</span><br><span class="line">	      transferchan &lt;- transfer</span><br><span class="line">	      result &lt;- <span class="number">1</span></span><br><span class="line">	 &#125;(transferchan, transfer, result)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*用select来处理超时机制*/</span>	 </span><br><span class="line">	 <span class="keyword">select</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> &lt;-result:</span><br><span class="line">	    fmt.Fprintf(w, <span class="string">"I have $%d\n"</span>, me.Cash)</span><br><span class="line">	    fmt.Fprintf(w, <span class="string">"You have $%d\n"</span>, you.Cash)</span><br><span class="line">	    fmt.Fprintf(w, <span class="string">"Total transferred: $%d\n"</span>, (you.Cash - <span class="number">500</span>))</span><br><span class="line">	  <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">10</span>): <span class="comment">//超时处理</span></span><br><span class="line">	    fmt.Fprintf(w, <span class="string">"Your request has been received, but is processing slowly"</span>)</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里提升了事件循环，等待不能超过10秒，等待超过timeout时间，会返回一个消息给User告诉它们请求已经接受，可能会花点时间处理，请耐心等候即可，使用这种方法我们降低了<code>DoS攻击</code>可能，一个真正健壮的能够<code>并发</code>处理转账且没有使用任何锁的系统诞生了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;golang&lt;/code&gt; 在1.5版本之前默认只使用一个核心来跑所有的&lt;code&gt;goroutines&lt;/code&gt;,即&lt;code&gt;GOMAXPROCS&lt;/code&gt;默认设置为1, ,即是串行执行&lt;code&gt;goroutines&lt;/code&gt;,在1.5版本后，&lt;code&gt;GOMAXPROCS&lt;/code&gt;默认设置为当前计算机真实的核心线程数，即是在并行执行&lt;code&gt;goroutines&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="concurrency" scheme="http://www.grdtechs.com/tags/concurrency/"/>
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 并发concurrency 使用总结</title>
    <link href="http://www.grdtechs.com/2016/02/17/go-concurrency-summarize/"/>
    <id>http://www.grdtechs.com/2016/02/17/go-concurrency-summarize/</id>
    <published>2016-02-17T13:47:51.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>go能处理高并发的根本原因在于执行go协程只需极少的栈内存(大概4~5KB),并且能根据需要动态增长和缩减占用的资源。<br><a id="more"></a></p>
<h2 id="u9AD8_u5E76_u53D1_u7684_u672C_u8D28goroutine"><a href="#u9AD8_u5E76_u53D1_u7684_u672C_u8D28goroutine" class="headerlink" title="高并发的本质goroutine"></a>高并发的本质goroutine</h2><p>简单而言,<code>goroutine</code>就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个<code>goroutine</code>，但它们并不是被操作系统所调度执行,而是通过系统的线程来多路派遣这些函数的执行，使得每个用go关键字执行的函数可以运行成为一个单位协程。当一个协程阻塞的时候，调度器就会自动把其他协程安排到另外的线程中去执行，从而实现了程序无等待并行化运行。而且调度的开销非常小，一颗CPU调度的规模不下于每秒百万次，这使得在程序中能够创建大量的<code>goroutine</code>，实现高并发的同时，依旧能保持高性能。<br><code>goroutine</code>是通过通信来共享内存,go中是通过<code>Channel</code>来实现通信的，<code>Channel</code>本身就像一根管道，go就通过这根管道进行数据的传递,实现消息通信。先来看一个简单的示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Go concurrency"</span>)</span><br><span class="line">	c &lt;- <span class="constant">true</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  v := <span class="keyword">range</span> c &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>上面的代码首先创建一个<code>bool</code>的<code>Channel</code>对象<code>c</code>,然后通过<code>go</code>关键字执行一个<code>goroutine</code>,紧接着执行一个<code>for</code>循环;<code>for</code>会循环去读取<code>c</code>中的值，如果读取到值，则执行<code>for</code>循环体（打印v的值），没读取到则<code>for</code>被阻塞等待,直到读取到<code>c</code>中的值再去执行<code>for</code>循环体然后继续循环读取<code>c</code>，如果执行了<code>close(c)</code>把<code>Channel</code>对象<code>c</code>关闭了，那<code>for</code>循环就退出不执行了。 这就是通过<code>Channel</code>通信执行<code>goroutine</code>的一个简单示例。</li>
<li><p>上面通过make这样初始化的<code>Channel</code>对象<code>c</code>是既可以写又可以被读取的双向通道, 有时候为了避免被误读误写操作，可以初始化一个单向的<code>Channel</code>对象。通过设置<code>Channel</code>的长度可以分为有缓冲和无缓冲两种<code>Channel</code>,无缓冲区的<code>Channel</code>,在等待读或等待写的过程中都会引起<code>同步阻塞</code>，而有缓冲区的<code>Channel</code>,可以看作<code>异步执行</code>,也可以认为控制为<code>同步执行</code>，只有当缓冲区被占用完了之后才会引起<code>阻塞</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>, <span class="number">3</span>)  <span class="comment">//初始化缓冲区长度为3的Channel</span></span><br><span class="line"><span class="keyword">var</span> send <span class="keyword">chan</span>&lt;- <span class="typename">int</span> = c <span class="comment">//只写入的Channel</span></span><br><span class="line"><span class="keyword">var</span> recv &lt;-<span class="keyword">chan</span> <span class="typename">int</span> = c <span class="comment">//只读取的Channel</span></span><br></pre></td></tr></table></figure>
<p>  <strong> 注意: </strong>  只读或只写的单向<code>Channel</code> 都需要借助其它<code>Channel</code>才有实际意义，定义一个只写入但是读取不出来的<code>Channel</code>没有任何用处。单向<code>Channel</code>用作函数形参用于防止参数在函数内部被误读误写是非常有帮助的。</p>
</li>
</ul>
<h2 id="u5F00_u542F_u591A_u6838_u5E76_u884C_u5E76_u53D1_u6267_u884C"><a href="#u5F00_u542F_u591A_u6838_u5E76_u884C_u5E76_u53D1_u6267_u884C" class="headerlink" title="开启多核并行并发执行"></a>开启多核并行并发执行</h2><p>默认情况下，go所有的<code>goroutines</code>是在一个线程中执行的，而不是同时利用多核进行并行执行，或者通过切换时间片让出CPU进行并发执行。下面看一段示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> GoPrint(&amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> GoPrint(wg *sync.WaitGroup) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前只有显示设置了<code>runtime.GOMAXPROCS</code>,go才会开启多核并行执行<code>goroutines</code>, 如果在<code>GoPrint</code>方法中不加入<code>time.Sleep</code>，输出的结果将会是<code>0 1 2 0 1 2 0 1 2</code>，如果当前<code>goroutine</code>不发生阻塞，它是不会让出CPU给其他<code>goroutine</code>的, 所以在<code>GoPrint</code>中不加<code>time.Sleep</code>,输出会是一个一个<code>goroutine</code>进行的，而sleep函数则阻塞掉了 当前<code>goroutine</code>, 当前<code>goroutine</code>主动让其他<code>goroutine</code>执行, 所以形成了逻辑上的并行, 也就是并发。</p>
<h2 id="go_u5E76_u53D1_u6267_u884C_u5B89_u5168_u95EE_u9898"><a href="#go_u5E76_u53D1_u6267_u884C_u5B89_u5168_u95EE_u9898" class="headerlink" title="go并发执行安全问题"></a>go并发执行安全问题</h2><p>go并发执行当多个<code>goroutine</code>同时访问一个共有的资源时，在不加锁的情况很容易出行数据不同步的问题，看一示例:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> sell_tickets(wg *sync.WaitGroup, i <span class="typename">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> total_tickets &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="comment">// 如果有票就卖</span></span><br><span class="line">		<span class="keyword">if</span> total_tickets &gt; <span class="number">0</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">5</span>)) * time.Millisecond)</span><br><span class="line">			<span class="comment">// 卖一张票</span></span><br><span class="line">			total_tickets--</span><br><span class="line">			fmt.Println(<span class="string">"id:"</span>, i, <span class="string">" ticket:"</span>, total_tickets)</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个多<code>goroutine</code>并发买票的问题，比如当开启5个<code>goroutine</code>来卖100张票，如果不加锁，则有可能会出行多出一些不存在的票的问题。所以当并发访问公有资源时要注意加锁保护公有资源属性修改的唯一性和访问时数据同步问题。<br><a href="https://github.com/researchlab/golearning/blob/master/concurrency/concurrency_sync_mutex.go" target="_blank" rel="external">示例代码</a></p>
<h2 id="u6279_u91CF_u5904_u7406_u591A_u4E2AChannel_u64CD_u4F5C"><a href="#u6279_u91CF_u5904_u7406_u591A_u4E2AChannel_u64CD_u4F5C" class="headerlink" title="批量处理多个Channel操作"></a>批量处理多个Channel操作</h2><p>go通过<code>Select</code>可以同时处理多个<code>Channel</code>,<code>Select</code>默认是阻塞的，只有当监听的<code>Channel</code>中有发送或接收可以进行时才会运行,当同时有多个可用的<code>Channel</code>,<code>Select</code>按随机顺序进行处理,<code>Select</code>可以方便处理多<code>Channel</code>同时响应，在goroutine阻塞的情况也可以方便借助<code>Select</code>超时机制来解除阻塞僵局，下面来看一个示例:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> getHttpRes(url <span class="typename">string</span>) (<span class="typename">string</span>, error) &#123;</span><br><span class="line">	res := <span class="built_in">make</span>(<span class="keyword">chan</span> *http.Response, <span class="number">1</span>)</span><br><span class="line">	httpError := <span class="built_in">make</span>(<span class="keyword">chan</span> *error)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		resp, err := http.Get(url)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">			httpError &lt;- &amp;err</span><br><span class="line">		&#125;</span><br><span class="line">		res &lt;- resp</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> r := &lt;-res:</span><br><span class="line">			result, err := ioutil.ReadAll(r.Body)</span><br><span class="line">			<span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">			<span class="keyword">return</span> <span class="typename">string</span>(result), err</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-httpError:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"err"</span>, *err</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">2000</span> * time.Millisecond):</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Timed out"</span>, errors.New(<span class="string">"Timed out"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发起http请求之后通常会有三种状况:1.访问成功，返回内容值;2.访问失败，返回错误信息;3.访问超时，返回超时。上面的代码中利用<code>Select</code>很方便的处理了go并发执行中多可用<code>Channel</code>的处理问题，通过设置超时，帮助程序跳出超时等待的僵局。<br><a href="https://github.com/researchlab/golearning/blob/master/concurrency/select_timeout.go" target="_blank" rel="external">示例代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;go能处理高并发的根本原因在于执行go协程只需极少的栈内存(大概4~5KB),并且能根据需要动态增长和缩减占用的资源。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="concurrency" scheme="http://www.grdtechs.com/tags/concurrency/"/>
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang reflect使用总结</title>
    <link href="http://www.grdtechs.com/2016/02/17/go-reflect-summarize/"/>
    <id>http://www.grdtechs.com/2016/02/17/go-reflect-summarize/</id>
    <published>2016-02-17T08:57:59.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>反射是一种检查存储在接口变量中的<code>&lt;值,类型&gt;</code>对的机制，借助go反射包提供的<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>可以方便的访问到一个接口值的<code>reflect.Type</code>和<code>reflect.Value</code>部分，从而可进一步得到这个接口的结构类型和对其进行值的修改操作。<br><a id="more"></a></p>
<h2 id="u53CD_u5C04_u7684_u4F7F_u7528"><a href="#u53CD_u5C04_u7684_u4F7F_u7528" class="headerlink" title="反射的使用"></a>反射的使用</h2><ol>
<li><p><strong>获取接口对象的字段,类型和方法信息</strong><br>先定义个通用的结构体</p>
<pre><code>type User struct{
    Id int
    Name string
    Age int
}
</code></pre><p>将接口对象类型信息映射为反射类型信息</p>
<pre><code class="golang"><span class="keyword">func</span> Info(o <span class="keyword">interface</span>{}) {
    t := reflect.TypeOf(o)         <span class="comment">//获取接口的类型</span>
    fmt.Println(<span class="string">"Type:"</span>, t.Name()) <span class="comment">//t.Name() 获取接口的名称</span>

    <span class="keyword">if</span> t.Kind() != refelct.Struct { <span class="comment">//通过Kind()来判断反射出的类型是否为需要的类型</span>
        fmt.Println(<span class="string">"err: type invalid!"</span>)        
        <span class="keyword">return</span>
    }        

    v := reflect.ValueOf(o) <span class="comment">//获取接口的值类型</span>
    fmt.Println(<span class="string">"Fields:"</span>)

    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ { <span class="comment">//NumField取出这个接口所有的字段数量</span>
    f := t.Field(i)                                   <span class="comment">//取得结构体的第i个字段</span>
    val := v.Field(i).Interface()                     <span class="comment">//取得字段的值</span>
    fmt.Printf(<span class="string">"%6s: %v = %v\n"</span>, f.Name, f.Type, val) <span class="comment">//第i个字段的名称,类型,值</span>
    }

    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++{
        m := t.Method(i)
        fmt.Printf(<span class="string">"%6s: %v\n"</span>, m.Name,m.Type) <span class="comment">//获取方法的名称和类型       </span>
    }
}
</code></pre>
<p>获取接口对象的类型名称，通过<code>refelct.TypeOf()</code>获取接口对象的类型,并通过<code>Name()</code>方法获取接口的名称。<br>获取对象中所有字段的名称,类型和值,通过<code>reflect.ValueOf()</code>获取接口对象的值类型取得字段的名称和类型,然后通过<code>v.Field(i).Interface()</code>取得第i个字段的值。<br>还可以通过<code>NumMethod()</code>循环获取接口对象所有方法的名称和类型。<br><a href="https://github.com/researchlab/golearning/blob/master/reflect/01reflect.go" target="_blank" rel="external">示例代码</a></p>
</li>
<li><p><strong>反射接口对象中的匿名或嵌入字段信息</strong><br>先再添加一个Manager结构,User作为它的匿名字段</p>
<pre><code>type Manager struct{
    User
    title string
}
</code></pre><p>初始化Manager的两种方法：</p>
<pre><code>m0 := Manager{User: User{1,&quot;Mike&quot;,11},title: &quot;Man&quot;}
m1 := Manager{User{1,&quot;Mike&quot;,11},&quot;Man&quot;} //这种初始化,赋值顺序必须和结构体中的声明顺序相同! 
</code></pre><p>现在如何来取出Manager中的匿名字段User？</p>
<pre><code>t := refelct.TypeOf(m)
fmt.Printf(&quot;%#v\n&quot;, t.Field(0))
</code></pre><p>如上述代码，通过<code>t := refelct.TypeOf(m)</code>将Manager的字段类型取出来,在反射中对象字段是通过索引取到的，所以可通过<code>t.Field(0)</code>,</p>
<pre><code>#reflect.StructField{Name:&quot;User&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0xedd20), Tag:&quot;&quot;, Offset:0x0, Index:[]int{0}, Anonymous:true}
</code></pre><p>还可以通过<code>FieldByIndex</code>和<code>FieldByName</code>两种方法取得匿名结构体中的字段属性</p>
<ol>
<li>给<code>FieldByIndex()</code>传入一个int型的slice索引,如<code>FieldByIndex([]int{0,0})</code>即取得User结构体中的Id字段。</li>
<li>通过<code>FieldByName(&quot;Id&quot;)</code>也可以取得User结构体中Id字段。</li>
</ol>
</li>
</ol>
<h2 id="u901A_u8FC7_u53CD_u5C04_u4FEE_u6539_u5BF9_u8C61"><a href="#u901A_u8FC7_u53CD_u5C04_u4FEE_u6539_u5BF9_u8C61" class="headerlink" title="通过反射修改对象"></a>通过反射修改对象</h2><p>上面通过<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>已经可以得到接口对象的类型,字段和方法等属性了，怎么通过反射来修改对象的字段值？</p>
<pre><code>x := 100
v := refelct.ValueOf(&amp;x) //传入地址
v.Elem().SetInt(200) //成功修改x值为200
</code></pre><p>要修改变量x的值，首先就要通过<code>reflect.ValueOf</code>来获取x的值类型,<code>refelct.ValueOf</code>返回的值类型是变量x一份值拷贝,要修改变量x就要传递x的地址,从而返回x的地址对象,才可以进行对x变量值对修改操作。在得到x变量的地址值类型之后先调用<code>Elem()</code>返回地址指针指向的值的Value封装。然后通过<code>Set</code>方法进行修改赋值。<br>通过反射可以很容易的修改变量的值，怎么来修改结构体中的字段值？</p>
<pre><code>func SetInfo(o interface{}) {
        v := reflect.ValueOf(o)

        if v.Kind() == reflect.Ptr &amp;&amp; !v.Elem().CanSet() { //判断是否为指针类型 元素是否可以修改
            fmt.Println(&quot;cannot set&quot;)
                return
        } else {
            v = v.Elem() //实际取得的对象
        }

        //判断字段是否存在
        f := v.FieldByName(&quot;Name&quot;)
        if !f.IsValid() {
            fmt.Println(&quot;wuxiao&quot;)
                return
        }

        //设置字段
        if f := v.FieldByName(&quot;Name&quot;); f.Kind() == reflect.String {
            f.SetString(&quot;BY&quot;)
        }
}
</code></pre><p>要成功修改结构体中的某个字段,主要进行以下操作：</p>
<ol>
<li>首先要反射出这个字段的地址值类型;</li>
<li>判断反射返回类型是否为<code>reflect.Ptr</code>指针类型（通过指针才能操作对象地址中的值)同时还要判断这个元素是否可以修改;</li>
<li>通过<code>FieldByName</code>的返回值判断字段是否存在</li>
<li>通过<code>Kind()</code>和<code>Set</code>来修改字段的值<br><a href="https://github.com/researchlab/golearning/blob/master/reflect/02reflect.go" target="_blank" rel="external">示例代码</a></li>
</ol>
<h2 id="u901A_u8FC7_u53CD_u5C04_u201C_u52A8_u6001_u201D_u8C03_u7528_u65B9_u6CD5"><a href="#u901A_u8FC7_u53CD_u5C04_u201C_u52A8_u6001_u201D_u8C03_u7528_u65B9_u6CD5" class="headerlink" title="通过反射“动态”调用方法"></a>通过反射“动态”调用方法</h2><p>现在已经可以通过反射获取并修改接口对象的字段，类型等信息了，那怎么通过反射“动态”调用接口对象等方法？<br>先为<code>User</code>结构体引入一个<code>Hello</code>方法：</p>
<pre><code>func (u User) Hello(m User) (int, string) {
    fmt.Println(&quot;Hello&quot;, m.Name, &quot;, I&apos;m &quot;, u.Name)
    return m.Age + u.Age, u.Name
}
</code></pre><p>下面通过反射来调用<code>Hello</code>这个方法：</p>
<pre><code>func GetInfo(u interface{}) {
    m := User{2, &quot;Json&quot;, 12}

    v := reflect.ValueOf(u)

    if v.Kind() != reflect.Struct {
        fmt.Println(&quot;type invalid&quot;)
        return
    }

    mv := v.MethodByName(&quot;Hello&quot;) //获取对应的方法
    if !mv.IsValid() {            //判断方法是否存在
        fmt.Println(&quot;Func Hello not exist&quot;)
        return
    }

    args := []reflect.Value{reflect.ValueOf(m)} //初始化传入等参数，传入等类型只能是[]reflect.Value类型
    res := mv.Call(args)
    fmt.Println(res[0], res[1])

}
</code></pre><p>通过<code>MethodByName</code>先获取对象的<code>Hello</code>方法,然后准备要传入的参数,这里传入的参数必须是<code>[]refelct.Value</code>类型,传入的参数值必须强制转换为反射值类型<code>refelct.Value</code>。<br>最后通过调用<code>Call</code>方法就可以实现通过反射”动态”调用对象的方法。<br><a href="https://github.com/researchlab/golearning/blob/master/reflect/03reflect.go" target="_blank" rel="external">示例代码</a></p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><ul>
<li>通过反射包提供<code>refelct.TypeOf</code>和<code>refelct.ValueOf</code>方法获得接口对象的类型，值和方法等。</li>
<li>通过反射修改字段值等时候需要传入地址类型，并且需要检查反射返回值类型是否为<code>refelct.Ptr</code>，检查字段是否<code>CanSet</code>,检查字段是存在,然后通过<code>Kind()</code>来帮助赋值相应对类型值。</li>
<li>最后总结了通过<code>MethodByName</code>等方法如何“动态”调用对象的方法，示例代码也演示了如何传入和接收多个参数值。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;反射是一种检查存储在接口变量中的&lt;code&gt;&amp;lt;值,类型&amp;gt;&lt;/code&gt;对的机制，借助go反射包提供的&lt;code&gt;reflect.TypeOf&lt;/code&gt;和&lt;code&gt;reflect.ValueOf&lt;/code&gt;可以方便的访问到一个接口值的&lt;code&gt;reflect.Type&lt;/code&gt;和&lt;code&gt;reflect.Value&lt;/code&gt;部分，从而可进一步得到这个接口的结构类型和对其进行值的修改操作。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.grdtechs.com/categories/golang/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
      <category term="reflect" scheme="http://www.grdtechs.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>[译]GO BOOTCAMP 第七章：接口</title>
    <link href="http://www.grdtechs.com/2016/01/25/go-interfaces/"/>
    <id>http://www.grdtechs.com/2016/01/25/go-interfaces/</id>
    <published>2016-01-25T15:12:56.000Z</published>
    <updated>2016-11-23T06:28:51.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>接口被定义为一组方法的集合, 接口可以接收任何其实现的方法的值.<br><a id="more"></a><br>下面利用接口的特性，重构了之前的一个案例,这次通过给<code>Greet</code>方法提供一个接口类型参数<code>Namer</code>，使得<code>Greet</code>方法更通用. <code>Namer</code>是定义的新接口，只包含一个方法<code>Name()</code>,所以<code>Greet()</code>可以接收任意有<code>Name()</code>方法定义的值.</p>
<p>为<code>User</code>结构体实现这个接口，定义了一个<code>Name()</code>方法。 可以通过传递一个执行<code>User</code>的指针给<code>Greet</code>方法来调用<code>Greet</code>.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	FirstName, LastName <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (u *User) Name() <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s"</span>, u.FirstName, u.LastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Greet(n Namer) <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"Dear %s"</span>, n.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	u := &amp;User&#123;<span class="string">"Matt"</span>, <span class="string">"Aimonetti"</span>&#125;</span><br><span class="line">	fmt.Println(Greet(u))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以定义一个新的类型实现相同的接口，<code>Greet</code>函数同样可以使用<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	FirstName, LastName <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (u *User) Name() <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s"</span>, u.FirstName, u.LastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id       <span class="typename">int</span></span><br><span class="line">	FullName <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (c *Customer) Name() <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.FullName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Greet(n Namer) <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"Dear %s"</span>, n.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	u := &amp;User&#123;<span class="string">"Matt"</span>, <span class="string">"Aimonetti"</span>&#125;</span><br><span class="line">	fmt.Println(Greet(u))</span><br><span class="line">	c := &amp;Customer&#123;<span class="number">42</span>, <span class="string">"Francesc"</span>&#125;</span><br><span class="line">	fmt.Println(Greet(c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u63A5_u53E3_u6EE1_u8DB3_u9690_u5F0F_u5B9E_u73B0"><a href="#u63A5_u53E3_u6EE1_u8DB3_u9690_u5F0F_u5B9E_u73B0" class="headerlink" title="接口满足隐式实现"></a>接口满足隐式实现</h2><p>一个类型可以通过实现接口的所有方法来实现接口.</p>
<p>不需要显示的取声明或者实现某个接口.</p>
<p>隐式接口解偶实现定义接口的包，不需要额外的依赖.</p>
<p>推荐合理定义接口，就不需要额外标记定义的新接口.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(b []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(b []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	<span class="keyword">var</span> w Writer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// os.Stdout implements Writer</span></span><br><span class="line">	w = os.Stdout</span><br><span class="line"></span><br><span class="line">	fmt.Fprintf(w, <span class="string">"hello, writer\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u9519_u8BEF"><a href="#u9519_u8BEF" class="headerlink" title="错误"></a>错误</h2><p>错误可以被描述任意的错误字符串. 可以捕获前置定义，内置接口类型，错误等， 错误返回的是一个字符串。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="typename">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用<code>fmt</code>包来打印错误信息<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (e *MyError) Error() <span class="typename">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> run() error &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">"it didn't work"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> 练习题 </strong><br>自定义一个<code>Sqrt</code>函数，让起返回一个错误。<br>创建一个新类型<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="typename">float64</span></span><br></pre></td></tr></table></figure></p>
<p>定义一个Error()<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (e ErrNegativeSqrt) Error() <span class="typename">string</span></span><br></pre></td></tr></table></figure></p>
<p>如果直接打印错误<code>fmt.Print(e)</code> 可能使得程序陷入无限循环，可以通过<code>fmt.Print(float64(e))</code> 来避免这种情况.</p>
<p><strong> 解决方案 </strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="typename">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (e ErrNegativeSqrt) Error() <span class="typename">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"cannot Sqrt negative number: %g"</span>, <span class="typename">float64</span>(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> Sqrt(x <span class="typename">float64</span>) (<span class="typename">float64</span>, error) &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(x)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z := <span class="number">1.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		z = z - ((z*z)-x)/(<span class="number">2</span>*z)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">	fmt.Println(Sqrt(-<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> Tip: </strong><br>当声明一个浮点数声明时，可以省略小数点后面的值, 如下面那样, 但是，不推荐!<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z := <span class="number">1.</span></span><br><span class="line"><span class="comment">// same as</span></span><br><span class="line"><span class="comment">// z := 1.0</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;接口被定义为一组方法的集合, 接口可以接收任何其实现的方法的值.&lt;br&gt;
    
    </summary>
    
      <category term="go-bootcamp" scheme="http://www.grdtechs.com/categories/go-bootcamp/"/>
    
    
      <category term="golang" scheme="http://www.grdtechs.com/tags/golang/"/>
    
  </entry>
  
</feed>
