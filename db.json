{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1},{"_id":"source/imgs/observer_pattern.jpg","path":"imgs/observer_pattern.jpg","modified":1},{"_id":"themes/lightman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/lightman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1},{"_id":"themes/lightman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/lightman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/lightman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/lightman/source/img/weixin.jpg","path":"img/weixin.jpg","modified":1},{"_id":"themes/lightman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/lightman/source/img/logo.svg","path":"img/logo.svg","modified":1},{"_id":"themes/lightman/source/img/logo.png","path":"img/logo.png","modified":1},{"_id":"themes/lightman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1},{"_id":"themes/lightman/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/lightman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/lightman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/lightman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/lightman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/lightman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/lightman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/lightman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/lightman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/lightman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/lightman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/lightman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/lightman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/lightman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/lightman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/lightman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/lightman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/lightman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/lightman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/lightman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/lightman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/lightman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/lightman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/lightman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/lightman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/lightman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/lightman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/lightman/source/css/style.styl","path":"css/style.styl","modified":1}],"Cache":[{"_id":"source/_posts/go-basics.md","shasum":"7cab798bd92f62d5bb8d9333e07f6d8a29436881","modified":1458578745570},{"_id":"source/_posts/go-collection-types.md","shasum":"40d2025704a2650206e18b2fccc6524c7148ef93","modified":1458578745570},{"_id":"source/CNAME","shasum":"a4ef4bfd8a21b7dacfbbfed32630367725273f3a","modified":1458578745570},{"_id":"source/_posts/go-concurrency-summarize.md","shasum":"7a33a65fa19133cc53520d18e1735a4dd1c5bd14","modified":1458578745570},{"_id":"source/_posts/go-type-convert.md","shasum":"f1ae088248b966b8bdccb5bdcc21ef2d3a2775b4","modified":1458869829035},{"_id":"source/_posts/go-reflect-summarize.md","shasum":"91275e6530e7201e36338dc2eee262623e7b9300","modified":1458578745571},{"_id":"source/_posts/go-reflect-summarize.md.older","shasum":"0352d5877828ac2a2e865951127c7d21bcff858e","modified":1458578745571},{"_id":"source/_posts/go-concurrency-security.md","shasum":"cec470077a0d7916ab504d2dbbaa8a65149b3a4f","modified":1458578745570},{"_id":"source/_posts/go-types.md","shasum":"f2daf24d20302be39a912c2ace4f3a37b21f8955","modified":1458578745571},{"_id":"source/_posts/go-xorm-summarize.md","shasum":"4aafb9ef3ff97d28331be1c5ae2587988f014c73","modified":1458578745571},{"_id":"source/about/index.md","shasum":"f1125f2d32654b6616288069d196b05475667332","modified":1458618335302},{"_id":"source/_posts/singleton-pattern-in-go.md","shasum":"39b9753b2c4fe254cc52fb50cba0f4381a9e8abb","modified":1458578745571},{"_id":"source/imgs/observer_pattern.jpg","shasum":"212fd6e2b2649b1102abe2a716668fc65f0e76b4","modified":1458578745572},{"_id":"source/_posts/observer-pattern-in-go-md.md","shasum":"582e71f242ca97898ce0f0c47bd3039ec437ff87","modified":1458578745571},{"_id":"source/_posts/hexo-blog-1.md","shasum":"4e6ebc563ab95654c51e5f2c3bb2cc3e78a5ba5b","modified":1458578745571},{"_id":"themes/lightman/README.md","shasum":"79be8a49927c8666f1804d7ccd08af8d3268062a","modified":1454402009000},{"_id":"themes/lightman/README_zh.md","shasum":"0854e4c96f53005f3a47e21af3f8aee361719ce4","modified":1454402009000},{"_id":"themes/lightman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1454402009000},{"_id":"themes/lightman/languages/default.yml","shasum":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1454402009000},{"_id":"themes/lightman/languages/zh-CN.yml","shasum":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1454402009000},{"_id":"themes/lightman/languages/zh-TW.yml","shasum":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/analytics.ejs","shasum":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/after_footer.ejs","shasum":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1454402009000},{"_id":"themes/lightman/_config.yml","shasum":"c9317fc0dc6054a7280b48182f2b73b4c17c40dc","modified":1455546946000},{"_id":"themes/lightman/layout/_partial/footer.ejs","shasum":"32db7e7c8171530d29c3878f387c4438d6057508","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/head.ejs","shasum":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/header.ejs","shasum":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/article_row.ejs","shasum":"68e57eb6ac49bdfba924f9ab7fed2fbc17d45118","modified":1455588829000},{"_id":"themes/lightman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/post/jiathis.ejs","shasum":"b87e2d6d62e35727855d86ea51323fed41ae4f5a","modified":1455589851000},{"_id":"themes/lightman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/sidebar.ejs","shasum":"0231cd8f3c97aa50239829928d5e70ea3b5627e7","modified":1454410614000},{"_id":"themes/lightman/layout/_partial/sidebar.ejs.older","shasum":"62a902d7491fa3778b1de1ae45a9b2174cd70a89","modified":1454410389000},{"_id":"themes/lightman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1454402009000},{"_id":"themes/lightman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/category.ejs","shasum":"09e28cf24ea4b74efcc48136bbb08b979ca74757","modified":1454407749000},{"_id":"themes/lightman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/douban.ejs","shasum":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/intro.ejs","shasum":"3f8980f92131954d069323d9a4250bb69b3fa2e6","modified":1455443691000},{"_id":"themes/lightman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/github-card.ejs","shasum":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/weibo.ejs.older","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1454402009000},{"_id":"themes/lightman/layout/_widget/weibo.ejs","shasum":"e3ad587aaf93adfd7fb52b1719f26c37deff923d","modified":1455439867000},{"_id":"themes/lightman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1454402009000},{"_id":"themes/lightman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1454402009000},{"_id":"themes/lightman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1454402009000},{"_id":"themes/lightman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1454402009000},{"_id":"themes/lightman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1454402009000},{"_id":"themes/lightman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1454402009000},{"_id":"themes/lightman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1454402009000},{"_id":"themes/lightman/source/css/_base/highlight/highlight.styl","shasum":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1454402009000},{"_id":"themes/lightman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1454402009000},{"_id":"themes/lightman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1454402009000},{"_id":"themes/lightman/source/css/_base/public.styl","shasum":"f016180726019927b9a835ed01e04d153f27a149","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1454402009000},{"_id":"themes/lightman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1454402009000},{"_id":"themes/lightman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/aside.styl","shasum":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/footer.styl","shasum":"e82dd88c7eb7a6db7b2fa012ce084cd3ee6d4881","modified":1455440785000},{"_id":"themes/lightman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1454402009000},{"_id":"themes/lightman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/helper.styl","shasum":"1136600932b97534b88465bf05ef313630b2de3d","modified":1454402009000},{"_id":"themes/lightman/source/css/_partial/index.styl","shasum":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1454402009000},{"_id":"themes/lightman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1454402009000},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1454402009000},{"_id":"themes/lightman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1454402009000},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1454402009000},{"_id":"themes/lightman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1454402009000},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1454402009000},{"_id":"themes/lightman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1454402009000},{"_id":"themes/lightman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1454402009000},{"_id":"themes/lightman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1454402009000},{"_id":"themes/lightman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1454402009000},{"_id":"themes/lightman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1454402009000},{"_id":"themes/lightman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1454402009000},{"_id":"themes/lightman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1454402009000},{"_id":"themes/lightman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1454402009000},{"_id":"themes/lightman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1454402009000},{"_id":"themes/lightman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1454402009000},{"_id":"themes/lightman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1454402009000},{"_id":"themes/lightman/source/img/jacman.jpg","shasum":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1454402009000},{"_id":"themes/lightman/source/img/favicon.ico","shasum":"82d7ca64bbb9ad5191a338437cdba179d27e28df","modified":1454331482000},{"_id":"themes/lightman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1454402009000},{"_id":"themes/lightman/source/img/logo.svg","shasum":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1454402009000},{"_id":"themes/lightman/source/img/weixin.jpg","shasum":"94cdf10543bfca06c103c60dd6b458b208f3244a","modified":1454407094000},{"_id":"themes/lightman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1454402009000},{"_id":"themes/lightman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1454402009000},{"_id":"themes/lightman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1454402009000},{"_id":"themes/lightman/source/js/jquery.qrcode-0.12.0.min.js","shasum":"57c3987166a26415a71292162690e82c21e315ad","modified":1454402009000},{"_id":"themes/lightman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1454402009000},{"_id":"themes/lightman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1454402009000},{"_id":"themes/lightman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1454402009000},{"_id":"themes/lightman/source/img/logo.png","shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1454402009000},{"_id":"themes/lightman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1454402009000},{"_id":"themes/lightman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1454402009000}],"Category":[{"name":"go-pattern","_id":"cim71frzn0002k2pvays17ske"},{"name":"Hexo","_id":"cim71frzz000ek2pvzzxw794o"},{"name":"golang","_id":"cim71fs03000lk2pv7rmi5tze"},{"name":"go-bootcamp","_id":"cim71fs07000rk2pv5le8x8ko"}],"Data":[],"Page":[{"title":"About Me","date":"2016-02-16T02:28:40.000Z","_content":"I'm a software developer under Linux/Mac OS.\ndev skills: `golang`,`c/c++`,`python`,`js`,`lua`\ntools: `vim`,`gcc-c++`,`Makefile`,`gdb`,`visio`,`uml`,`vs`,`svn`,`git`\nsql: `mysql`,`influxdb`,`redis`,`mongodb`\nprotocol: `xml`,`json`,`protocol buffer`, `http`,`http proxy`\nothers: `beego`,`rabbitmq`,`goconvey`,`jenkins`,`xorm`,`nginx`,`echarts`\nrelations: `golang web`, `golang/c++ game`\ninteresting:`web server/front-end`,`mobile app server`,`game server`\nfocus on: `High-Performance, High-Concurrency in web dev`,`Continuous Integration,Automated Construction,Automated Testing`\n\n","source":"about/index.md","raw":"---\ntitle: About Me \ndate: 2016-02-15 21:28:40\n---\nI'm a software developer under Linux/Mac OS.\ndev skills: `golang`,`c/c++`,`python`,`js`,`lua`\ntools: `vim`,`gcc-c++`,`Makefile`,`gdb`,`visio`,`uml`,`vs`,`svn`,`git`\nsql: `mysql`,`influxdb`,`redis`,`mongodb`\nprotocol: `xml`,`json`,`protocol buffer`, `http`,`http proxy`\nothers: `beego`,`rabbitmq`,`goconvey`,`jenkins`,`xorm`,`nginx`,`echarts`\nrelations: `golang web`, `golang/c++ game`\ninteresting:`web server/front-end`,`mobile app server`,`game server`\nfocus on: `High-Performance, High-Concurrency in web dev`,`Continuous Integration,Automated Construction,Automated Testing`\n\n","updated":"2016-03-22T03:45:35.302Z","path":"about/index.html","comments":1,"layout":"page","_id":"cim71fryi0000k2pvw4v7fj7r"}],"Post":[{"title":"golang 设计模式之singleton使用总结","date":"2016-02-25T22:01:43.000Z","description":null,"_content":"\n## 前言\n`golang` 1.5版本之后默认设置`GOMAXPROCS`值为当前计算机真实核心数，使得`goroutines`从默认的`单线程内并发执行`变成了默认的（真实核心数支持的）的`多线程内并行`执行。多线程并行执行`goroutines`需要考虑并行执行过程中引入的`线程安全问题`。\n<!--more-->\n\n## 单线程singleton模型\n单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。先摘取一个在实际工作项目中碰到的singleton模型代码:\n```golang\npackage singleton\n\ntype singleton struct {\n}\n\nvar instance *singleton\n\nfunc GetInstance() *singleton {\n\tif instance == nil {\n       instance = &singleton{}   // 没有考虑线程安全 \n\t}\n\treturn instance\n}\n```\n上面的`singleton`设计代码在见过的几个`golang`项目中都是这么写的，如果这段代码放在`golang`1.5版本之前默认的单线程场景下运行显然是没什么问题的。`golang`1.5版本之后默认是启动多核并行执行`goroutines`的，如果上述代码放在`golang`1.5版本之后，如果程序开启n个`goroutines`初始化一个`singleton`对象, 显然会初始化成功最少一个最多n个`singleton`对象，从而会存在潜在的多个单例实例对象了，也就不可能保证这个`singleton`对象全局唯一性了，那后继采用`singleton`对象进行全局唯一性操作时势必会造成数据不一致的问题。如果场景中但个`goroutines`执行时间短的话，会使得调试更难。\n\n## 采用互斥锁机制\n面对上述线程安全问题，一般会考虑到用锁机制(`Mutex`)来解决因线程安全引入的数据不一致问题，采用锁机制如：\n```golang \nvar mu Sync.Mutex\n\nfunc GetInstance() *singleton {\n    mu.Lock()                    // singleton实例对象操作之后，锁就是多余的了 \n    defer mu.Unlock()\n\n    if instance == nil {\n        instance = &singleton{}\n    }\n   return instance\n}\n```\n上述代码可以看到，引入锁机制`Sync.Mutex`后，能够保证多线程并行执行`goroutines`创建的`singleton`实例对象是唯一的，但是当这个`singleton`实例对象被初始化创建之后，再次并行来创建`singleton`实例对象时，其实已经不再需要锁了，因为已经存在了一个创建好的`singleton`实例对象，所以直接返回即可;但是因为锁机制的存在，使得再次创建`singleton`实例对象时，还是需要先获取锁，然后在判断处理，多线程执行中这种锁竞争使得多线程的并行执行变成了多线程的串行执行，这显然会使程序丧失并行执行带来的性能提升。在一个高度并行的程序中，这样显示会是抑制程序性能提升的一个瓶颈。\n\n## 采用双重检查锁机制\n在`C++`等编程语言中，为了同时保证最小锁和线程安全通常采用的方法是`双重检查锁(Check-Lock-Check)`机制，也表述为`DCL(Double Check Lock)`。`双重检查锁`机制的伪代码一般是下面的这种形式:\n```golang\nif check() {\n    lock() {\n       if check() {\n           // 锁安全代码 \n        }\n    }\n}\n```\n其实对这个`singleton`实例对象来说，只有在第一次创建实例的时候才需要同步，所以为了减少同步，先check一下，判断`singleton`实例对象是否为空，如果为空，表示是第一使用这个`singleton`实例对象，那就锁住它，new一个`singleton`实例，下次另一个线程来`GetInstance`的时候，看到这个`singleton`实例对象不为空，就表示已经创建过一个实例了，那就可以直接得到这个实例，避免再次锁。这是第一个 check的作用。 \n\n第二个check是解决锁竞争情况下的问题，假设现在两个线程来请求`GetInstance`，A、B线程同时发现`singleton`实例对象为空，因为我们在第一次check方法上没有加锁，然后A线程率先获得锁，进入同步代码块，new了一个`singleton`实例对象，之后释放锁，接着B线程获得了这个锁，发现`singleton`实例对象已经被创建了，就直接释放锁，退出同步代码块。所以这就是`Check-Lock-Check`; 将上面的`singleton`实例用`Check-Lock-Check`机制实现如：\n```golang\nfunc GetInstance() *singleton {\n    if instance == nil { \n        mu.Lock()\n        defer mu.Unlock()\n\n        if instance == nil {\n\t            instance = &singleton{}\n        }\n    }\n    return instance\n}\n```\n通过上面的`Check-Lock-Check`机制,的确可以解决锁竟争的问题，但是这种方法不管是否`singleton`实例对象是否已创建，每次都要执行两次check才是一个完整的判断，那有没有方法使得只要一次check就可以完成对`singleton`实例对象是否存在的检查呢？ 有！通过`golang`的`sync/atomic`包提供的原子性操作可以更高效的完成这个检查，改进代码如：\n```golang\nimport \"sync\"\nimport \"sync/atomic\"\n\nvar initialized uint32\n...\n\nfunc GetInstance() *singleton {\n\n   if atomic.LoadUInt32(&initialized) == 1 {\n\t\treturn instance\n\t}\n\n    mu.Lock()\n    defer mu.Unlock()\n\n    if initialized == 0 {\n         instance = &singleton{}\n         atomic.StoreUint32(&initialized, 1)\n\t}\n\n\treturn instance\n}\n```\n改进之后的代码通过设置一个标志操作，使得`singleton`实例对象创建之后，直接通过原子操作读取标志字段的值判断返回已经存在的实例，连锁操作及其后面的代码都略过了。\n\n## 采用atomic进一步简化\n上面通过`Check-Lock-Check`机制改进之后似乎没有什么可做的了，先不急，来看看`golang`原生标准包`sync`包中对`Once`实现的源码：\n```golang\n// Once is an object that will perform exactly one action.\ntype Once struct {\n\tm    Mutex\n\tdone uint32\n}\n\n// Do calls the function f if and only if Do is being called for the\n// first time for this instance of Once. In other words, given\n//\tvar once Once\n// if once.Do(f) is called multiple times, only the first call will invoke f,\n// even if f has a different value in each invocation.  A new instance of\n// Once is required for each function to execute.\n//\n// Do is intended for initialization that must be run exactly once.  Since f\n// is niladic, it may be necessary to use a function literal to capture the\n// arguments to a function to be invoked by Do:\n//\tconfig.once.Do(func() { config.init(filename) })\n//\n// Because no call to Do returns until the one call to f returns, if f causes\n// Do to be called, it will deadlock.\n//\n// If f panics, Do considers it to have returned; future calls of Do return\n// without calling f.\n//\nfunc (o *Once) Do(f func()) {\n\tif atomic.LoadUint32(&o.done) == 1 { // <-- Check\n\t\treturn\n\t}\n\t// Slow-path.\n\to.m.Lock()                           // <-- Lock\n\tdefer o.m.Unlock()\n\tif o.done == 0 {                     // <-- Check\n\t\tdefer atomic.StoreUint32(&o.done, 1)\n\t\tf()\n\t}\n}\n```\n可以看到我们之前其实是借鉴了`golang`原生标准包`sync`中对`Once`实现对源码，那既然标准包中已经实现了这个`Check-Lock-Check`机制，那我们直接调用`sync`包提供`once.Do()`方法对某个方法只进行一次性调用：\n```golang\nonce.Do(func() {\n\t // perform safe initialization here\n}\n```\n那么下面是根据`sync`包提供的`sync.Once`改进的获取`singleton`实例对象最终优化版本:\n```golang\npackage singleton\n\nimport (\n    \"sync\"\n)\n\ntype singleton struct {\n}\n\nvar instance *singleton\nvar once sync.Once\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &singleton{}\n    })\n    return instance\n}\n```\n因此使用`sync`包提供的`sync.Once`实现获取`singleton`实例对象可以说是最安全有效又简洁的方法。\n","source":"_posts/singleton-pattern-in-go.md","raw":"---\ntitle: \"golang 设计模式之singleton使用总结\"\ndate: 2016-02-25 17:01:43\ncategories: [go-pattern]\ntags: [golang,singleton]\ndescription:\n---\n\n## 前言\n`golang` 1.5版本之后默认设置`GOMAXPROCS`值为当前计算机真实核心数，使得`goroutines`从默认的`单线程内并发执行`变成了默认的（真实核心数支持的）的`多线程内并行`执行。多线程并行执行`goroutines`需要考虑并行执行过程中引入的`线程安全问题`。\n<!--more-->\n\n## 单线程singleton模型\n单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。先摘取一个在实际工作项目中碰到的singleton模型代码:\n```golang\npackage singleton\n\ntype singleton struct {\n}\n\nvar instance *singleton\n\nfunc GetInstance() *singleton {\n\tif instance == nil {\n       instance = &singleton{}   // 没有考虑线程安全 \n\t}\n\treturn instance\n}\n```\n上面的`singleton`设计代码在见过的几个`golang`项目中都是这么写的，如果这段代码放在`golang`1.5版本之前默认的单线程场景下运行显然是没什么问题的。`golang`1.5版本之后默认是启动多核并行执行`goroutines`的，如果上述代码放在`golang`1.5版本之后，如果程序开启n个`goroutines`初始化一个`singleton`对象, 显然会初始化成功最少一个最多n个`singleton`对象，从而会存在潜在的多个单例实例对象了，也就不可能保证这个`singleton`对象全局唯一性了，那后继采用`singleton`对象进行全局唯一性操作时势必会造成数据不一致的问题。如果场景中但个`goroutines`执行时间短的话，会使得调试更难。\n\n## 采用互斥锁机制\n面对上述线程安全问题，一般会考虑到用锁机制(`Mutex`)来解决因线程安全引入的数据不一致问题，采用锁机制如：\n```golang \nvar mu Sync.Mutex\n\nfunc GetInstance() *singleton {\n    mu.Lock()                    // singleton实例对象操作之后，锁就是多余的了 \n    defer mu.Unlock()\n\n    if instance == nil {\n        instance = &singleton{}\n    }\n   return instance\n}\n```\n上述代码可以看到，引入锁机制`Sync.Mutex`后，能够保证多线程并行执行`goroutines`创建的`singleton`实例对象是唯一的，但是当这个`singleton`实例对象被初始化创建之后，再次并行来创建`singleton`实例对象时，其实已经不再需要锁了，因为已经存在了一个创建好的`singleton`实例对象，所以直接返回即可;但是因为锁机制的存在，使得再次创建`singleton`实例对象时，还是需要先获取锁，然后在判断处理，多线程执行中这种锁竞争使得多线程的并行执行变成了多线程的串行执行，这显然会使程序丧失并行执行带来的性能提升。在一个高度并行的程序中，这样显示会是抑制程序性能提升的一个瓶颈。\n\n## 采用双重检查锁机制\n在`C++`等编程语言中，为了同时保证最小锁和线程安全通常采用的方法是`双重检查锁(Check-Lock-Check)`机制，也表述为`DCL(Double Check Lock)`。`双重检查锁`机制的伪代码一般是下面的这种形式:\n```golang\nif check() {\n    lock() {\n       if check() {\n           // 锁安全代码 \n        }\n    }\n}\n```\n其实对这个`singleton`实例对象来说，只有在第一次创建实例的时候才需要同步，所以为了减少同步，先check一下，判断`singleton`实例对象是否为空，如果为空，表示是第一使用这个`singleton`实例对象，那就锁住它，new一个`singleton`实例，下次另一个线程来`GetInstance`的时候，看到这个`singleton`实例对象不为空，就表示已经创建过一个实例了，那就可以直接得到这个实例，避免再次锁。这是第一个 check的作用。 \n\n第二个check是解决锁竞争情况下的问题，假设现在两个线程来请求`GetInstance`，A、B线程同时发现`singleton`实例对象为空，因为我们在第一次check方法上没有加锁，然后A线程率先获得锁，进入同步代码块，new了一个`singleton`实例对象，之后释放锁，接着B线程获得了这个锁，发现`singleton`实例对象已经被创建了，就直接释放锁，退出同步代码块。所以这就是`Check-Lock-Check`; 将上面的`singleton`实例用`Check-Lock-Check`机制实现如：\n```golang\nfunc GetInstance() *singleton {\n    if instance == nil { \n        mu.Lock()\n        defer mu.Unlock()\n\n        if instance == nil {\n\t            instance = &singleton{}\n        }\n    }\n    return instance\n}\n```\n通过上面的`Check-Lock-Check`机制,的确可以解决锁竟争的问题，但是这种方法不管是否`singleton`实例对象是否已创建，每次都要执行两次check才是一个完整的判断，那有没有方法使得只要一次check就可以完成对`singleton`实例对象是否存在的检查呢？ 有！通过`golang`的`sync/atomic`包提供的原子性操作可以更高效的完成这个检查，改进代码如：\n```golang\nimport \"sync\"\nimport \"sync/atomic\"\n\nvar initialized uint32\n...\n\nfunc GetInstance() *singleton {\n\n   if atomic.LoadUInt32(&initialized) == 1 {\n\t\treturn instance\n\t}\n\n    mu.Lock()\n    defer mu.Unlock()\n\n    if initialized == 0 {\n         instance = &singleton{}\n         atomic.StoreUint32(&initialized, 1)\n\t}\n\n\treturn instance\n}\n```\n改进之后的代码通过设置一个标志操作，使得`singleton`实例对象创建之后，直接通过原子操作读取标志字段的值判断返回已经存在的实例，连锁操作及其后面的代码都略过了。\n\n## 采用atomic进一步简化\n上面通过`Check-Lock-Check`机制改进之后似乎没有什么可做的了，先不急，来看看`golang`原生标准包`sync`包中对`Once`实现的源码：\n```golang\n// Once is an object that will perform exactly one action.\ntype Once struct {\n\tm    Mutex\n\tdone uint32\n}\n\n// Do calls the function f if and only if Do is being called for the\n// first time for this instance of Once. In other words, given\n//\tvar once Once\n// if once.Do(f) is called multiple times, only the first call will invoke f,\n// even if f has a different value in each invocation.  A new instance of\n// Once is required for each function to execute.\n//\n// Do is intended for initialization that must be run exactly once.  Since f\n// is niladic, it may be necessary to use a function literal to capture the\n// arguments to a function to be invoked by Do:\n//\tconfig.once.Do(func() { config.init(filename) })\n//\n// Because no call to Do returns until the one call to f returns, if f causes\n// Do to be called, it will deadlock.\n//\n// If f panics, Do considers it to have returned; future calls of Do return\n// without calling f.\n//\nfunc (o *Once) Do(f func()) {\n\tif atomic.LoadUint32(&o.done) == 1 { // <-- Check\n\t\treturn\n\t}\n\t// Slow-path.\n\to.m.Lock()                           // <-- Lock\n\tdefer o.m.Unlock()\n\tif o.done == 0 {                     // <-- Check\n\t\tdefer atomic.StoreUint32(&o.done, 1)\n\t\tf()\n\t}\n}\n```\n可以看到我们之前其实是借鉴了`golang`原生标准包`sync`中对`Once`实现对源码，那既然标准包中已经实现了这个`Check-Lock-Check`机制，那我们直接调用`sync`包提供`once.Do()`方法对某个方法只进行一次性调用：\n```golang\nonce.Do(func() {\n\t // perform safe initialization here\n}\n```\n那么下面是根据`sync`包提供的`sync.Once`改进的获取`singleton`实例对象最终优化版本:\n```golang\npackage singleton\n\nimport (\n    \"sync\"\n)\n\ntype singleton struct {\n}\n\nvar instance *singleton\nvar once sync.Once\n\nfunc GetInstance() *singleton {\n    once.Do(func() {\n        instance = &singleton{}\n    })\n    return instance\n}\n```\n因此使用`sync`包提供的`sync.Once`实现获取`singleton`实例对象可以说是最安全有效又简洁的方法。\n","slug":"singleton-pattern-in-go","published":1,"updated":"2016-03-21T16:45:45.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71frzh0001k2pvz3gfa025"},{"title":"golang 设计模式之observer使用总结","date":"2016-02-26T05:40:11.000Z","description":null,"_content":"\n## 前言\n观察者(`Observer`)设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。观察者模式将观察者和被观察的对象分离开,体现了面向对象设计中一个对象只做一件事情的原则，提高了应用程序的可维护性和重用性。\n<!--more-->\n\n## 实现观察者模式 \n观察者模式有很多实现方式，从根本上说，该模式必须包含两个角色：观察者(Observer)和被观察对象(Subject)。\n<center>![observer_pattern](/imgs/observer_pattern.jpg)</center>\n- 观察者\n观察者（`Observer`）将自己注册到被观察对象（`Subject`）中，被观察对象将观察者存放在一个容器（`Container`）里。\n\n- 被观察\n被观察对象(`Subject`)发生了某种变化，从容器中得到所有注册过的观察者，将变化通知观察者(`notifyObservers`)。\n\n- 撤销观察\n观察者告诉被观察者要撤销观察，被观察者从容器中将观察者去除。\n**观察者将自己注册到被观察者的容器中时，被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口。**这样的优点是：假定程序中还有别的观察者，那么只要这个观察者也是相同的接口实现即可。一个被观察者可以对应多个观察者，当被观察者发生变化的时候，它可以将消息一一通知给所有的观察者。基于接口，而不是具体的实现——这一点为程序提供了更大的灵活性。\n下面通过构建一个股民(`Observer`)和他们关注的某支具体股票(`Subject`)案例分析,\n首先观察者(`Observer`)要能注册/注销到某个被观察者(`Subject`)中，同时被观察者(`Subject`)发送变化时要能够通知到依赖它的观察者(`Observer`),由此我们需要声明一个被观察者(`Subject`)的接口：\n```golang\n// subject被观察者接口\ntype Subject interface {\n\tAttach(Observer)\n\tDetach(Observer)\n\tNotify()\n}\n```\n遵循被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口的原则，当被观察者(`Subject`)因自身改变通知观察者(`Observer`)改变时，应提供一个观察者(`Observer`)接口供被观察者(`Subject`)调用:\n```golang\n// observer观察者\ntype Observer interface {\n\tUpdate(Subject, interface{}) //更新\n}\n```\n接口设计好之后，就需要通过具体的对象来实现这些接口，在这个案例中假定股民关注的是中国石油这只股票，那么股票就是观察者(`Observer`),而中国石油股票则是被观察者(`Subject`),具体结构如下：\n```golang\n// 具体observer观察者\ntype Investors struct {\n\t/*投资人*/\n}\n\n// 具体subject被观察者\ntype ChinaPetroleum struct {\n\toblist []Observer //注册者链表\n}\n```\n\n","source":"_posts/observer-pattern-in-go-md.md","raw":"---\ntitle: \"golang 设计模式之observer使用总结\"\ndate: 2016-02-26 00:40:11\ncategories: [go-pattern]\ntags: [golang, observer]\ndescription:\n---\n\n## 前言\n观察者(`Observer`)设计模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。观察者模式将观察者和被观察的对象分离开,体现了面向对象设计中一个对象只做一件事情的原则，提高了应用程序的可维护性和重用性。\n<!--more-->\n\n## 实现观察者模式 \n观察者模式有很多实现方式，从根本上说，该模式必须包含两个角色：观察者(Observer)和被观察对象(Subject)。\n<center>![observer_pattern](/imgs/observer_pattern.jpg)</center>\n- 观察者\n观察者（`Observer`）将自己注册到被观察对象（`Subject`）中，被观察对象将观察者存放在一个容器（`Container`）里。\n\n- 被观察\n被观察对象(`Subject`)发生了某种变化，从容器中得到所有注册过的观察者，将变化通知观察者(`notifyObservers`)。\n\n- 撤销观察\n观察者告诉被观察者要撤销观察，被观察者从容器中将观察者去除。\n**观察者将自己注册到被观察者的容器中时，被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口。**这样的优点是：假定程序中还有别的观察者，那么只要这个观察者也是相同的接口实现即可。一个被观察者可以对应多个观察者，当被观察者发生变化的时候，它可以将消息一一通知给所有的观察者。基于接口，而不是具体的实现——这一点为程序提供了更大的灵活性。\n下面通过构建一个股民(`Observer`)和他们关注的某支具体股票(`Subject`)案例分析,\n首先观察者(`Observer`)要能注册/注销到某个被观察者(`Subject`)中，同时被观察者(`Subject`)发送变化时要能够通知到依赖它的观察者(`Observer`),由此我们需要声明一个被观察者(`Subject`)的接口：\n```golang\n// subject被观察者接口\ntype Subject interface {\n\tAttach(Observer)\n\tDetach(Observer)\n\tNotify()\n}\n```\n遵循被观察者不应该过问观察者的具体类型，而是应该使用观察者的接口的原则，当被观察者(`Subject`)因自身改变通知观察者(`Observer`)改变时，应提供一个观察者(`Observer`)接口供被观察者(`Subject`)调用:\n```golang\n// observer观察者\ntype Observer interface {\n\tUpdate(Subject, interface{}) //更新\n}\n```\n接口设计好之后，就需要通过具体的对象来实现这些接口，在这个案例中假定股民关注的是中国石油这只股票，那么股票就是观察者(`Observer`),而中国石油股票则是被观察者(`Subject`),具体结构如下：\n```golang\n// 具体observer观察者\ntype Investors struct {\n\t/*投资人*/\n}\n\n// 具体subject被观察者\ntype ChinaPetroleum struct {\n\toblist []Observer //注册者链表\n}\n```\n\n","slug":"observer-pattern-in-go-md","published":1,"updated":"2016-03-21T16:45:45.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71frzu0008k2pvovwbo96w"},{"title":"用Hexo+github搭建本站","date":"2016-01-15T17:10:10.000Z","description":null,"_content":"\n## 前言\n[Hexo](https://hexo.io)是一个基于`Node.js`免费开源的静态博客框架，方便将生成的静态网页托管在`github`和`Heroku`上，可快速部署，并支持`Markdown`写作，这也是选择`Hexo`部署本站的理由。无特殊说明，本站所有操作均在`Mac OS`下完成。\n<!--more-->\n## 搭建Hexo博客\n- 安装`Node.js`\n\t\t$ brew install node #该命令执行后，自动装好node和npm\n\t\t$ brew upgrade node #更新node\n安装完成后 我们测试一下 在任意目录下 创建js文件, 如helloworld.js\n``` javascript\n\t\tvar http = require('http');\n\t\thttp.createServer(function (req, res) {\n\t\t\tres.writeHead(200, {'Content-Type': 'text/plain'});\n\t\t\t\tres.end('Hello World\\n');\n\t\t\t}).listen(1337, '127.0.0.1');\n\t\tconsole.log('Server running at http://127.0.0.1:1337/');\n```\n\t在终端进入该目录下 输入node helloworld.js\n\t在浏览器中输入 地址 http://127.0.0.1:1337/ 查看结果 至此 NODEJS 运行环境已经配置好。\n\n- 安装 `hexo`\n\t\t$ npm install hexo-cli -g\n\n- 创建本地博客\n\t\t$ hexo init blog #这里是在/Users/lihong/ 这个目录下执行这个目录\n\t\t$ cd blog  #pwd 目录为: /Users/lihong/blog\n\t\t$ npm install\n\t\t$ hexo server\n浏览器输入localhost:4000即可看到搭建的博客,此时只能本地访问，可通过部署到github上，使得在公网同样可以访问。\n\n- 部署到`github`上\n注册一个`github`账号，在自己`github`主页右下角，创建一个新的`repository`。例如我的github账号为`researchlab`,那么我应该创建的repository名字应该是`researchlab.github.io`。\n编辑`_config.yml`(在`Users/lihong/blog`目录下)。你在部署时，要把下面的researchlab都换成你的账号名。(没有看到repository:, branch:等字段则加上即可）\n\n\t\tdeploy:\n\t\ttype: git\n\t\trepository: https://github.com/researchlab/researchlab.github.io.git\n\t\tbranch: master\n回到/Users/lihong/blog目录下执行如下命令\n\t\t$ hexo generate #生成静态网页\n\t\t$ hexo deploy #部署到github上\n\t**记住:** 每次修改本地文件后，需要hexo generate才能保存。每次使用命令时，都要在$pwd/blog目录下。现在可在浏览器访问`researchlab.github.io`看到我们到博客了。\n- Hexo常用命令\n\t`hexo g` == `hexo generate` #生成静态页面\n\t`hexo d` == `hexo deploy` #部署到远程服务器上（如本站部署到 github)\n\t`hexo s` == `hexo server` #启动本地服务器\n\t`hexo n` == `hexo new` #新建一篇文章或一个页面\n\n## 配置Hexo博客\nHexo站点配置用到两个文件，一个是对整站的配置`$pwd/blog/_config.yml`，另一个是对主题的配置 `$pwd/blog/themes/jacman/_config.yml`，我们来分别介绍。\n- 对整站的配置`$pwd/blog/_config.yml`\n``` md \n\t\t# Hexo Configuration\n\t\t## Docs: https://hexo.io/docs/configuration.html\n\t\t## Source: https://github.com/hexojs/hexo/\n\t\t\n\t\t# Site\n\t\ttitle: 朴实的一线码农 #站点名 站点左上角 \n\t\tsubtitle: 十年磨一剑，一步一步脚踏实地的耕种 #站点副标题\n\t\tdescription: Leehong's Blog #给搜索引擎看的, 对站点的描述，可以自定义\n\t\tauthor: Lee Hong \n\t\tlanguage: zh-CN #页面语言\n\t\ttimezone:\n\t\t\n\t\t# URL\n\t\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\t\turl: http://www.grdtechs.com\n\t\troot: /\n\t\tpermalink: :year/:month/:day/:title/\n\t\tpermalink_defaults:\n\t\t\n\t\t# Directory #目录配置 默认即可\n\t\tsource_dir: source\n\t\tpublic_dir: public\n\t\ttag_dir: tags\n\t\tarchive_dir: archives\n\t\tcategory_dir: categories\n\t\tcode_dir: downloads/code\n\t\ti18n_dir: :lang\n\t\tskip_render:\n\t\t\n\t\t# Writing 文章布局，写作格式定义 默认即可\n\t\tnew_post_name: :title.md # File name of new posts\n\t\tdefault_layout: post\n\t\ttitlecase: false # Transform title into titlecase\n\t\texternal_link: true # Open external links in new tab\n\t\tfilename_case: 0\n\t\trender_drafts: false\n\t\tpost_asset_folder: false\n\t\trelative_link: false\n\t\tfuture: true\n\t\thighlight:\n\t\t  enable: true\n\t\t  line_number: true\n\t\t  auto_detect: false\n\t\t  tab_replace:\n\t\t\n\t\t# Category & Tag\n\t\tdefault_category: uncategorized\n\t\tcategory_map:\n\t\ttag_map:\n\t\t\n\t\t# Date / Time format 期日格式 默认即可\n\t\t## Hexo uses Moment.js to parse and display date\n\t\t## You can customize the date format as defined in\n\t\t## http://momentjs.com/docs/#/displaying/format/\n\t\tdate_format: YYYY-MM-DD\n\t\ttime_format: HH:mm:ss\n\t\t\n\t\t# Pagination 每页显示的文章数目 默认每页显示10篇\n\t\t## Set per_page to 0 to disable pagination\n\t\tper_page: 10\n\t\tpagination_dir: page\n\t\t\n\t\t# Extensions\n\t\t## Plugins: https://hexo.io/plugins/\n\t\t## Themes: https://hexo.io/themes/\n\t\ttheme: jacman \n\t\t\n\t\t# Deployment 部署站点到github\n\t\t## Docs: https://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type: git \n\t\t  repository: https://github.com/researchlab/researchlab.github.io.git\n\t\t  branch: master\n```\n-  对主题的配置 `$pwd/blog/themes/jacman/_config.yml`\n``` md\n##### Menu 站点右上角导航栏\nmenu:\n  首页: /\n  归档: /archives\n  关于: /about\n## you can create `tags` and `categories` folders in `../source`.\n## And create a `index.md` file in each of them.\n## set `front-matter`as\n## layout: tags (or categories)\n## title: tags (or categories)\n## ---\n\n#### Widgets 站点右边栏\nwidgets: \n    #- github-card\n- intro\n- category\n- tag\n- links\n- douban\n- rss\n- weibo\n  ## provide eight widgets:github-card,category,tag,rss,archive,tagcloud,links,weibo\n\n#### RSS \nrss: /atom.xml ## RSS address.\n\n#### Image\nimglogo:\n  enable: true             ## display image logo true/false.\n  src: #img/logo.png        ## `.svg` and `.png` are recommended,please put image into the theme folder `/jacman/source/img`.\nfavicon: #img/favicon.ico   ## size:32px*32px,`.ico` is recommended,please put image into the theme folder `/jacman/source/img`.     \napple_icon: #img/jacman.jpg ## size:114px*114px,please put image into the theme folder `/jacman/source/img`.\nauthor_img: #img/author.jpg ## size:220px*220px.display author avatar picture.if don't want to display,please don't set this.\nbanner_img: #img/banner.jpg ## size:1920px*200px+. Banner Picture\n### Theme Color \ntheme_color:\n    theme: '#2ca6cb'    ##the defaut theme color is blue\n\n# 代码高亮主题\n# available: default | night\nhighlight_theme: default\n\n#### index post is expanding or not \nindex:\n  expand: true           ## default is unexpanding,so you can only see the short description of each post.\n  excerpt_link: Read More  \n\nclose_aside: false  #close sidebar in post page if true\nmathjax: false      #enable mathjax if true\n\n### Creative Commons License Support, see http://creativecommons.org/ \n### you can choose: by , by-nc , by-nc-nd , by-nc-sa , by-nd , by-sa , zero\ncreative_commons: none\n\n#### Toc\ntoc:\n  article: true   ## show contents in article.\n  aside: true     ## show contents in aside.\n## you can set both of the value to true of neither of them.\n## if you don't want display contents in a specified post,you can modify `front-matter` and add `toc: false`.\n\n#### Links\nlinks:\n  Linux/c/c++: http://blog.csdn.net/xiaolongwang2010,小龙王2010csdn技术博客\n\n#### Comment 添加多说评论\nduoshuo_shortname: gamedp   ## e.g. Leehong   your duoshuo short name.\ndisqus_shortname:     ## e.g. Leehong   your disqus short name.\n\n#### Share button\njiathis:\n  enable: true ## if you use jiathis as your share tool,the built-in share tool won't be display.\n  id:  2084050  ## e.g. 2084050 your jiathis ID. \n  tsina: ## e.g. 2176287895 Your weibo id,It will be used in share button.\n\n#### Analytics\ngoogle_analytics:\n  enable: false\n  id:        ## e.g. UA-46321946-2 your google analytics ID.\n  site:      ## e.g. Leehong.me your google analytics site or set the value as auto.\n## You MUST upgrade to Universal Analytics first!\n## https://developers.google.com/analytics/devguides/collection/upgrade/?hl=zh_CN\nbaidu_tongji:\n  enable: true\n  sitecode: ## e.g. e6d1f421bbc9962127a50488f9ed37d1 your baidu tongji site code\ncnzz_tongji:\n  enable: false\n  siteid:    ## e.g. 1253575964 your cnzz tongji site id\n\n#### Miscellaneous\nShowCustomFont: true  ## you can change custom font in `variable.styl` and `font.styl` which in the theme folder `/jacman/source/css`.\nfancybox: true        ## if you use gallery post or want use fancybox please set the value to true.\ntotop: true           ## if you want to scroll to top in every post set the value to true\n\n#### Custom Search\ngoogle_cse: \n  enable: false\n  cx:   ## e.g. 018294693190868310296:abnhpuysycw your Custom Search ID.\n## https://www.google.com/cse/ \n## To enable the custom search You must create a \"search\" folder in '/source' and a \"index.md\" file\n## set the 'front-matter' as\n## layout: search \n## title: search\n## ---\nbaidu_search:     ## http://zn.baidu.com/\n  enable: false\n  id:   ## e.g. \"783281470518440642\"  for your baidu search id\n  site: http://zhannei.baidu.com/cse/search  ## your can change to your site instead of the default site\n  \ntinysou_search:     ## http://tinysou.com/\n  enable: false\n  id:  ## e.g. \"4ac092ad8d749fdc6293\" for your tiny search id\n```\n\n## 用Hexo写博客\n站点配置好了之后，可通过执行如下命令开始写文章并发布\n\n\t\t$ hexo new \"the_first_post\" #在/Users/lihong/blog 目录下执行hexo new 命令\n打开新建的`source/_posts/the_first_post.md`, 如下：\n``` md\n---\ntitle: the_first_post # 这个是文章的标题,可随意修改,如: 用Hexo+github搭建本站 \ndate: 2016-01-15 12:10:10 #发表日期\ncategories: Hexo #文章分类\ntags: [Hexo,Blog] #文章标签,多于一项时用这种格式\ndescription: \n---\n# 这里是正文\n<!--more--> #这后面的正文在首页不予以显示\n```\n写好之后，执行`hexo g` 命令生成静态网页，执行`hexo s`启动本地服务器此时可通过localhost:4000在本地浏览器访问,执行`hexo d`部署到github上，则可通过公网访问了。\n\t\n## 优化Hexo博客\n- 导航栏添加\"关于\"\n\t1. `hexo new page \"about\"`\n\t2. 到`source/about/index.md`编辑内容\n\t3. 在`themes/jacman/_config.yml`中,添加如下：\n\t\t\tmenu:\n\t\t\t\t关于: /about\n\n- 添加RSS\nhexo提供了RSS的生成插件，需要手动安装和设置。步骤如下：\n\t1. 安装RSS插件到本地：`npm install hexo-generator-feed`\n\t2. 开启RSS功能：编辑`$pwd/blog/_config.yml`，添加如下代码：\n\t\t\tplugins:\n\t\t\t\t- hexo-generator-feed\n\t3. 在`themes/jacman/_config.yml`中，编辑 `rss: /atom.xml`\n\t** 注意 ** 如果发现没有生成`atom.xml`, 可接着执行`npm install hexo-generator-feed --save`即可。\n- 添加sitemap\nhexo也提供了sitemap到生成插件，与添加RSS插件类似。\n\t1. 安装sitemap插件到本地：`npm install hexo-generator-sitemap`\n\t2. 开启sitmap功能: 编辑`$pwd/blog/_config.yml`,添加如下代码：\n\t\t\tplugins:\n\t\t\t\t- hexo-generator-feed\n\t\t\t\t- hexo-generator-sitemap\n\n\t3. 访问researchlab.github.io/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。\n\n- 文章中插入图片\n使用markdown写文章，插入图片的格式为`![图片名称](链接地址)`，这里要说的是链接地址怎么写。对于hexo，有两种方式：\n\t1. 使用本地路径：在`$pwd/blog/source`目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为`/img/图片名称`。\n\t2. 使用微博图床，地址:[http://weibotuchuang.sinaapp.com/](http://weibotuchuang.sinaapp.com/)，将图片拖入区域中，会生成图片的URL，这就是链接地址。\n\n## 问题解决方案\n1. 执行`Hexo d` 出现`ERROR Deployer not found:git`,解决方案：`npm install hexo-deployer-git --save` 即可。\n","source":"_posts/hexo-blog-1.md","raw":"---\ntitle: 用Hexo+github搭建本站 \ndate: 2016-01-15 12:10:10\ncategories: Hexo\ntags: [Hexo,Blog] \ndescription: \n---\n\n## 前言\n[Hexo](https://hexo.io)是一个基于`Node.js`免费开源的静态博客框架，方便将生成的静态网页托管在`github`和`Heroku`上，可快速部署，并支持`Markdown`写作，这也是选择`Hexo`部署本站的理由。无特殊说明，本站所有操作均在`Mac OS`下完成。\n<!--more-->\n## 搭建Hexo博客\n- 安装`Node.js`\n\t\t$ brew install node #该命令执行后，自动装好node和npm\n\t\t$ brew upgrade node #更新node\n安装完成后 我们测试一下 在任意目录下 创建js文件, 如helloworld.js\n``` javascript\n\t\tvar http = require('http');\n\t\thttp.createServer(function (req, res) {\n\t\t\tres.writeHead(200, {'Content-Type': 'text/plain'});\n\t\t\t\tres.end('Hello World\\n');\n\t\t\t}).listen(1337, '127.0.0.1');\n\t\tconsole.log('Server running at http://127.0.0.1:1337/');\n```\n\t在终端进入该目录下 输入node helloworld.js\n\t在浏览器中输入 地址 http://127.0.0.1:1337/ 查看结果 至此 NODEJS 运行环境已经配置好。\n\n- 安装 `hexo`\n\t\t$ npm install hexo-cli -g\n\n- 创建本地博客\n\t\t$ hexo init blog #这里是在/Users/lihong/ 这个目录下执行这个目录\n\t\t$ cd blog  #pwd 目录为: /Users/lihong/blog\n\t\t$ npm install\n\t\t$ hexo server\n浏览器输入localhost:4000即可看到搭建的博客,此时只能本地访问，可通过部署到github上，使得在公网同样可以访问。\n\n- 部署到`github`上\n注册一个`github`账号，在自己`github`主页右下角，创建一个新的`repository`。例如我的github账号为`researchlab`,那么我应该创建的repository名字应该是`researchlab.github.io`。\n编辑`_config.yml`(在`Users/lihong/blog`目录下)。你在部署时，要把下面的researchlab都换成你的账号名。(没有看到repository:, branch:等字段则加上即可）\n\n\t\tdeploy:\n\t\ttype: git\n\t\trepository: https://github.com/researchlab/researchlab.github.io.git\n\t\tbranch: master\n回到/Users/lihong/blog目录下执行如下命令\n\t\t$ hexo generate #生成静态网页\n\t\t$ hexo deploy #部署到github上\n\t**记住:** 每次修改本地文件后，需要hexo generate才能保存。每次使用命令时，都要在$pwd/blog目录下。现在可在浏览器访问`researchlab.github.io`看到我们到博客了。\n- Hexo常用命令\n\t`hexo g` == `hexo generate` #生成静态页面\n\t`hexo d` == `hexo deploy` #部署到远程服务器上（如本站部署到 github)\n\t`hexo s` == `hexo server` #启动本地服务器\n\t`hexo n` == `hexo new` #新建一篇文章或一个页面\n\n## 配置Hexo博客\nHexo站点配置用到两个文件，一个是对整站的配置`$pwd/blog/_config.yml`，另一个是对主题的配置 `$pwd/blog/themes/jacman/_config.yml`，我们来分别介绍。\n- 对整站的配置`$pwd/blog/_config.yml`\n``` md \n\t\t# Hexo Configuration\n\t\t## Docs: https://hexo.io/docs/configuration.html\n\t\t## Source: https://github.com/hexojs/hexo/\n\t\t\n\t\t# Site\n\t\ttitle: 朴实的一线码农 #站点名 站点左上角 \n\t\tsubtitle: 十年磨一剑，一步一步脚踏实地的耕种 #站点副标题\n\t\tdescription: Leehong's Blog #给搜索引擎看的, 对站点的描述，可以自定义\n\t\tauthor: Lee Hong \n\t\tlanguage: zh-CN #页面语言\n\t\ttimezone:\n\t\t\n\t\t# URL\n\t\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\t\turl: http://www.grdtechs.com\n\t\troot: /\n\t\tpermalink: :year/:month/:day/:title/\n\t\tpermalink_defaults:\n\t\t\n\t\t# Directory #目录配置 默认即可\n\t\tsource_dir: source\n\t\tpublic_dir: public\n\t\ttag_dir: tags\n\t\tarchive_dir: archives\n\t\tcategory_dir: categories\n\t\tcode_dir: downloads/code\n\t\ti18n_dir: :lang\n\t\tskip_render:\n\t\t\n\t\t# Writing 文章布局，写作格式定义 默认即可\n\t\tnew_post_name: :title.md # File name of new posts\n\t\tdefault_layout: post\n\t\ttitlecase: false # Transform title into titlecase\n\t\texternal_link: true # Open external links in new tab\n\t\tfilename_case: 0\n\t\trender_drafts: false\n\t\tpost_asset_folder: false\n\t\trelative_link: false\n\t\tfuture: true\n\t\thighlight:\n\t\t  enable: true\n\t\t  line_number: true\n\t\t  auto_detect: false\n\t\t  tab_replace:\n\t\t\n\t\t# Category & Tag\n\t\tdefault_category: uncategorized\n\t\tcategory_map:\n\t\ttag_map:\n\t\t\n\t\t# Date / Time format 期日格式 默认即可\n\t\t## Hexo uses Moment.js to parse and display date\n\t\t## You can customize the date format as defined in\n\t\t## http://momentjs.com/docs/#/displaying/format/\n\t\tdate_format: YYYY-MM-DD\n\t\ttime_format: HH:mm:ss\n\t\t\n\t\t# Pagination 每页显示的文章数目 默认每页显示10篇\n\t\t## Set per_page to 0 to disable pagination\n\t\tper_page: 10\n\t\tpagination_dir: page\n\t\t\n\t\t# Extensions\n\t\t## Plugins: https://hexo.io/plugins/\n\t\t## Themes: https://hexo.io/themes/\n\t\ttheme: jacman \n\t\t\n\t\t# Deployment 部署站点到github\n\t\t## Docs: https://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type: git \n\t\t  repository: https://github.com/researchlab/researchlab.github.io.git\n\t\t  branch: master\n```\n-  对主题的配置 `$pwd/blog/themes/jacman/_config.yml`\n``` md\n##### Menu 站点右上角导航栏\nmenu:\n  首页: /\n  归档: /archives\n  关于: /about\n## you can create `tags` and `categories` folders in `../source`.\n## And create a `index.md` file in each of them.\n## set `front-matter`as\n## layout: tags (or categories)\n## title: tags (or categories)\n## ---\n\n#### Widgets 站点右边栏\nwidgets: \n    #- github-card\n- intro\n- category\n- tag\n- links\n- douban\n- rss\n- weibo\n  ## provide eight widgets:github-card,category,tag,rss,archive,tagcloud,links,weibo\n\n#### RSS \nrss: /atom.xml ## RSS address.\n\n#### Image\nimglogo:\n  enable: true             ## display image logo true/false.\n  src: #img/logo.png        ## `.svg` and `.png` are recommended,please put image into the theme folder `/jacman/source/img`.\nfavicon: #img/favicon.ico   ## size:32px*32px,`.ico` is recommended,please put image into the theme folder `/jacman/source/img`.     \napple_icon: #img/jacman.jpg ## size:114px*114px,please put image into the theme folder `/jacman/source/img`.\nauthor_img: #img/author.jpg ## size:220px*220px.display author avatar picture.if don't want to display,please don't set this.\nbanner_img: #img/banner.jpg ## size:1920px*200px+. Banner Picture\n### Theme Color \ntheme_color:\n    theme: '#2ca6cb'    ##the defaut theme color is blue\n\n# 代码高亮主题\n# available: default | night\nhighlight_theme: default\n\n#### index post is expanding or not \nindex:\n  expand: true           ## default is unexpanding,so you can only see the short description of each post.\n  excerpt_link: Read More  \n\nclose_aside: false  #close sidebar in post page if true\nmathjax: false      #enable mathjax if true\n\n### Creative Commons License Support, see http://creativecommons.org/ \n### you can choose: by , by-nc , by-nc-nd , by-nc-sa , by-nd , by-sa , zero\ncreative_commons: none\n\n#### Toc\ntoc:\n  article: true   ## show contents in article.\n  aside: true     ## show contents in aside.\n## you can set both of the value to true of neither of them.\n## if you don't want display contents in a specified post,you can modify `front-matter` and add `toc: false`.\n\n#### Links\nlinks:\n  Linux/c/c++: http://blog.csdn.net/xiaolongwang2010,小龙王2010csdn技术博客\n\n#### Comment 添加多说评论\nduoshuo_shortname: gamedp   ## e.g. Leehong   your duoshuo short name.\ndisqus_shortname:     ## e.g. Leehong   your disqus short name.\n\n#### Share button\njiathis:\n  enable: true ## if you use jiathis as your share tool,the built-in share tool won't be display.\n  id:  2084050  ## e.g. 2084050 your jiathis ID. \n  tsina: ## e.g. 2176287895 Your weibo id,It will be used in share button.\n\n#### Analytics\ngoogle_analytics:\n  enable: false\n  id:        ## e.g. UA-46321946-2 your google analytics ID.\n  site:      ## e.g. Leehong.me your google analytics site or set the value as auto.\n## You MUST upgrade to Universal Analytics first!\n## https://developers.google.com/analytics/devguides/collection/upgrade/?hl=zh_CN\nbaidu_tongji:\n  enable: true\n  sitecode: ## e.g. e6d1f421bbc9962127a50488f9ed37d1 your baidu tongji site code\ncnzz_tongji:\n  enable: false\n  siteid:    ## e.g. 1253575964 your cnzz tongji site id\n\n#### Miscellaneous\nShowCustomFont: true  ## you can change custom font in `variable.styl` and `font.styl` which in the theme folder `/jacman/source/css`.\nfancybox: true        ## if you use gallery post or want use fancybox please set the value to true.\ntotop: true           ## if you want to scroll to top in every post set the value to true\n\n#### Custom Search\ngoogle_cse: \n  enable: false\n  cx:   ## e.g. 018294693190868310296:abnhpuysycw your Custom Search ID.\n## https://www.google.com/cse/ \n## To enable the custom search You must create a \"search\" folder in '/source' and a \"index.md\" file\n## set the 'front-matter' as\n## layout: search \n## title: search\n## ---\nbaidu_search:     ## http://zn.baidu.com/\n  enable: false\n  id:   ## e.g. \"783281470518440642\"  for your baidu search id\n  site: http://zhannei.baidu.com/cse/search  ## your can change to your site instead of the default site\n  \ntinysou_search:     ## http://tinysou.com/\n  enable: false\n  id:  ## e.g. \"4ac092ad8d749fdc6293\" for your tiny search id\n```\n\n## 用Hexo写博客\n站点配置好了之后，可通过执行如下命令开始写文章并发布\n\n\t\t$ hexo new \"the_first_post\" #在/Users/lihong/blog 目录下执行hexo new 命令\n打开新建的`source/_posts/the_first_post.md`, 如下：\n``` md\n---\ntitle: the_first_post # 这个是文章的标题,可随意修改,如: 用Hexo+github搭建本站 \ndate: 2016-01-15 12:10:10 #发表日期\ncategories: Hexo #文章分类\ntags: [Hexo,Blog] #文章标签,多于一项时用这种格式\ndescription: \n---\n# 这里是正文\n<!--more--> #这后面的正文在首页不予以显示\n```\n写好之后，执行`hexo g` 命令生成静态网页，执行`hexo s`启动本地服务器此时可通过localhost:4000在本地浏览器访问,执行`hexo d`部署到github上，则可通过公网访问了。\n\t\n## 优化Hexo博客\n- 导航栏添加\"关于\"\n\t1. `hexo new page \"about\"`\n\t2. 到`source/about/index.md`编辑内容\n\t3. 在`themes/jacman/_config.yml`中,添加如下：\n\t\t\tmenu:\n\t\t\t\t关于: /about\n\n- 添加RSS\nhexo提供了RSS的生成插件，需要手动安装和设置。步骤如下：\n\t1. 安装RSS插件到本地：`npm install hexo-generator-feed`\n\t2. 开启RSS功能：编辑`$pwd/blog/_config.yml`，添加如下代码：\n\t\t\tplugins:\n\t\t\t\t- hexo-generator-feed\n\t3. 在`themes/jacman/_config.yml`中，编辑 `rss: /atom.xml`\n\t** 注意 ** 如果发现没有生成`atom.xml`, 可接着执行`npm install hexo-generator-feed --save`即可。\n- 添加sitemap\nhexo也提供了sitemap到生成插件，与添加RSS插件类似。\n\t1. 安装sitemap插件到本地：`npm install hexo-generator-sitemap`\n\t2. 开启sitmap功能: 编辑`$pwd/blog/_config.yml`,添加如下代码：\n\t\t\tplugins:\n\t\t\t\t- hexo-generator-feed\n\t\t\t\t- hexo-generator-sitemap\n\n\t3. 访问researchlab.github.io/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。\n\n- 文章中插入图片\n使用markdown写文章，插入图片的格式为`![图片名称](链接地址)`，这里要说的是链接地址怎么写。对于hexo，有两种方式：\n\t1. 使用本地路径：在`$pwd/blog/source`目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为`/img/图片名称`。\n\t2. 使用微博图床，地址:[http://weibotuchuang.sinaapp.com/](http://weibotuchuang.sinaapp.com/)，将图片拖入区域中，会生成图片的URL，这就是链接地址。\n\n## 问题解决方案\n1. 执行`Hexo d` 出现`ERROR Deployer not found:git`,解决方案：`npm install hexo-deployer-git --save` 即可。\n","slug":"hexo-blog-1","published":1,"updated":"2016-03-21T16:45:45.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71frzy000dk2pvo0t33ifh"},{"title":"golang xorm库使用总结","date":"2016-01-21T22:50:07.000Z","description":null,"_content":"\n## 前言\n[XORM](https://github.com/go-xorm/xorm)是一个简单而强大的Go语言`ORM(Object Relational Mapping)`库,通过调用`XORM`提供简单丰富的API接口,可以简化便捷的完成对数据库的各类操作。`XORM`目前已经支持所有主流关系型数据库,如Mysql,SQLite,Oracle,Postgres等。\n<!--more-->\n\n## 安装及特性\n`XORM`的安装很简单， 具体可参看[官网安装](http://xorm.io/)。\n未完待续\n\n\n","source":"_posts/go-xorm-summarize.md","raw":"---\ntitle: \"golang xorm库使用总结\"\ndate: 2016-01-21 17:50:07\ncategories: golang\ntags: [golang, xorm]\ndescription:\n---\n\n## 前言\n[XORM](https://github.com/go-xorm/xorm)是一个简单而强大的Go语言`ORM(Object Relational Mapping)`库,通过调用`XORM`提供简单丰富的API接口,可以简化便捷的完成对数据库的各类操作。`XORM`目前已经支持所有主流关系型数据库,如Mysql,SQLite,Oracle,Postgres等。\n<!--more-->\n\n## 安装及特性\n`XORM`的安装很简单， 具体可参看[官网安装](http://xorm.io/)。\n未完待续\n\n\n","slug":"go-xorm-summarize","published":1,"updated":"2016-03-21T16:45:45.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs02000kk2pvd8f12wtl"},{"title":"[译]GO BOOTCAMP 第三章：内置类型实战","date":"2016-01-18T02:36:28.000Z","description":null,"_content":"\n## 前言\n`Go`内置类型实战，包括类型转换，类型断言，结构类型，结构继承等内容。\n<!--more-->\n\n## 基本类型\n`Go`语言主要有如下内置基本类型，\n```golang\nbool\nstring\n\nNumeric types:\n\nuint        either 32 or 64 bits\nint         same size as uint\nuintptr     an unsigned integer large enough to store the uninterpreted bits of\n            a pointer value\nuint8       the set of all unsigned  8-bit integers (0 to 255)\nuint16      the set of all unsigned 16-bit integers (0 to 65535)\nuint32      the set of all unsigned 32-bit integers (0 to 4294967295)\nuint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)\n\nint8        the set of all signed  8-bit integers (-128 to 127)\nint16       the set of all signed 16-bit integers (-32768 to 32767)\nint32       the set of all signed 32-bit integers (-2147483648 to 2147483647)\nint64       the set of all signed 64-bit integers\n            (-9223372036854775808 to 9223372036854775807)\n\nfloat32     the set of all IEEE-754 32-bit floating-point numbers\nfloat64     the set of all IEEE-754 64-bit floating-point numbers\n\ncomplex64   the set of all complex numbers with float32 real and imaginary parts\ncomplex128  the set of all complex numbers with float64 real and imaginary parts\n\nbyte        alias for uint8\nrune        alias for int32 (represents a Unicode code point)\n```\n内置类型基本使用示例，\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/cmplx\"\n)\n\nvar (\n\tgoIsFun bool       = true\n\tmaxInt  uint64     = 1<<64 - 1\n\tcomplex complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n\tconst f = \"%T(%v)\\n\"\n\tfmt.Printf(f, goIsFun, goIsFun)\n\tfmt.Printf(f, maxInt, maxInt)\n\tfmt.Printf(f, complex, complex)\n}\n```\n输出结果:\n```bash\nbool(true)\nuint64(18446744073709551615)\ncomplex128((2+3i))\n```\n\n## 类型转换\n`T(v)`表示将`v`的类型转换为`T`类型，一些数值类型转换如下，\n```golang\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n简化一下,\n```golang \ni := 42\nf := float64(i)\nu := uint(f)\n```\n`Go`语言中不同类型之间需要显示转换才能相互赋值，如传入的参数类型与函数接收的参数不同时，需要手动进行类型转换才能传入。\n**译者注:** `Go`语言中除了`byte`和`uint8`之间以及`rune`和`int32`之间可以相互进行赋值操作外，其它不同类型直接都需要显示转换才能进行相互赋值操作。 如,\n\t```golang\n\tvar i byte = 1\n\tvar u uint8 \n\tu = i // 可以直接赋值，不需显示转换 ，同样rune 与 int32 之间也是一样的。\n\n\tvar i int = 1\n\tvar f float64 = float64(i) //这里需要显示将 int 转换float64 才能赋值成功!\n\t```\n\n## 类型断言\n如果想判断一个变量的数据类型,或将当前类型(如 interface{})作相应的类型判断,可以借助类型断言来解决。类型断言试图将当前变量转换为指定的数据类型，并返回转换之后相应的指针对象（如果转换成功）及是否转换成功的标志值。下面示例中，`timeMap`函数接受一个变量，并断言这个变量类型是否为`map[string]interface{}`类型，如果是则为其初始化一个`key`为`updated_at`,`value`为`time.Now()`的值对。\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc timeMap(y interface{}) {\n\tz, ok := y.(map[string]interface{})\n\tif ok {\n\t\tz[\"updated_at\"] = time.Now()\n\t}\n}\n\nfunc main() {\n\tfoo := map[string]interface{}{\n\t\t\"Matt\": 42,\n\t}\n\ttimeMap(foo)\n\t\tfmt.Println(foo)\n}\n```\n`Go`语言并不对空接口`interface{}`进行类型断言，如果函数内部如对不同类型参数会作出不同的处理，则通常需借助类型断言来完成，如：\n```golang\ntype Stringer interface {\n\tString() string\n}\n\ntype fakeString struct {\n\tcontent string\n}\n\nfunc (s *fakeString) String() string {\n\treturn s.content\n}\n\nfunc printString(value interface{}) {\n\tswitch str := value.(type) {\n\tcase string:\n\t\tfmt.Println(str)\n\tcase Stringer:\n\t\tfmt.Println(str.String())\n\t}\n}\n```\n如果给`printString`传入一个`fakeString`,因为`fakeString`实现了`Stringer`方法，那么`printString`中会处理`Stringer`这个case,如果直接传入一个字符串给`printString`，则显然会处理`string`这个case 从而直接输出传入的字符串。\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/type_assertion.go)\n类型断言也可以用于判断具体的`error`类型，如:\n```golang\nif err != nil {\n\t  if msqlerr, ok := err.(*mysql.MySQLError); ok && msqlerr.Number == 1062 {\n\t    \tlog.Println(\"We got a MySQL duplicate :(\")\n\t   } else {\n\t\t    return err\n\t   }\n}\n```\n\n## 结构\n`struct`是多个字段或属性的集合，用户也可以自定义一个像`struct`或`interface`这样的数据类型。如果你学过面向对象编程，你可以将`struct`理解为一个轻量级的`class`支持字段属性的集合，但不支持继承。`struct`中默认提供`get`和`set`方法，需要注意的是只有首字母大写的`struct`变量才能被包访问。`struct`可以通过`Name:`后跟初始值来初始化`struct`,这样初始化时可以不按`struct`中字段声明的顺序进行初始化，如果在`struct`变量前加上`&`符号，返回的是一个指向这个`struct`的指针对象。\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Bootcamp struct {\n\t// Latitude of the event\n\tLat float64\n\t// Longitude of the event\n\tLon float64\n\t// Date of the event\n\tDate time.Time\n}\n\nfunc main() {\n\tfmt.Println(Bootcamp{\n\t\tLat:  34.012836,\n\t\tLon:  -118.495338,\n\t\tDate: time.Now(),\n\t})\n}\n```\n声明并初始化`struct`对象，\n```golang\npackage main\n\nimport \"fmt\"\n\ntype Point struct {\n\tX, Y int\n}\n\nvar (\n\tp = Point{1, 2}  // 初始化一个Point对象\n\tq = &Point{1, 2} // 初始化一个Point指针对象\n\tr = Point{X: 1}  // Y值默认为0 \n\ts = Point{}      // X和Y的值都默认为0\n)\n\nfunc main() {\n\tfmt.Println(p, q, r, s)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/declaration_struct.go)\n\n可通过`.`符号访问`struct`中的成员变量，\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Bootcamp struct {\n\tLat, Lon float64\n\tDate     time.Time\n}\n\nfunc main() {\n\tevent := Bootcamp{\n\t\tLat: 34.012836,\n\t\tLon: -118.495338,\n\t}\n\tevent.Date = time.Now()\n\tfmt.Printf(\"Event on %s, location (%f, %f)\",event.Date, event.Lat, event.Lon)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/access_struct_field.go)\n\n## 初始化\n`Go`支持用`new`表达式初始化变量，分配一个类型零值并返回指向这个类型的指针给变量。\n```golang\nx := new(int)\n```\n一种常见的初始化一个包含`struct`或引用变量的方法是创建一个`struct`字段。另一种方法是通过创建构造函数来完成初始化操作。这两种方法是当需要自定义初始化字段值常用的两种方法。下面用`new`方法和用空`struct`字段初始化一个`struct`是等价的，如:\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Bootcamp struct {\n\tLat float64\n\tLon float64\n}\n\nfunc main() {\n\tx := new(Bootcamp)\n\ty := &Bootcamp{}\n\tfmt.Println(*x == *y)\n}\n```\n上面`x`和`y`的初始化操作是等价的；后面要接触的`slices`，`maps`和`channels`结构初始化一般需要自定义初始化字段如长度，容量等，所以这些结构通常用`make`关键字来初始化操作。\n\n## 组合vs继承\n`Go`不支持面向对象编程中的继承操作，但是可以使用组合和接口来完成继承的操作。`Go`支持`OOP`中的组合（或者说绑定）操作。下面是一个关于地址操作的示例:\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId       int\n\tName     string\n\tLocation string\n}\n\ntype Player struct {\n\tUser\n\tGameId   int\n}\n\nfunc main() {\n\tp := Player{}\n\tp.Id = 42\n\tp.Name = \"Matt\"\n\tp.Location = \"LA\"\n\tp.GameId = 90404\n\tfmt.Printf(\"%+v\", p)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/composition_case.go)\n上面地址的案例是一个经典的`OOP`例子，现在考虑到`Player` struct和`User`struct有相同的字段，但是`Player`还有一个自己的`GameId`字段，用`OOP`思想则声明`Player`和`User`struct，会存在重复声明相同的字段，但是在`Go`中可以通过组合`struct`来简化这样的情况,\n```golang\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n```\n现在可通过两种方法来初始化一个`Player`结构。第一种使用`.`来设置`struct`字段,\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n\nfunc main() {\n\tp := Player{}\n\tp.Id = 42\n\tp.Name = \"Matt\"\n\tp.Location = \"LA\"\n\tp.GameId = 90404\n\tfmt.Printf(\"%+v\", p)\n}\n```\n另一种初始化方法是使用`struct`字段初始化语法`Name:`来初始化，\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n\nfunc main() {\n\tp := Player{\n\tUser{Id: 42, Name: \"Matt\", Location: \"LA\"},90404,}\n\tfmt.Printf(\"Id: %d, Name: %s, Location: %s, Game id: %d\\n\",\tp.Id, p.Name, p.Location, p.GameId)\n\t// Directly set a field define on the Player struct\n\tp.Id = 11\n\tfmt.Printf(\"%+v\", p)\n}\n```\n当需要调用匿名结构中的字段时，不能直接引用相应的字段，而是需要通过当前结构对象来调用，如`User`作为匿名结构嵌入在`Player`中，所以通过`Player`对象能调用到`User`中到字段，但是不能直接通过`User`中到字段名去调用，示例如:\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\nfunc (u *User) Greetings() string {\n\treturn fmt.Sprintf(\"Hi %s from %s\",u.Name, u.Location)\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n\nfunc main() {\n\tp := Player{}\n\tp.Id = 42\n\tp.Name = \"Matt\"\n\tp.Location = \"LA\"\n\tfmt.Println(p.Greetings())\n}\n```\n通过当前结构体对象引用嵌入到匿名结构体中的字段对构建数据结构非常有效，当嵌入对匿名结构实现了某个接口，那当前结构也就自动实现了这个接口了。下面来看另一个示例，`Job`结构中嵌入了`Logger`结构，那相当于`Job`也实现了`Logger`实现的了日志接口，如：\n```golang\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\ntype Job struct {\n\tCommand string\n\tLogger  *log.Logger\n}\n\nfunc main() {\n\tjob := &Job{\"demo\", log.New(os.Stderr, \"Job: \", log.Ldate)}\n\t// 也可这样初始化job\n\t// job := &Job{Command: \"demo\",\n    //       Logger: log.New(os.Stderr, \"Job: \", log.Ldate)}\n\tjob.Logger.Print(\"test\")\n}\n```\n`Job`结构中有个字段`Logger`是一个指向`log.Logger`类型的指针，在初始化值之后，则`Job`对象就可以通过这样来调用`log.Logger`实现的`Print`函数了，`job.Logger.Print()`。既然`Logger`本身是一个指向`log.Logger`类型的指针，那我们直接在`Job`结构中嵌入一个`log.Logger`指针对象，那`Job`结构对象不就可以直接调用`job.Logger`实现的`Print`方法？ 答案是可以的， 如:\n```golang\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\ntype Job struct {\n\tCommand string\n\t*log.Logger //嵌入匿名指针类型\n}\n\nfunc main() {\n\tjob := &Job{\"demo\", log.New(os.Stderr, \"Job: \", log.Ldate)}\n\tjob.Print(\"starting now...\") //直接调用log.Logger实现的Print()方法\n}\n```\n注意在使用`log.Logger`之前需要初始化，如果匿名结构实现了某个接口，也相当于使嵌入这个匿名结构的当前结构也实现了这个接口，非常方便高效。\n\n## 案例分析\n在`Go`中参数是默认是值传递,所以从上述`User/Player`示例中，你可能注意到在`Player`结构中嵌入`User`结构指针比直接嵌入`User`结构对象更好。确实如果嵌入到结构体比较简单时，使用哪种方法都差不多，如果像现实中`User`结构其实非常复杂，那选择传入引用则是更好到选择。修改上述代码如：\n```golang\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\nfunc (u *User) Greetings() string {\n\treturn fmt.Sprintf(\"Hi %s from %s\",u.Name, u.Location)\n}\n\ntype Player struct {\n\t*User\n\tGameId int\n}\n```\n上述将代码修改为嵌入`User`指针，那在调用`User`中字段之后，需要对`User`先初始化，详情看[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/pass_ptr.go)\n\n- Question: 为`User`结构指针类型定义一个`Greetings`方法，如何直接去调用它呢？\n- Solution:\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\nfunc (u *User) Greetings() string {\n\treturn fmt.Sprintf(\"Hi %s from %s\",u.Name, u.Location)\n}\n\ntype Player struct {\n\t*User\n\tGameId int\n}\n\nfunc NewPlayer(id int, name, location string, gameId int) *Player {\n\treturn &Player{\n\t\tUser:   &User{id, name, location},\n\t\tGameId: gameId,\n\t}\n}\n\nfunc main() {\n\tp := NewPlayer(42, \"Matt\", \"LA\", 90404)\n\tfmt.Println(p.Greetings())\n}\n```\n上述案例通过`NewPlayer`方法在使用`User`中的`Greetings`前，先初始化了`User`结构指针,如果在使用前不初始化，则调用`Greetings`时，是用一个`nil ptr`去调用`Greetings`，显然这样调用不成功，所以使用前需要先初始化，得到返回指向这个匿名对象的地址指针对象，才能进一步通过这个指针对象去调用匿名结构中的字段属性。\n\n\n** 《GO BOOTCAMP》第三章翻译完成，原著第三章出处：[Chapter 3 Types](http://www.golangbootcamp.com/book/types) **\n","source":"_posts/go-types.md","raw":"---\ntitle: \"[译]GO BOOTCAMP 第三章：内置类型实战\"\ndate: 2016-01-17 21:36:28\ncategories: go-bootcamp\ntags: [golang]\ndescription:\n---\n\n## 前言\n`Go`内置类型实战，包括类型转换，类型断言，结构类型，结构继承等内容。\n<!--more-->\n\n## 基本类型\n`Go`语言主要有如下内置基本类型，\n```golang\nbool\nstring\n\nNumeric types:\n\nuint        either 32 or 64 bits\nint         same size as uint\nuintptr     an unsigned integer large enough to store the uninterpreted bits of\n            a pointer value\nuint8       the set of all unsigned  8-bit integers (0 to 255)\nuint16      the set of all unsigned 16-bit integers (0 to 65535)\nuint32      the set of all unsigned 32-bit integers (0 to 4294967295)\nuint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)\n\nint8        the set of all signed  8-bit integers (-128 to 127)\nint16       the set of all signed 16-bit integers (-32768 to 32767)\nint32       the set of all signed 32-bit integers (-2147483648 to 2147483647)\nint64       the set of all signed 64-bit integers\n            (-9223372036854775808 to 9223372036854775807)\n\nfloat32     the set of all IEEE-754 32-bit floating-point numbers\nfloat64     the set of all IEEE-754 64-bit floating-point numbers\n\ncomplex64   the set of all complex numbers with float32 real and imaginary parts\ncomplex128  the set of all complex numbers with float64 real and imaginary parts\n\nbyte        alias for uint8\nrune        alias for int32 (represents a Unicode code point)\n```\n内置类型基本使用示例，\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/cmplx\"\n)\n\nvar (\n\tgoIsFun bool       = true\n\tmaxInt  uint64     = 1<<64 - 1\n\tcomplex complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n\tconst f = \"%T(%v)\\n\"\n\tfmt.Printf(f, goIsFun, goIsFun)\n\tfmt.Printf(f, maxInt, maxInt)\n\tfmt.Printf(f, complex, complex)\n}\n```\n输出结果:\n```bash\nbool(true)\nuint64(18446744073709551615)\ncomplex128((2+3i))\n```\n\n## 类型转换\n`T(v)`表示将`v`的类型转换为`T`类型，一些数值类型转换如下，\n```golang\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n简化一下,\n```golang \ni := 42\nf := float64(i)\nu := uint(f)\n```\n`Go`语言中不同类型之间需要显示转换才能相互赋值，如传入的参数类型与函数接收的参数不同时，需要手动进行类型转换才能传入。\n**译者注:** `Go`语言中除了`byte`和`uint8`之间以及`rune`和`int32`之间可以相互进行赋值操作外，其它不同类型直接都需要显示转换才能进行相互赋值操作。 如,\n\t```golang\n\tvar i byte = 1\n\tvar u uint8 \n\tu = i // 可以直接赋值，不需显示转换 ，同样rune 与 int32 之间也是一样的。\n\n\tvar i int = 1\n\tvar f float64 = float64(i) //这里需要显示将 int 转换float64 才能赋值成功!\n\t```\n\n## 类型断言\n如果想判断一个变量的数据类型,或将当前类型(如 interface{})作相应的类型判断,可以借助类型断言来解决。类型断言试图将当前变量转换为指定的数据类型，并返回转换之后相应的指针对象（如果转换成功）及是否转换成功的标志值。下面示例中，`timeMap`函数接受一个变量，并断言这个变量类型是否为`map[string]interface{}`类型，如果是则为其初始化一个`key`为`updated_at`,`value`为`time.Now()`的值对。\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc timeMap(y interface{}) {\n\tz, ok := y.(map[string]interface{})\n\tif ok {\n\t\tz[\"updated_at\"] = time.Now()\n\t}\n}\n\nfunc main() {\n\tfoo := map[string]interface{}{\n\t\t\"Matt\": 42,\n\t}\n\ttimeMap(foo)\n\t\tfmt.Println(foo)\n}\n```\n`Go`语言并不对空接口`interface{}`进行类型断言，如果函数内部如对不同类型参数会作出不同的处理，则通常需借助类型断言来完成，如：\n```golang\ntype Stringer interface {\n\tString() string\n}\n\ntype fakeString struct {\n\tcontent string\n}\n\nfunc (s *fakeString) String() string {\n\treturn s.content\n}\n\nfunc printString(value interface{}) {\n\tswitch str := value.(type) {\n\tcase string:\n\t\tfmt.Println(str)\n\tcase Stringer:\n\t\tfmt.Println(str.String())\n\t}\n}\n```\n如果给`printString`传入一个`fakeString`,因为`fakeString`实现了`Stringer`方法，那么`printString`中会处理`Stringer`这个case,如果直接传入一个字符串给`printString`，则显然会处理`string`这个case 从而直接输出传入的字符串。\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/type_assertion.go)\n类型断言也可以用于判断具体的`error`类型，如:\n```golang\nif err != nil {\n\t  if msqlerr, ok := err.(*mysql.MySQLError); ok && msqlerr.Number == 1062 {\n\t    \tlog.Println(\"We got a MySQL duplicate :(\")\n\t   } else {\n\t\t    return err\n\t   }\n}\n```\n\n## 结构\n`struct`是多个字段或属性的集合，用户也可以自定义一个像`struct`或`interface`这样的数据类型。如果你学过面向对象编程，你可以将`struct`理解为一个轻量级的`class`支持字段属性的集合，但不支持继承。`struct`中默认提供`get`和`set`方法，需要注意的是只有首字母大写的`struct`变量才能被包访问。`struct`可以通过`Name:`后跟初始值来初始化`struct`,这样初始化时可以不按`struct`中字段声明的顺序进行初始化，如果在`struct`变量前加上`&`符号，返回的是一个指向这个`struct`的指针对象。\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Bootcamp struct {\n\t// Latitude of the event\n\tLat float64\n\t// Longitude of the event\n\tLon float64\n\t// Date of the event\n\tDate time.Time\n}\n\nfunc main() {\n\tfmt.Println(Bootcamp{\n\t\tLat:  34.012836,\n\t\tLon:  -118.495338,\n\t\tDate: time.Now(),\n\t})\n}\n```\n声明并初始化`struct`对象，\n```golang\npackage main\n\nimport \"fmt\"\n\ntype Point struct {\n\tX, Y int\n}\n\nvar (\n\tp = Point{1, 2}  // 初始化一个Point对象\n\tq = &Point{1, 2} // 初始化一个Point指针对象\n\tr = Point{X: 1}  // Y值默认为0 \n\ts = Point{}      // X和Y的值都默认为0\n)\n\nfunc main() {\n\tfmt.Println(p, q, r, s)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/declaration_struct.go)\n\n可通过`.`符号访问`struct`中的成员变量，\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Bootcamp struct {\n\tLat, Lon float64\n\tDate     time.Time\n}\n\nfunc main() {\n\tevent := Bootcamp{\n\t\tLat: 34.012836,\n\t\tLon: -118.495338,\n\t}\n\tevent.Date = time.Now()\n\tfmt.Printf(\"Event on %s, location (%f, %f)\",event.Date, event.Lat, event.Lon)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/access_struct_field.go)\n\n## 初始化\n`Go`支持用`new`表达式初始化变量，分配一个类型零值并返回指向这个类型的指针给变量。\n```golang\nx := new(int)\n```\n一种常见的初始化一个包含`struct`或引用变量的方法是创建一个`struct`字段。另一种方法是通过创建构造函数来完成初始化操作。这两种方法是当需要自定义初始化字段值常用的两种方法。下面用`new`方法和用空`struct`字段初始化一个`struct`是等价的，如:\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Bootcamp struct {\n\tLat float64\n\tLon float64\n}\n\nfunc main() {\n\tx := new(Bootcamp)\n\ty := &Bootcamp{}\n\tfmt.Println(*x == *y)\n}\n```\n上面`x`和`y`的初始化操作是等价的；后面要接触的`slices`，`maps`和`channels`结构初始化一般需要自定义初始化字段如长度，容量等，所以这些结构通常用`make`关键字来初始化操作。\n\n## 组合vs继承\n`Go`不支持面向对象编程中的继承操作，但是可以使用组合和接口来完成继承的操作。`Go`支持`OOP`中的组合（或者说绑定）操作。下面是一个关于地址操作的示例:\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId       int\n\tName     string\n\tLocation string\n}\n\ntype Player struct {\n\tUser\n\tGameId   int\n}\n\nfunc main() {\n\tp := Player{}\n\tp.Id = 42\n\tp.Name = \"Matt\"\n\tp.Location = \"LA\"\n\tp.GameId = 90404\n\tfmt.Printf(\"%+v\", p)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/composition_case.go)\n上面地址的案例是一个经典的`OOP`例子，现在考虑到`Player` struct和`User`struct有相同的字段，但是`Player`还有一个自己的`GameId`字段，用`OOP`思想则声明`Player`和`User`struct，会存在重复声明相同的字段，但是在`Go`中可以通过组合`struct`来简化这样的情况,\n```golang\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n```\n现在可通过两种方法来初始化一个`Player`结构。第一种使用`.`来设置`struct`字段,\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n\nfunc main() {\n\tp := Player{}\n\tp.Id = 42\n\tp.Name = \"Matt\"\n\tp.Location = \"LA\"\n\tp.GameId = 90404\n\tfmt.Printf(\"%+v\", p)\n}\n```\n另一种初始化方法是使用`struct`字段初始化语法`Name:`来初始化，\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n\nfunc main() {\n\tp := Player{\n\tUser{Id: 42, Name: \"Matt\", Location: \"LA\"},90404,}\n\tfmt.Printf(\"Id: %d, Name: %s, Location: %s, Game id: %d\\n\",\tp.Id, p.Name, p.Location, p.GameId)\n\t// Directly set a field define on the Player struct\n\tp.Id = 11\n\tfmt.Printf(\"%+v\", p)\n}\n```\n当需要调用匿名结构中的字段时，不能直接引用相应的字段，而是需要通过当前结构对象来调用，如`User`作为匿名结构嵌入在`Player`中，所以通过`Player`对象能调用到`User`中到字段，但是不能直接通过`User`中到字段名去调用，示例如:\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\nfunc (u *User) Greetings() string {\n\treturn fmt.Sprintf(\"Hi %s from %s\",u.Name, u.Location)\n}\n\ntype Player struct {\n\tUser\n\tGameId int\n}\n\nfunc main() {\n\tp := Player{}\n\tp.Id = 42\n\tp.Name = \"Matt\"\n\tp.Location = \"LA\"\n\tfmt.Println(p.Greetings())\n}\n```\n通过当前结构体对象引用嵌入到匿名结构体中的字段对构建数据结构非常有效，当嵌入对匿名结构实现了某个接口，那当前结构也就自动实现了这个接口了。下面来看另一个示例，`Job`结构中嵌入了`Logger`结构，那相当于`Job`也实现了`Logger`实现的了日志接口，如：\n```golang\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\ntype Job struct {\n\tCommand string\n\tLogger  *log.Logger\n}\n\nfunc main() {\n\tjob := &Job{\"demo\", log.New(os.Stderr, \"Job: \", log.Ldate)}\n\t// 也可这样初始化job\n\t// job := &Job{Command: \"demo\",\n    //       Logger: log.New(os.Stderr, \"Job: \", log.Ldate)}\n\tjob.Logger.Print(\"test\")\n}\n```\n`Job`结构中有个字段`Logger`是一个指向`log.Logger`类型的指针，在初始化值之后，则`Job`对象就可以通过这样来调用`log.Logger`实现的`Print`函数了，`job.Logger.Print()`。既然`Logger`本身是一个指向`log.Logger`类型的指针，那我们直接在`Job`结构中嵌入一个`log.Logger`指针对象，那`Job`结构对象不就可以直接调用`job.Logger`实现的`Print`方法？ 答案是可以的， 如:\n```golang\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\ntype Job struct {\n\tCommand string\n\t*log.Logger //嵌入匿名指针类型\n}\n\nfunc main() {\n\tjob := &Job{\"demo\", log.New(os.Stderr, \"Job: \", log.Ldate)}\n\tjob.Print(\"starting now...\") //直接调用log.Logger实现的Print()方法\n}\n```\n注意在使用`log.Logger`之前需要初始化，如果匿名结构实现了某个接口，也相当于使嵌入这个匿名结构的当前结构也实现了这个接口，非常方便高效。\n\n## 案例分析\n在`Go`中参数是默认是值传递,所以从上述`User/Player`示例中，你可能注意到在`Player`结构中嵌入`User`结构指针比直接嵌入`User`结构对象更好。确实如果嵌入到结构体比较简单时，使用哪种方法都差不多，如果像现实中`User`结构其实非常复杂，那选择传入引用则是更好到选择。修改上述代码如：\n```golang\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\nfunc (u *User) Greetings() string {\n\treturn fmt.Sprintf(\"Hi %s from %s\",u.Name, u.Location)\n}\n\ntype Player struct {\n\t*User\n\tGameId int\n}\n```\n上述将代码修改为嵌入`User`指针，那在调用`User`中字段之后，需要对`User`先初始化，详情看[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch03/pass_ptr.go)\n\n- Question: 为`User`结构指针类型定义一个`Greetings`方法，如何直接去调用它呢？\n- Solution:\n```golang\npackage main\n\nimport \"fmt\"\n\ntype User struct {\n\tId             int\n\tName, Location string\n}\n\nfunc (u *User) Greetings() string {\n\treturn fmt.Sprintf(\"Hi %s from %s\",u.Name, u.Location)\n}\n\ntype Player struct {\n\t*User\n\tGameId int\n}\n\nfunc NewPlayer(id int, name, location string, gameId int) *Player {\n\treturn &Player{\n\t\tUser:   &User{id, name, location},\n\t\tGameId: gameId,\n\t}\n}\n\nfunc main() {\n\tp := NewPlayer(42, \"Matt\", \"LA\", 90404)\n\tfmt.Println(p.Greetings())\n}\n```\n上述案例通过`NewPlayer`方法在使用`User`中的`Greetings`前，先初始化了`User`结构指针,如果在使用前不初始化，则调用`Greetings`时，是用一个`nil ptr`去调用`Greetings`，显然这样调用不成功，所以使用前需要先初始化，得到返回指向这个匿名对象的地址指针对象，才能进一步通过这个指针对象去调用匿名结构中的字段属性。\n\n\n** 《GO BOOTCAMP》第三章翻译完成，原著第三章出处：[Chapter 3 Types](http://www.golangbootcamp.com/book/types) **\n","slug":"go-types","published":1,"updated":"2016-03-21T16:45:45.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs06000qk2pvq6yoim7q"},{"title":"golang类型转换(指定精度/四舍五入)","date":"2016-03-24T06:06:54.000Z","description":null,"_content":"\n## 前言\n`Go`的数据类型很多都需要显示转换才能使用,比如`string`转`float64`指定精度等。转换中常用到的第三方包为`strconv`和`math`包。\n<!--more-->\n\n## 整型转字符串\n```golang\nstrconv.Itoa(i) //方法1\nstrconv.FormatInt(int64(i),10) //方法2\n```\n\n## 字符串转整型\n```golang\nstrconv.Atoi(s) //方法1\nstrconv.ParseInt(s,10,0) //方法2\n```\n\n## bytes转float64\n```golang\nfunc bytesToFloat64(bytes []byte) float64 {\n\tbits := binary.LittleEndian.Uint64(bytes)\n\treturn math.Float64frombits(bits)\n}\n```\n\n## float64转bytes\n```golang\nfunc float64ToBytes(input float64) []byte {\n\tbits := math.Float64bits(input)\n\tbytes := make([]byte,8) //这里表示[]uint8, 所以用了 8\n\tbinary.LittleEndian.PutUint64(bytes,bits)\n\treturn bytes\n}\n```\n\n## float64转string \n```golang\nfunc FloatToStr(num float64, floatPartLen int) string {\n\treturn strconv.FormatFloat(num,'f',floatPartLen,64) //这里64改为32，则表示float32\n}\n```\n\n## string转float64\n`string`转`float64` 这里有两种方法，都支持指定精度。** 注意：所有数字要在表现层显示最好转换为字符串传送给表现层，如果用于后端计算则转换为数字即可。比如：数字2.10 如果用保持5位数字精度显示： 那么 数字2.10 显示为：2.1, 而将2.10转换为字符串同时保持5位精度，则显示为: 2.10000。但是它们都是转换为了5位精度的，只是显示的时候，数字2.10000 直接显示为2.1了， 所以要显示精度则转换为字符串，要用于计算则转换为数字。**\n\n方法1： 只支持指定精度 \n```golang\nfunc strToFloat64(str string, len int) float64 {\n\tlenstr := \"%.\" + strconv.Itoa(len) + \"f\"\n\tvalue,_ := strconv.ParseFloat(str,64)\n\tnstr := fmt.Sprintf(lenstr,value)\n\tval,_ := strconv.ParseFloat(nstr,64)\n\treturn val\n}\n```\n\n方法2：支持指定精度，支持是否四舍五入\n```golang\nfunc strToFloat64Round(str string, prec int, round bool) float64 {\n\tf,_ := strconv.ParseFloat(str,64)\n\treturn Precision(f,prec,round)\n}\n\nfunc Precision(f float64, prec int, round bool) float64 {\n\tpow10_n := math.Pow10(prec)\n\tif round {\n\t\treturn math.Trunc(f + 0.5/pow10_n)*pow10_n) / pow10_n\t\n\t}\n\treturn math.Trunc((f)*pow10_n) / pow10_n\n}\n```\n具体请参考[[示例代码](https://github.com/researchlab/go-learning/blob/master/base/convert.go)]\n","source":"_posts/go-type-convert.md","raw":"---\ntitle: \"golang类型转换(指定精度/四舍五入)\"\ndate: 2016-03-24 02:06:54\ncategories: golang\ntags: [golang]\ndescription: \n---\n\n## 前言\n`Go`的数据类型很多都需要显示转换才能使用,比如`string`转`float64`指定精度等。转换中常用到的第三方包为`strconv`和`math`包。\n<!--more-->\n\n## 整型转字符串\n```golang\nstrconv.Itoa(i) //方法1\nstrconv.FormatInt(int64(i),10) //方法2\n```\n\n## 字符串转整型\n```golang\nstrconv.Atoi(s) //方法1\nstrconv.ParseInt(s,10,0) //方法2\n```\n\n## bytes转float64\n```golang\nfunc bytesToFloat64(bytes []byte) float64 {\n\tbits := binary.LittleEndian.Uint64(bytes)\n\treturn math.Float64frombits(bits)\n}\n```\n\n## float64转bytes\n```golang\nfunc float64ToBytes(input float64) []byte {\n\tbits := math.Float64bits(input)\n\tbytes := make([]byte,8) //这里表示[]uint8, 所以用了 8\n\tbinary.LittleEndian.PutUint64(bytes,bits)\n\treturn bytes\n}\n```\n\n## float64转string \n```golang\nfunc FloatToStr(num float64, floatPartLen int) string {\n\treturn strconv.FormatFloat(num,'f',floatPartLen,64) //这里64改为32，则表示float32\n}\n```\n\n## string转float64\n`string`转`float64` 这里有两种方法，都支持指定精度。** 注意：所有数字要在表现层显示最好转换为字符串传送给表现层，如果用于后端计算则转换为数字即可。比如：数字2.10 如果用保持5位数字精度显示： 那么 数字2.10 显示为：2.1, 而将2.10转换为字符串同时保持5位精度，则显示为: 2.10000。但是它们都是转换为了5位精度的，只是显示的时候，数字2.10000 直接显示为2.1了， 所以要显示精度则转换为字符串，要用于计算则转换为数字。**\n\n方法1： 只支持指定精度 \n```golang\nfunc strToFloat64(str string, len int) float64 {\n\tlenstr := \"%.\" + strconv.Itoa(len) + \"f\"\n\tvalue,_ := strconv.ParseFloat(str,64)\n\tnstr := fmt.Sprintf(lenstr,value)\n\tval,_ := strconv.ParseFloat(nstr,64)\n\treturn val\n}\n```\n\n方法2：支持指定精度，支持是否四舍五入\n```golang\nfunc strToFloat64Round(str string, prec int, round bool) float64 {\n\tf,_ := strconv.ParseFloat(str,64)\n\treturn Precision(f,prec,round)\n}\n\nfunc Precision(f float64, prec int, round bool) float64 {\n\tpow10_n := math.Pow10(prec)\n\tif round {\n\t\treturn math.Trunc(f + 0.5/pow10_n)*pow10_n) / pow10_n\t\n\t}\n\treturn math.Trunc((f)*pow10_n) / pow10_n\n}\n```\n具体请参考[[示例代码](https://github.com/researchlab/go-learning/blob/master/base/convert.go)]\n","slug":"go-type-convert","published":1,"updated":"2016-03-25T01:37:09.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs09000uk2pvwbkvt8s3"},{"title":"golang reflect使用总结","date":"2016-02-17T13:57:59.000Z","description":null,"_content":"\n## 前言\n反射是一种检查存储在接口变量中的`<值,类型>`对的机制，借助go反射包提供的`reflect.TypeOf`和`reflect.ValueOf`可以方便的访问到一个接口值的`reflect.Type`和`reflect.Value`部分，从而可进一步得到这个接口的结构类型和对其进行值的修改操作。 \n<!--more-->\n## 反射的使用\n1. **获取接口对象的字段,类型和方法信息**\n先定义个通用的结构体\n\t\ttype User struct{\n\t\t\tId int\n\t\t\tName string\n\t\t\tAge int\n\t\t}\n将接口对象类型信息映射为反射类型信息\n```golang\n\tfunc Info(o interface{}) {\n\t\tt := reflect.TypeOf(o)         //获取接口的类型\n\t\tfmt.Println(\"Type:\", t.Name()) //t.Name() 获取接口的名称\n\t\t\n\t\tif t.Kind() != refelct.Struct { //通过Kind()来判断反射出的类型是否为需要的类型\n\t\t\tfmt.Println(\"err: type invalid!\")\t\t\n\t\t\treturn\n\t\t}\t\t\n\n\t\tv := reflect.ValueOf(o) //获取接口的值类型\n\t\tfmt.Println(\"Fields:\")\n\t\t\t\t\n\t\tfor i := 0; i < t.NumField(); i++ { //NumField取出这个接口所有的字段数量\n\t\tf := t.Field(i)                                   //取得结构体的第i个字段\n\t\tval := v.Field(i).Interface()                     //取得字段的值\n\t\tfmt.Printf(\"%6s: %v = %v\\n\", f.Name, f.Type, val) //第i个字段的名称,类型,值\n\t\t}\n\n\t\tfor i := 0; i < t.NumMethod(); i++{\n\t\t\tm := t.Method(i)\n\t\t\tfmt.Printf(\"%6s: %v\\n\", m.Name,m.Type) //获取方法的名称和类型\t   \n\t\t}\n\t}\t\n``` \n获取接口对象的类型名称，通过`refelct.TypeOf()`获取接口对象的类型,并通过`Name()`方法获取接口的名称。\n获取对象中所有字段的名称,类型和值,通过`reflect.ValueOf()`获取接口对象的值类型取得字段的名称和类型,然后通过`v.Field(i).Interface()`取得第i个字段的值。\n还可以通过`NumMethod()`循环获取接口对象所有方法的名称和类型。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/reflect/01reflect.go)\n\n2. **反射接口对象中的匿名或嵌入字段信息**\n先再添加一个Manager结构,User作为它的匿名字段\n\t\ttype Manager struct{\n\t\t\tUser\n\t\t\ttitle string\n\t\t}\n初始化Manager的两种方法：\n\t\tm0 := Manager{User: User{1,\"Mike\",11},title: \"Man\"}\n\t\tm1 := Manager{User{1,\"Mike\",11},\"Man\"} //这种初始化,赋值顺序必须和结构体中的声明顺序相同! \n现在如何来取出Manager中的匿名字段User？\n\t\tt := refelct.TypeOf(m)\n\t\tfmt.Printf(\"%#v\\n\", t.Field(0))\n如上述代码，通过`t := refelct.TypeOf(m)`将Manager的字段类型取出来,在反射中对象字段是通过索引取到的，所以可通过`t.Field(0)`,\n\t\t#reflect.StructField{Name:\"User\", PkgPath:\"\", Type:(*reflect.rtype)(0xedd20), Tag:\"\", Offset:0x0, Index:[]int{0}, Anonymous:true}\n还可以通过`FieldByIndex`和`FieldByName`两种方法取得匿名结构体中的字段属性\n\t1. 给`FieldByIndex()`传入一个int型的slice索引,如`FieldByIndex([]int{0,0})`即取得User结构体中的Id字段。\n\t2. 通过`FieldByName(\"Id\")`也可以取得User结构体中Id字段。\n\n\n## 通过反射修改对象\n上面通过`reflect.TypeOf`和`reflect.ValueOf`已经可以得到接口对象的类型,字段和方法等属性了，怎么通过反射来修改对象的字段值？\n\n\t\tx := 100\n\t\tv := refelct.ValueOf(&x) //传入地址\n\t\tv.Elem().SetInt(200) //成功修改x值为200\n要修改变量x的值，首先就要通过`reflect.ValueOf`来获取x的值类型,`refelct.ValueOf`返回的值类型是变量x一份值拷贝,要修改变量x就要传递x的地址,从而返回x的地址对象,才可以进行对x变量值对修改操作。在得到x变量的地址值类型之后先调用`Elem()`返回地址指针指向的值的Value封装。然后通过`Set`方法进行修改赋值。\n通过反射可以很容易的修改变量的值，怎么来修改结构体中的字段值？\n\n\t\tfunc SetInfo(o interface{}) {\n\t\t\t\tv := reflect.ValueOf(o)\n\t\t\n\t\t\t\tif v.Kind() == reflect.Ptr && !v.Elem().CanSet() { //判断是否为指针类型 元素是否可以修改\n\t\t\t\t\tfmt.Println(\"cannot set\")\n\t\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tv = v.Elem() //实际取得的对象\n\t\t\t\t}\n\t\t\n\t\t\t\t//判断字段是否存在\n\t\t\t\tf := v.FieldByName(\"Name\")\n\t\t\t\tif !f.IsValid() {\n\t\t\t\t\tfmt.Println(\"wuxiao\")\n\t\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\n\t\t\t\t//设置字段\n\t\t\t\tif f := v.FieldByName(\"Name\"); f.Kind() == reflect.String {\n\t\t\t\t\tf.SetString(\"BY\")\n\t\t\t\t}\n\t\t}\n要成功修改结构体中的某个字段,主要进行以下操作：\n1. 首先要反射出这个字段的地址值类型;\n2. 判断反射返回类型是否为`reflect.Ptr`指针类型（通过指针才能操作对象地址中的值)同时还要判断这个元素是否可以修改;\n3. 通过`FieldByName`的返回值判断字段是否存在\n4. 通过`Kind()`和`Set`来修改字段的值\n[示例代码](https://github.com/researchlab/go-learning/blob/master/reflect/02reflect.go)\n\n## 通过反射“动态”调用方法\n现在已经可以通过反射获取并修改接口对象的字段，类型等信息了，那怎么通过反射“动态”调用接口对象等方法？\n先为`User`结构体引入一个`Hello`方法：\n\n\t\tfunc (u User) Hello(m User) (int, string) {\n\t\t\tfmt.Println(\"Hello\", m.Name, \", I'm \", u.Name)\n\t\t\treturn m.Age + u.Age, u.Name\n\t\t}\n\n下面通过反射来调用`Hello`这个方法：\n\n\t\tfunc GetInfo(u interface{}) {\n\t\t\tm := User{2, \"Json\", 12}\n\t\t\n\t\t\tv := reflect.ValueOf(u)\n\t\t\n\t\t\tif v.Kind() != reflect.Struct {\n\t\t\t\tfmt.Println(\"type invalid\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\n\t\t\tmv := v.MethodByName(\"Hello\") //获取对应的方法\n\t\t\tif !mv.IsValid() {            //判断方法是否存在\n\t\t\t\tfmt.Println(\"Func Hello not exist\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\n\t\t\targs := []reflect.Value{reflect.ValueOf(m)} //初始化传入等参数，传入等类型只能是[]reflect.Value类型\n\t\t\tres := mv.Call(args)\n\t\t\tfmt.Println(res[0], res[1])\n\t\t\n\t\t}\n通过`MethodByName`先获取对象的`Hello`方法,然后准备要传入的参数,这里传入的参数必须是`[]refelct.Value`类型,传入的参数值必须强制转换为反射值类型`refelct.Value`。\n最后通过调用`Call`方法就可以实现通过反射\"动态\"调用对象的方法。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/reflect/03reflect.go)\n\n## 小结\n- 通过反射包提供`refelct.TypeOf`和`refelct.ValueOf`方法获得接口对象的类型，值和方法等。\n- 通过反射修改字段值等时候需要传入地址类型，并且需要检查反射返回值类型是否为`refelct.Ptr`，检查字段是否`CanSet`,检查字段是存在,然后通过`Kind()`来帮助赋值相应对类型值。\n- 最后总结了通过`MethodByName`等方法如何“动态”调用对象的方法，示例代码也演示了如何传入和接收多个参数值。\n","source":"_posts/go-reflect-summarize.md","raw":"---\ntitle: golang reflect使用总结\ndate: 2016-02-17 08:57:59\ncategories: golang\ntags: [golang,reflect]\ndescription:\n---\n\n## 前言\n反射是一种检查存储在接口变量中的`<值,类型>`对的机制，借助go反射包提供的`reflect.TypeOf`和`reflect.ValueOf`可以方便的访问到一个接口值的`reflect.Type`和`reflect.Value`部分，从而可进一步得到这个接口的结构类型和对其进行值的修改操作。 \n<!--more-->\n## 反射的使用\n1. **获取接口对象的字段,类型和方法信息**\n先定义个通用的结构体\n\t\ttype User struct{\n\t\t\tId int\n\t\t\tName string\n\t\t\tAge int\n\t\t}\n将接口对象类型信息映射为反射类型信息\n```golang\n\tfunc Info(o interface{}) {\n\t\tt := reflect.TypeOf(o)         //获取接口的类型\n\t\tfmt.Println(\"Type:\", t.Name()) //t.Name() 获取接口的名称\n\t\t\n\t\tif t.Kind() != refelct.Struct { //通过Kind()来判断反射出的类型是否为需要的类型\n\t\t\tfmt.Println(\"err: type invalid!\")\t\t\n\t\t\treturn\n\t\t}\t\t\n\n\t\tv := reflect.ValueOf(o) //获取接口的值类型\n\t\tfmt.Println(\"Fields:\")\n\t\t\t\t\n\t\tfor i := 0; i < t.NumField(); i++ { //NumField取出这个接口所有的字段数量\n\t\tf := t.Field(i)                                   //取得结构体的第i个字段\n\t\tval := v.Field(i).Interface()                     //取得字段的值\n\t\tfmt.Printf(\"%6s: %v = %v\\n\", f.Name, f.Type, val) //第i个字段的名称,类型,值\n\t\t}\n\n\t\tfor i := 0; i < t.NumMethod(); i++{\n\t\t\tm := t.Method(i)\n\t\t\tfmt.Printf(\"%6s: %v\\n\", m.Name,m.Type) //获取方法的名称和类型\t   \n\t\t}\n\t}\t\n``` \n获取接口对象的类型名称，通过`refelct.TypeOf()`获取接口对象的类型,并通过`Name()`方法获取接口的名称。\n获取对象中所有字段的名称,类型和值,通过`reflect.ValueOf()`获取接口对象的值类型取得字段的名称和类型,然后通过`v.Field(i).Interface()`取得第i个字段的值。\n还可以通过`NumMethod()`循环获取接口对象所有方法的名称和类型。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/reflect/01reflect.go)\n\n2. **反射接口对象中的匿名或嵌入字段信息**\n先再添加一个Manager结构,User作为它的匿名字段\n\t\ttype Manager struct{\n\t\t\tUser\n\t\t\ttitle string\n\t\t}\n初始化Manager的两种方法：\n\t\tm0 := Manager{User: User{1,\"Mike\",11},title: \"Man\"}\n\t\tm1 := Manager{User{1,\"Mike\",11},\"Man\"} //这种初始化,赋值顺序必须和结构体中的声明顺序相同! \n现在如何来取出Manager中的匿名字段User？\n\t\tt := refelct.TypeOf(m)\n\t\tfmt.Printf(\"%#v\\n\", t.Field(0))\n如上述代码，通过`t := refelct.TypeOf(m)`将Manager的字段类型取出来,在反射中对象字段是通过索引取到的，所以可通过`t.Field(0)`,\n\t\t#reflect.StructField{Name:\"User\", PkgPath:\"\", Type:(*reflect.rtype)(0xedd20), Tag:\"\", Offset:0x0, Index:[]int{0}, Anonymous:true}\n还可以通过`FieldByIndex`和`FieldByName`两种方法取得匿名结构体中的字段属性\n\t1. 给`FieldByIndex()`传入一个int型的slice索引,如`FieldByIndex([]int{0,0})`即取得User结构体中的Id字段。\n\t2. 通过`FieldByName(\"Id\")`也可以取得User结构体中Id字段。\n\n\n## 通过反射修改对象\n上面通过`reflect.TypeOf`和`reflect.ValueOf`已经可以得到接口对象的类型,字段和方法等属性了，怎么通过反射来修改对象的字段值？\n\n\t\tx := 100\n\t\tv := refelct.ValueOf(&x) //传入地址\n\t\tv.Elem().SetInt(200) //成功修改x值为200\n要修改变量x的值，首先就要通过`reflect.ValueOf`来获取x的值类型,`refelct.ValueOf`返回的值类型是变量x一份值拷贝,要修改变量x就要传递x的地址,从而返回x的地址对象,才可以进行对x变量值对修改操作。在得到x变量的地址值类型之后先调用`Elem()`返回地址指针指向的值的Value封装。然后通过`Set`方法进行修改赋值。\n通过反射可以很容易的修改变量的值，怎么来修改结构体中的字段值？\n\n\t\tfunc SetInfo(o interface{}) {\n\t\t\t\tv := reflect.ValueOf(o)\n\t\t\n\t\t\t\tif v.Kind() == reflect.Ptr && !v.Elem().CanSet() { //判断是否为指针类型 元素是否可以修改\n\t\t\t\t\tfmt.Println(\"cannot set\")\n\t\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tv = v.Elem() //实际取得的对象\n\t\t\t\t}\n\t\t\n\t\t\t\t//判断字段是否存在\n\t\t\t\tf := v.FieldByName(\"Name\")\n\t\t\t\tif !f.IsValid() {\n\t\t\t\t\tfmt.Println(\"wuxiao\")\n\t\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\n\t\t\t\t//设置字段\n\t\t\t\tif f := v.FieldByName(\"Name\"); f.Kind() == reflect.String {\n\t\t\t\t\tf.SetString(\"BY\")\n\t\t\t\t}\n\t\t}\n要成功修改结构体中的某个字段,主要进行以下操作：\n1. 首先要反射出这个字段的地址值类型;\n2. 判断反射返回类型是否为`reflect.Ptr`指针类型（通过指针才能操作对象地址中的值)同时还要判断这个元素是否可以修改;\n3. 通过`FieldByName`的返回值判断字段是否存在\n4. 通过`Kind()`和`Set`来修改字段的值\n[示例代码](https://github.com/researchlab/go-learning/blob/master/reflect/02reflect.go)\n\n## 通过反射“动态”调用方法\n现在已经可以通过反射获取并修改接口对象的字段，类型等信息了，那怎么通过反射“动态”调用接口对象等方法？\n先为`User`结构体引入一个`Hello`方法：\n\n\t\tfunc (u User) Hello(m User) (int, string) {\n\t\t\tfmt.Println(\"Hello\", m.Name, \", I'm \", u.Name)\n\t\t\treturn m.Age + u.Age, u.Name\n\t\t}\n\n下面通过反射来调用`Hello`这个方法：\n\n\t\tfunc GetInfo(u interface{}) {\n\t\t\tm := User{2, \"Json\", 12}\n\t\t\n\t\t\tv := reflect.ValueOf(u)\n\t\t\n\t\t\tif v.Kind() != reflect.Struct {\n\t\t\t\tfmt.Println(\"type invalid\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\n\t\t\tmv := v.MethodByName(\"Hello\") //获取对应的方法\n\t\t\tif !mv.IsValid() {            //判断方法是否存在\n\t\t\t\tfmt.Println(\"Func Hello not exist\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\n\t\t\targs := []reflect.Value{reflect.ValueOf(m)} //初始化传入等参数，传入等类型只能是[]reflect.Value类型\n\t\t\tres := mv.Call(args)\n\t\t\tfmt.Println(res[0], res[1])\n\t\t\n\t\t}\n通过`MethodByName`先获取对象的`Hello`方法,然后准备要传入的参数,这里传入的参数必须是`[]refelct.Value`类型,传入的参数值必须强制转换为反射值类型`refelct.Value`。\n最后通过调用`Call`方法就可以实现通过反射\"动态\"调用对象的方法。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/reflect/03reflect.go)\n\n## 小结\n- 通过反射包提供`refelct.TypeOf`和`refelct.ValueOf`方法获得接口对象的类型，值和方法等。\n- 通过反射修改字段值等时候需要传入地址类型，并且需要检查反射返回值类型是否为`refelct.Ptr`，检查字段是否`CanSet`,检查字段是存在,然后通过`Kind()`来帮助赋值相应对类型值。\n- 最后总结了通过`MethodByName`等方法如何“动态”调用对象的方法，示例代码也演示了如何传入和接收多个参数值。\n","slug":"go-reflect-summarize","published":1,"updated":"2016-03-21T16:45:45.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs0d000xk2pvfifovpll"},{"title":"golang 并发concurrency 使用总结","date":"2016-02-17T18:47:51.000Z","description":null,"_content":"## 前言\ngo能处理高并发的根本原因在于执行go协程只需极少的栈内存(大概4~5KB),并且能根据需要动态增长和缩减占用的资源。\n<!--more-->\n## 高并发的本质goroutine\n简单而言,`goroutine`就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个`goroutine`，但它们并不是被操作系统所调度执行,而是通过系统的线程来多路派遣这些函数的执行，使得每个用go关键字执行的函数可以运行成为一个单位协程。当一个协程阻塞的时候，调度器就会自动把其他协程安排到另外的线程中去执行，从而实现了程序无等待并行化运行。而且调度的开销非常小，一颗CPU调度的规模不下于每秒百万次，这使得在程序中能够创建大量的`goroutine`，实现高并发的同时，依旧能保持高性能。\n`goroutine`是通过通信来共享内存,go中是通过`Channel`来实现通信的，`Channel`本身就像一根管道，go就通过这根管道进行数据的传递,实现消息通信。先来看一个简单的示例：\n```golang\n\tc := make(chan bool)\n\tgo func() {\n\t\tfmt.Println(\"Go concurrency\")\n\t\tc <- true\n\t\tclose(c)\n\t}()\n\n\tfor  v := range c {\n\t\tfmt.Println(v)\n\t}\n```\n- 上面的代码首先创建一个`bool`的`Channel`对象`c`,然后通过`go`关键字执行一个`goroutine`,紧接着执行一个`for`循环;`for`会循环去读取`c`中的值，如果读取到值，则执行`for`循环体（打印v的值），没读取到则`for`被阻塞等待,直到读取到`c`中的值再去执行`for`循环体然后继续循环读取`c`，如果执行了`close(c)`把`Channel`对象`c`关闭了，那`for`循环就退出不执行了。 这就是通过`Channel`通信执行`goroutine`的一个简单示例。\n- 上面通过make这样初始化的`Channel`对象`c`是既可以写又可以被读取的双向通道, 有时候为了避免被误读误写操作，可以初始化一个单向的`Channel`对象。通过设置`Channel`的长度可以分为有缓冲和无缓冲两种`Channel`,无缓冲区的`Channel`,在等待读或等待写的过程中都会引起`同步阻塞`，而有缓冲区的`Channel`,可以看作`异步执行`,也可以认为控制为`同步执行`，只有当缓冲区被占用完了之后才会引起`阻塞`。\n```golang\t\t\n\t\tc := make(chan int, 3)  //初始化缓冲区长度为3的Channel\n\t\tvar send chan<- int = c //只写入的Channel\n\t\tvar recv <-chan int = c //只读取的Channel\n```\n\t** 注意: **  只读或只写的单向`Channel` 都需要借助其它`Channel`才有实际意义，定义一个只写入但是读取不出来的`Channel`没有任何用处。单向`Channel`用作函数形参用于防止参数在函数内部被误读误写是非常有帮助的。\n\n## 开启多核并行并发执行\n默认情况下，go所有的`goroutines`是在一个线程中执行的，而不是同时利用多核进行并行执行，或者通过切换时间片让出CPU进行并发执行。下面看一段示例：\n```golang\nfunc main() {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\twg := sync.WaitGroup{}\n\twg.Add(3)\n\tfor i := 0; i < 3; i++ {\n\t\tgo GoPrint(&wg)\n\t}\n\n\twg.Wait()\n}\n\nfunc GoPrint(wg *sync.WaitGroup) {\n\tfor i := 0; i < 3; i++ {\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"%d \", i)\n\n\t}\n\twg.Done()\n}\n```\n目前只有显示设置了`runtime.GOMAXPROCS`,go才会开启多核并行执行`goroutines`, 如果在`GoPrint`方法中不加入`time.Sleep`，输出的结果将会是`0 1 2 0 1 2 0 1 2`，如果当前`goroutine`不发生阻塞，它是不会让出CPU给其他`goroutine`的, 所以在`GoPrint`中不加`time.Sleep`,输出会是一个一个`goroutine`进行的，而sleep函数则阻塞掉了 当前`goroutine`, 当前`goroutine`主动让其他`goroutine`执行, 所以形成了逻辑上的并行, 也就是并发。\n\n## go并发执行安全问题\ngo并发执行当多个`goroutine`同时访问一个共有的资源时，在不加锁的情况很容易出行数据不同步的问题，看一示例:\n```golang\nfunc sell_tickets(wg *sync.WaitGroup, i int) {\n\n\tfor total_tickets > 0 {\n\n\t\tmutex.Lock()\n\t\t// 如果有票就卖\n\t\tif total_tickets > 0 {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Millisecond)\n\t\t\t// 卖一张票\n\t\t\ttotal_tickets--\n\t\t\tfmt.Println(\"id:\", i, \" ticket:\", total_tickets)\n\t\t}\n\t\tmutex.Unlock()\n\t}\n\twg.Done()\n}\n```\n上面是一个多`goroutine`并发买票的问题，比如当开启5个`goroutine`来卖100张票，如果不加锁，则有可能会出行多出一些不存在的票的问题。所以当并发访问公有资源时要注意加锁保护公有资源属性修改的唯一性和访问时数据同步问题。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/concurrency/concurrency_sync_mutex.go)\n\n## 批量处理多个Channel操作\ngo通过`Select`可以同时处理多个`Channel`,`Select`默认是阻塞的，只有当监听的`Channel`中有发送或接收可以进行时才会运行,当同时有多个可用的`Channel`,`Select`按随机顺序进行处理,`Select`可以方便处理多`Channel`同时响应，在goroutine阻塞的情况也可以方便借助`Select`超时机制来解除阻塞僵局，下面来看一个示例:\n```golang\nfunc getHttpRes(url string) (string, error) {\n\tres := make(chan *http.Response, 1)\n\thttpError := make(chan *error)\n\tgo func() {\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\thttpError <- &err\n\t\t}\n\t\tres <- resp\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase r := <-res:\n\t\t\tresult, err := ioutil.ReadAll(r.Body)\n\t\t\tdefer r.Body.Close()\n\t\t\treturn string(result), err\n\t\tcase err := <-httpError:\n\t\t\treturn \"err\", *err\n\t\tcase <-time.After(2000 * time.Millisecond):\n\t\t\treturn \"Timed out\", errors.New(\"Timed out\")\n\t\t}\n\t}\n\n}\n```\n发起http请求之后通常会有三种状况:1.访问成功，返回内容值;2.访问失败，返回错误信息;3.访问超时，返回超时。上面的代码中利用`Select`很方便的处理了go并发执行中多可用`Channel`的处理问题，通过设置超时，帮助程序跳出超时等待的僵局。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/concurrency/select_timeout.go)\n","source":"_posts/go-concurrency-summarize.md","raw":"---\ntitle: golang 并发concurrency 使用总结\ndate: 2016-02-17 13:47:51\ncategories: golang\ntags: [golang, concurrency]\ndescription:\n---\n## 前言\ngo能处理高并发的根本原因在于执行go协程只需极少的栈内存(大概4~5KB),并且能根据需要动态增长和缩减占用的资源。\n<!--more-->\n## 高并发的本质goroutine\n简单而言,`goroutine`就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个`goroutine`，但它们并不是被操作系统所调度执行,而是通过系统的线程来多路派遣这些函数的执行，使得每个用go关键字执行的函数可以运行成为一个单位协程。当一个协程阻塞的时候，调度器就会自动把其他协程安排到另外的线程中去执行，从而实现了程序无等待并行化运行。而且调度的开销非常小，一颗CPU调度的规模不下于每秒百万次，这使得在程序中能够创建大量的`goroutine`，实现高并发的同时，依旧能保持高性能。\n`goroutine`是通过通信来共享内存,go中是通过`Channel`来实现通信的，`Channel`本身就像一根管道，go就通过这根管道进行数据的传递,实现消息通信。先来看一个简单的示例：\n```golang\n\tc := make(chan bool)\n\tgo func() {\n\t\tfmt.Println(\"Go concurrency\")\n\t\tc <- true\n\t\tclose(c)\n\t}()\n\n\tfor  v := range c {\n\t\tfmt.Println(v)\n\t}\n```\n- 上面的代码首先创建一个`bool`的`Channel`对象`c`,然后通过`go`关键字执行一个`goroutine`,紧接着执行一个`for`循环;`for`会循环去读取`c`中的值，如果读取到值，则执行`for`循环体（打印v的值），没读取到则`for`被阻塞等待,直到读取到`c`中的值再去执行`for`循环体然后继续循环读取`c`，如果执行了`close(c)`把`Channel`对象`c`关闭了，那`for`循环就退出不执行了。 这就是通过`Channel`通信执行`goroutine`的一个简单示例。\n- 上面通过make这样初始化的`Channel`对象`c`是既可以写又可以被读取的双向通道, 有时候为了避免被误读误写操作，可以初始化一个单向的`Channel`对象。通过设置`Channel`的长度可以分为有缓冲和无缓冲两种`Channel`,无缓冲区的`Channel`,在等待读或等待写的过程中都会引起`同步阻塞`，而有缓冲区的`Channel`,可以看作`异步执行`,也可以认为控制为`同步执行`，只有当缓冲区被占用完了之后才会引起`阻塞`。\n```golang\t\t\n\t\tc := make(chan int, 3)  //初始化缓冲区长度为3的Channel\n\t\tvar send chan<- int = c //只写入的Channel\n\t\tvar recv <-chan int = c //只读取的Channel\n```\n\t** 注意: **  只读或只写的单向`Channel` 都需要借助其它`Channel`才有实际意义，定义一个只写入但是读取不出来的`Channel`没有任何用处。单向`Channel`用作函数形参用于防止参数在函数内部被误读误写是非常有帮助的。\n\n## 开启多核并行并发执行\n默认情况下，go所有的`goroutines`是在一个线程中执行的，而不是同时利用多核进行并行执行，或者通过切换时间片让出CPU进行并发执行。下面看一段示例：\n```golang\nfunc main() {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\twg := sync.WaitGroup{}\n\twg.Add(3)\n\tfor i := 0; i < 3; i++ {\n\t\tgo GoPrint(&wg)\n\t}\n\n\twg.Wait()\n}\n\nfunc GoPrint(wg *sync.WaitGroup) {\n\tfor i := 0; i < 3; i++ {\n\t\ttime.Sleep(time.Second)\n\t\tfmt.Printf(\"%d \", i)\n\n\t}\n\twg.Done()\n}\n```\n目前只有显示设置了`runtime.GOMAXPROCS`,go才会开启多核并行执行`goroutines`, 如果在`GoPrint`方法中不加入`time.Sleep`，输出的结果将会是`0 1 2 0 1 2 0 1 2`，如果当前`goroutine`不发生阻塞，它是不会让出CPU给其他`goroutine`的, 所以在`GoPrint`中不加`time.Sleep`,输出会是一个一个`goroutine`进行的，而sleep函数则阻塞掉了 当前`goroutine`, 当前`goroutine`主动让其他`goroutine`执行, 所以形成了逻辑上的并行, 也就是并发。\n\n## go并发执行安全问题\ngo并发执行当多个`goroutine`同时访问一个共有的资源时，在不加锁的情况很容易出行数据不同步的问题，看一示例:\n```golang\nfunc sell_tickets(wg *sync.WaitGroup, i int) {\n\n\tfor total_tickets > 0 {\n\n\t\tmutex.Lock()\n\t\t// 如果有票就卖\n\t\tif total_tickets > 0 {\n\t\t\ttime.Sleep(time.Duration(rand.Intn(5)) * time.Millisecond)\n\t\t\t// 卖一张票\n\t\t\ttotal_tickets--\n\t\t\tfmt.Println(\"id:\", i, \" ticket:\", total_tickets)\n\t\t}\n\t\tmutex.Unlock()\n\t}\n\twg.Done()\n}\n```\n上面是一个多`goroutine`并发买票的问题，比如当开启5个`goroutine`来卖100张票，如果不加锁，则有可能会出行多出一些不存在的票的问题。所以当并发访问公有资源时要注意加锁保护公有资源属性修改的唯一性和访问时数据同步问题。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/concurrency/concurrency_sync_mutex.go)\n\n## 批量处理多个Channel操作\ngo通过`Select`可以同时处理多个`Channel`,`Select`默认是阻塞的，只有当监听的`Channel`中有发送或接收可以进行时才会运行,当同时有多个可用的`Channel`,`Select`按随机顺序进行处理,`Select`可以方便处理多`Channel`同时响应，在goroutine阻塞的情况也可以方便借助`Select`超时机制来解除阻塞僵局，下面来看一个示例:\n```golang\nfunc getHttpRes(url string) (string, error) {\n\tres := make(chan *http.Response, 1)\n\thttpError := make(chan *error)\n\tgo func() {\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\thttpError <- &err\n\t\t}\n\t\tres <- resp\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase r := <-res:\n\t\t\tresult, err := ioutil.ReadAll(r.Body)\n\t\t\tdefer r.Body.Close()\n\t\t\treturn string(result), err\n\t\tcase err := <-httpError:\n\t\t\treturn \"err\", *err\n\t\tcase <-time.After(2000 * time.Millisecond):\n\t\t\treturn \"Timed out\", errors.New(\"Timed out\")\n\t\t}\n\t}\n\n}\n```\n发起http请求之后通常会有三种状况:1.访问成功，返回内容值;2.访问失败，返回错误信息;3.访问超时，返回超时。上面的代码中利用`Select`很方便的处理了go并发执行中多可用`Channel`的处理问题，通过设置超时，帮助程序跳出超时等待的僵局。\n[示例代码](https://github.com/researchlab/go-learning/blob/master/concurrency/select_timeout.go)\n","slug":"go-concurrency-summarize","published":1,"updated":"2016-03-21T16:45:45.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs0g0012k2pv9ka1oaph"},{"title":"golang 并发安全性案例分析","date":"2016-02-25T02:47:55.000Z","description":null,"_content":"\n## 前言\n`golang` 在1.5版本之前默认只使用一个核心来跑所有的`goroutines`,即`GOMAXPROCS`默认设置为1, ,即是串行执行`goroutines`,在1.5版本后，`GOMAXPROCS`默认设置为当前计算机真实的核心线程数，即是在并行执行`goroutines`。\n<!--more-->\n\n## 并行执行安全性案例分析\n利用计算机多核处理的特性，并行执行能成倍的提高程序的性能,但同时也带入了数据安全性问题，下面看一个在线银行转账的案例:\n```golang\ntype User struct {\n\t\tCash int\n}\n\nfunc (u *User) sendCash(to *User, amount int) bool {\n\tif u.Cash < amount {\n\t\treturn false\n\t}\n\t/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */\n\ttime.Sleep(500 * time.Millisecond)\n\tu.Cash = u.Cash - amount\n\tto.Cash = to.Cash + amount\n\treturn true\n}\n\nfunc main() {\n\tme := User{Cash: 500}\n\tyou := User{Cash: 500}\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tme.sendCash(&you, 50) //转账\n\t\tfmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t\tfmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t\tfmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n这是一个通用的Go Web应用，定义User数据结构，sendCash是在两个User之间转账的服务，这里使用的是net/http 包，我们创建了一个简单的Http服务器，然后将请求路由到转账50元的sendCash方法，在正常操作下，代码会如我们预料一样运行，每次转移50美金，一旦一个用户的账户余额达到0美金，就不能再进行转出钞票了，因为没有钱了，但是，如果我们很快地发送很多请求，这个程序会继续转出很多钱，导致账户余额为负数。\n\n这是课本上经常谈到的竞争情况race condition，在这个代码中，账户余额的检查是与从账户中取钱操作分离的，我们假想一下，如果一个请求刚刚完成账户余额检查，但是还没有取钱，也就是没有减少账户余额数值；而另外一个请求线程同时也检查账户余额，发现账户余额还没有剩为零（结果两个请求都一起取钱，导致账户余额为负数），这是典型的”check-then-act”竞争情况。这是很普遍存在的 并发 bug。\n\n## 用锁解决竟态数据安全问题\n\n那么我们如何解决呢？我们肯定不能移除检查操作，而是确保检查和取钱两个动作之间没有任何其他操作发生，其他语言是使用锁，当账户进行更新时，锁住禁止同时有其他线程操作，确保一次只有一个进程操作，也就是排斥锁Mutex。,下面用`golang`自带的`sync`包实现对转账判断及数据操作过程的加锁：\n```golang\ntype User struct {\n\t\tCash int\n}\n\nvar transferLock *sync.Mutex\n\nfunc (u *User) sendCash(to *User, amount int) bool {\n\n\ttransferLock.Lock() //对转账操作进行加锁\n\tdefer transferLock.Unlock() //转账结束后解锁释放资源\n\tif u.Cash < amount {\n\t\treturn false\n\t}\n\t/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */\n\ttime.Sleep(500 * time.Millisecond)\n\tu.Cash = u.Cash - amount\n\tto.Cash = to.Cash + amount\n\treturn true\n}\nfunc main() {\n\tme := User{Cash: 500}\n\tyou := User{Cash: 500}\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tme.sendCash(&you, 50) //转账\n\t\tfmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t\tfmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t\tfmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n## 利用Channel,更好的实现并发\n\n但是锁的问题很显然降低了`程序并发的性能`，锁是并发设计的最大敌人，在Go中推荐使用通道`Channel`，能够使用事件循环event loop机制更灵活地实现并发;通过委托一个后台协程监听通道，当通道中有数据时，立即进行转账操作，因为协程是顺序地读取通道中的数据，也就是巧妙地回避了竞争情况，没有必要使用任何状态变量防止`并发`竞争了。 具体示例:\n```golang\ntype User struct {\n\tCash int\n}\ntype Transfer struct {\n\tSender    *User\n\tRecipient *User\n\tAmount    int\n}\n\nfunc sendCashHandler(transferchan chan Transfer) {\n\tvar val Transfer\n\tfor {\n\t\tval = <-transferchan\n\t\tval.Sender.sendCash(val.Recipient, val.Amount)\n\t}\n}\n\nfunc (u *User) sendCash(to *User, amount int) bool {\n\tif u.Cash < amount {\n\t\treturn false\n\t}\n\t/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */\n\ttime.Sleep(500 * time.Millisecond)\n\tu.Cash = u.Cash - amount\n\tto.Cash = to.Cash + amount\n\treturn true\n}\n\nfunc main() {\n\tme := User{Cash: 500}\n\tyou := User{Cash: 500}\n\ttransferchan := make(chan Transfer)\n\tgo sendCashHandler(transferchan)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttransfer := Transfer{Sender: &me, Recipient: &you, Amount: 50}\n\t\ttransferchan <- transfer\n\t\tfmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t\tfmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t\tfmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n上面这段代码创建了比较可靠的系统从而避免了`并发`竞争，但是我们会带来另外一个安全问题：`DoS(Denial of Service服务拒绝)`，如果我们的转账操作慢下来，那么不断进来的请求需要等待进行转账操作的那个协程从通道中读取新数据，但是这个线程忙于照顾转账操作，没有闲功夫读取通道中新数据，这个情况会导致系统容易遭受`DoS攻击`，外界只要发送大量请求就能让系统停止响应。\n\n## 祭出select 进一步提升性能\n一些基础机制比如buffered channel可以处理这种情况，但是buffered channel是有内存上限的，不足够保存所有请求数据，优化解决方案是使用Go杰出的`select`语句：\n```golang\nhttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t transfer := Transfer{Sender: &me, Recipient: &you, Amount: 50}\n\t /*转账*/\n\t result := make(chan int)\n\t go func(transferchan chan<- Transfer, transfer Transfer, result chan<- int) {\n\t      transferchan <- transfer\n\t      result <- 1\n\t }(transferchan, transfer, result)\n\n\t/*用select来处理超时机制*/\t \n\t select {\n\t   case <-result:\n\t    fmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t    fmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t    fmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t  case <-time.After(time.Second * 10): //超时处理\n\t    fmt.Fprintf(w, \"Your request has been received, but is processing slowly\")\n\t }\n})\n```\n这里提升了事件循环，等待不能超过10秒，等待超过timeout时间，会返回一个消息给User告诉它们请求已经接受，可能会花点时间处理，请耐心等候即可，使用这种方法我们降低了`DoS攻击`可能，一个真正健壮的能够`并发`处理转账且没有使用任何锁的系统诞生了。\n","source":"_posts/go-concurrency-security.md","raw":"---\ntitle: \"golang 并发安全性案例分析\"\ndate: 2016-02-24 21:47:55\ncategories: [golang]\ntags: [golang,concurrency]\ndescription:\n---\n\n## 前言\n`golang` 在1.5版本之前默认只使用一个核心来跑所有的`goroutines`,即`GOMAXPROCS`默认设置为1, ,即是串行执行`goroutines`,在1.5版本后，`GOMAXPROCS`默认设置为当前计算机真实的核心线程数，即是在并行执行`goroutines`。\n<!--more-->\n\n## 并行执行安全性案例分析\n利用计算机多核处理的特性，并行执行能成倍的提高程序的性能,但同时也带入了数据安全性问题，下面看一个在线银行转账的案例:\n```golang\ntype User struct {\n\t\tCash int\n}\n\nfunc (u *User) sendCash(to *User, amount int) bool {\n\tif u.Cash < amount {\n\t\treturn false\n\t}\n\t/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */\n\ttime.Sleep(500 * time.Millisecond)\n\tu.Cash = u.Cash - amount\n\tto.Cash = to.Cash + amount\n\treturn true\n}\n\nfunc main() {\n\tme := User{Cash: 500}\n\tyou := User{Cash: 500}\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tme.sendCash(&you, 50) //转账\n\t\tfmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t\tfmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t\tfmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n这是一个通用的Go Web应用，定义User数据结构，sendCash是在两个User之间转账的服务，这里使用的是net/http 包，我们创建了一个简单的Http服务器，然后将请求路由到转账50元的sendCash方法，在正常操作下，代码会如我们预料一样运行，每次转移50美金，一旦一个用户的账户余额达到0美金，就不能再进行转出钞票了，因为没有钱了，但是，如果我们很快地发送很多请求，这个程序会继续转出很多钱，导致账户余额为负数。\n\n这是课本上经常谈到的竞争情况race condition，在这个代码中，账户余额的检查是与从账户中取钱操作分离的，我们假想一下，如果一个请求刚刚完成账户余额检查，但是还没有取钱，也就是没有减少账户余额数值；而另外一个请求线程同时也检查账户余额，发现账户余额还没有剩为零（结果两个请求都一起取钱，导致账户余额为负数），这是典型的”check-then-act”竞争情况。这是很普遍存在的 并发 bug。\n\n## 用锁解决竟态数据安全问题\n\n那么我们如何解决呢？我们肯定不能移除检查操作，而是确保检查和取钱两个动作之间没有任何其他操作发生，其他语言是使用锁，当账户进行更新时，锁住禁止同时有其他线程操作，确保一次只有一个进程操作，也就是排斥锁Mutex。,下面用`golang`自带的`sync`包实现对转账判断及数据操作过程的加锁：\n```golang\ntype User struct {\n\t\tCash int\n}\n\nvar transferLock *sync.Mutex\n\nfunc (u *User) sendCash(to *User, amount int) bool {\n\n\ttransferLock.Lock() //对转账操作进行加锁\n\tdefer transferLock.Unlock() //转账结束后解锁释放资源\n\tif u.Cash < amount {\n\t\treturn false\n\t}\n\t/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */\n\ttime.Sleep(500 * time.Millisecond)\n\tu.Cash = u.Cash - amount\n\tto.Cash = to.Cash + amount\n\treturn true\n}\nfunc main() {\n\tme := User{Cash: 500}\n\tyou := User{Cash: 500}\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tme.sendCash(&you, 50) //转账\n\t\tfmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t\tfmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t\tfmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n## 利用Channel,更好的实现并发\n\n但是锁的问题很显然降低了`程序并发的性能`，锁是并发设计的最大敌人，在Go中推荐使用通道`Channel`，能够使用事件循环event loop机制更灵活地实现并发;通过委托一个后台协程监听通道，当通道中有数据时，立即进行转账操作，因为协程是顺序地读取通道中的数据，也就是巧妙地回避了竞争情况，没有必要使用任何状态变量防止`并发`竞争了。 具体示例:\n```golang\ntype User struct {\n\tCash int\n}\ntype Transfer struct {\n\tSender    *User\n\tRecipient *User\n\tAmount    int\n}\n\nfunc sendCashHandler(transferchan chan Transfer) {\n\tvar val Transfer\n\tfor {\n\t\tval = <-transferchan\n\t\tval.Sender.sendCash(val.Recipient, val.Amount)\n\t}\n}\n\nfunc (u *User) sendCash(to *User, amount int) bool {\n\tif u.Cash < amount {\n\t\treturn false\n\t}\n\t/* 设置延迟Sleep，当多个goroutines并行执行时,便于进行数据安全分析 */\n\ttime.Sleep(500 * time.Millisecond)\n\tu.Cash = u.Cash - amount\n\tto.Cash = to.Cash + amount\n\treturn true\n}\n\nfunc main() {\n\tme := User{Cash: 500}\n\tyou := User{Cash: 500}\n\ttransferchan := make(chan Transfer)\n\tgo sendCashHandler(transferchan)\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttransfer := Transfer{Sender: &me, Recipient: &you, Amount: 50}\n\t\ttransferchan <- transfer\n\t\tfmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t\tfmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t\tfmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n上面这段代码创建了比较可靠的系统从而避免了`并发`竞争，但是我们会带来另外一个安全问题：`DoS(Denial of Service服务拒绝)`，如果我们的转账操作慢下来，那么不断进来的请求需要等待进行转账操作的那个协程从通道中读取新数据，但是这个线程忙于照顾转账操作，没有闲功夫读取通道中新数据，这个情况会导致系统容易遭受`DoS攻击`，外界只要发送大量请求就能让系统停止响应。\n\n## 祭出select 进一步提升性能\n一些基础机制比如buffered channel可以处理这种情况，但是buffered channel是有内存上限的，不足够保存所有请求数据，优化解决方案是使用Go杰出的`select`语句：\n```golang\nhttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t transfer := Transfer{Sender: &me, Recipient: &you, Amount: 50}\n\t /*转账*/\n\t result := make(chan int)\n\t go func(transferchan chan<- Transfer, transfer Transfer, result chan<- int) {\n\t      transferchan <- transfer\n\t      result <- 1\n\t }(transferchan, transfer, result)\n\n\t/*用select来处理超时机制*/\t \n\t select {\n\t   case <-result:\n\t    fmt.Fprintf(w, \"I have $%d\\n\", me.Cash)\n\t    fmt.Fprintf(w, \"You have $%d\\n\", you.Cash)\n\t    fmt.Fprintf(w, \"Total transferred: $%d\\n\", (you.Cash - 500))\n\t  case <-time.After(time.Second * 10): //超时处理\n\t    fmt.Fprintf(w, \"Your request has been received, but is processing slowly\")\n\t }\n})\n```\n这里提升了事件循环，等待不能超过10秒，等待超过timeout时间，会返回一个消息给User告诉它们请求已经接受，可能会花点时间处理，请耐心等候即可，使用这种方法我们降低了`DoS攻击`可能，一个真正健壮的能够`并发`处理转账且没有使用任何锁的系统诞生了。\n","slug":"go-concurrency-security","published":1,"updated":"2016-03-21T16:45:45.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs0l0017k2pvutynsmxd"},{"title":"[译]GO BOOTCAMP 第四章：集合类型","date":"2016-01-19T14:24:38.000Z","description":null,"_content":"\n## 前言\n`Go`集合类型包含`Array`,`Slice`,`Range`,`Map`等议题的分析和讨论。\n<!--more-->\n## Array-数组\n未完待续...\n","source":"_posts/go-collection-types.md","raw":"---\ntitle: \"[译]GO BOOTCAMP 第四章：集合类型\"\ndate: 2016-01-19 09:24:38\ncategories: go-bootcamp\ntags: [golang]\ndescription:\n---\n\n## 前言\n`Go`集合类型包含`Array`,`Slice`,`Range`,`Map`等议题的分析和讨论。\n<!--more-->\n## Array-数组\n未完待续...\n","slug":"go-collection-types","published":1,"updated":"2016-03-21T16:45:45.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs0n001bk2pvo3g9yt5b"},{"title":"[译]GO BOOTCAMP 第二章：基本概念实战","date":"2016-01-16T21:54:06.000Z","description":null,"_content":"\n## 前言\n如果已经有一定的编程基础，那你只需花几个小时就能学会`Go`编程，因此`Go`也常被认为是一门“简单易用”的编程语言。Go语言被设计得尽量简洁，它的整个语言规范也一样。在写第一个`Go`应用之前，我们先来学习`Go`的一些基础概念。\n<!--more-->\n\n## 变量及类型推断\n用`var`关键字声明一个变量列表，其中变量的数据类型Type放在变量名的后面，如:\n```golang\nvar(\n\tname string\n\tage int\n\tlocation string\t\n)\n```\n或着将相同类型的变量写在一行并用逗号隔开,\n```golang\nvar(\n\tname, location string\n\tage int\t\n)\n```\n也可以一个一个的声明变量, \n```golang\nvar name string\nvar age int \nvar location string\n```\n也可在`var`关键字声明的变量列表中初始化变量，\n```golang\nvar(\n\tname string = \"Prince Oberyn\"\n\tage int = 32\n\tlocation string = \"Dorne\"\t\n)\n```\n也可以向下面这样声明初始化变量,\n```golang\nvar (\n\tname, location, age = \"Prince Oberyn\", \"Dorne\", 32\n)\n```\n在函数内部可以直接用短赋值符号`:=`来隐式的声明初始化变量，但是这种短赋值符号只能用于声明局部变量，即只能在函数体内使用,如:\n```golang\nfunc main() {\n\tname, location := \"Prince Oberyn\", \"Dorne\"\n\tage := 32\n\tfmt.Printf(\"%s (%d) of %s\", name, age, location)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch02/short_assign_case.go)\n在`Go`语言中，一个变量可以是任意类型，甚至可以将一个函数赋值给一个变量,如:\n```golang\nfunc main() {\n\taction := func() {\n\t\t//doing something\n\t}\n\taction()\n}\n```\n**注意:** 短赋值符号`:=`只能用来隐式初始化局部变量，不能在函数体外部使用。\n\n## 常量\n在`Go`语言中，用`const`关键字声明常量。常量只能是字符，字符串，布尔值或数值。常量初始化可以通过上下文推断它的类型，但是不能使用短赋值符号`:=`对常量进行声明初始化操作，如:\n```golang\nconst Pi = 3.14\nconst (\n\t\tStatusOK                   = 200\n\t\tStatusCreated              = 201\n\t\tStatusAccepted             = 202\n\t\tStatusNonAuthoritativeInfo = 203\n\t\tStatusNoContent            = 204\n\t\tStatusResetContent         = 205\n\t\tStatusPartialContent       = 206\n)\n```\n```golang\npackage main\n\nimport \"fmt\"\n\nconst (\n\tPi    = 3.14\n\tTruth = false\n\tBig   = 1 << 100\n\tSmall = Big >> 99\n)\n\nfunc main() {\n\tconst Greeting = \"ハローワールド\"\n\tfmt.Println(Greeting)\n\tfmt.Println(Pi)\n\tfmt.Println(Truth)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch02/constant_declared.go)\n\n## 打印常量和变量\n你可以灵活的使用`fmt`包提供的`print`和`println`函数打印一个常量或变量的值,如:\n```golang\nfunc main() {\n\tcylonModel := 6\n\tfmt.Println(cylonModel)\n}\n```\n可用`fmt.Println`换行打印变量，如果要按指定的输出格式打印一个或多个值变量时可以用`fmt.Printf`函数,如:\n```golang\nfunc main() {\n\tname := \"Caprica-Six\"\n\taka := fmt.Sprintf(\"Number %d\", 6)\n\tfmt.Printf(\"%s is also known as %s\",name, aka)\n}\n```\n## 包和引入\n每个`Go`程序都是由`packages`组成的，并且以`main`包为程序的运行入口，如:\n```golang\npackage main\nfunc main() {\n\tprint(\"Hello,World!\\n\")\n}\n```\n如果写一个可执行程序（相对于库）,那需要定义一个`main` 包的`go`文件，`main`包中的`main`函数就是执行程序的入口。按惯例，包名是相同的导入路径的最后一个元素。例如，引入路径`math/rand`，是指引入`math/`路径下的`rand`包。\n引入包示例:\n```golang\nimport \"fmt\"\nimport \"math/rand\"\n```\n或着引入一个包组:\n```golang\nimport(\n\t\"fmt\"\n\t\"math/rand\"\t\n)\n```\n通常，非标准库包使用一个`web url`作为命名空间，如我将`Rails 4`中使用的一些用于加密的代码和逻辑移植到`Go`中，然后将代码包托管到`github`的`repository`上，如:[http://github.com/mattetti/goRailsYourself]()\n 那现在可以通过下面的方式来引入提交的这个加密包`crypto package`:\n ```golang\nimport \"github.com/mattetti/goRailsYourself/crypto\"\n```\n\n## 代码位置\n上面的代码片段只是简单的告诉编译器可以在**github.com/mattetti/goRailsYourself/crypto**路径下获得`crypto`这个包，但并不意味着编译器会自动去`github`仓库中把这个代码拉下来，那到哪里去找到这个`crypto`代码包呢？\n你需要自己去把代码拉下来，最简单的方法是使用`Go`提供的`go get`命令,\n```bash\n$ go get github.com/mattetti/goRailsYourself/crypto\n```\n当安装`Go`时，我们需要设置`GOPATH`环境变量, 这个是用来指明二进制执行程序，库文件和你自己代码的存放位置的。执行`go get`命令，它会把相应的包文件下载到`GOPATH`指定到路径下。\n```bash\n$ ls $GOPATH\nbin\tpkg\tsrc\n```\n`bin`文件夹中包括`Go`编译生成到二进制执行文件，你需要将`bin`文件夹路径添加到你的系统路径中。\n`pkg`文件夹存放编译生成的对应编译版本的所有库文件使得编译器在不需要重新编译的情况下可以重新链接它们。\n最后，`src`文件夹中按引入路径存放着所有`Go`源码,如：\n```bash\n$ ls $GOPATH/src\nbitbucket.org\tcode.google.com\tgithub.com\tlaunchpad.net\n```\n```bash\n$ ls $GOPATH/src/github.com/mattetti\ngoblin\t\t\tgoRailsYourself\t\tjet\n```\n当新建一个项目时，在`src`文件夹中推荐按照包引入路径来放置源码文件(如: **github.com/<your username>/<project name>**)\n\n## 导入名字\n导入一个包后，就可以通过名字来引用导入包中的内容（即在包外可以访问到它到变量，方法及函数等）,在`Go`中，如果名字首字母大写则这个名字，则这个名字可导入的，可以被导入到其它包中使用，即公有的。如`Foo`和`FOO`都是可导入的,而`foo`则不是可导入的，来看两者的不同:\n```golang\nfunc main() {\n    fmt.Println(math.pi)\n}\n```\n和\n```golang\nfunc main() {\n\tfmt.Println(math.Pi)\n}\n```\n`Pi`是可以导入的，可以在包外被调用，是公有的，而`pi`则不可以，编译报错提示：\n```bash\ncannot refer to unexported name math.pi\n```\n\n## 函数形参名,返回值，被命名的返回值\n一个函数可以有零个或多个形参，也可以有多个返回值。在形参列表中类型放在形参变量的后面，如:\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n\t    return x + y\n}\n\nfunc main() {\n\t    fmt.Println(add(42, 13))\n}\n```\n在下面的示例中，可以将多个类型相同的形参一起声明，如`x int, y int`可以写成`x, y int`，\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc add(x, y int) int {\n\t    return x + y\n}\n\nfunc main() {\n\t    fmt.Println(add(42, 13))\n}\n```\n下面示例中，`location`函数返回两个`string`类型值。\n```golang\nfunc location(city string) (string, string) {\n\t\tvar region string\n\t\tvar continent string\n\n\t\tswitch city {\n\t\tcase \"Los Angeles\", \"LA\", \"Santa Monica\":\n\t\t\tregion, continent = \"California\", \"North America\"\n\t\tcase \"New York\", \"NYC\":\n\t\t\tregion, continent = \"New York\", \"North America\"\n\t\tdefault:\n\t\t\tregion, continent = \"Unknown\", \"Unknown\"\n\t\t}\n\t\t\treturn region, continent\n}\n\nfunc main() {\n\t\tregion, continent := location(\"Santa Monica\")\n\t\tfmt.Printf(\"Matt lives in %s, %s\", region, continent)\n}\n```\n在`Go`语言中，函数可以返回多个值，如果返回参数被命名了，则返回语句可以不需要显示返回相应的返回参数，如：\n```golang\nfunc location(name, city string) (name, continent string) {\n\tswitch city {\n\t\tcase \"New York\", \"LA\", \"Chicago\":\n\t\t\tcontinent = \"North America\"\n\t\tdefault:\n\t\t\tcontinent = \"Unknown\"\n\t\t}\n\t\treturn\n}\n\nfunc main() {\n\t\tname, continent := location(\"Matt\", \"LA\")\n\t\tfmt.Printf(\"%s lives in %s\", name, continent)\n}\n```\n但是个人推荐，无论返回参数是否被命名了，在返回语句中都显示加上被返回的参数名称\n\n## 指针\n在`Go`语言中有指针，但是没有指针运算。结构字段都可以通过一个结构指针进行访问。`Go`中指针就像透明的一样，可以用指针直接调用字段和方法。不过`Go`默认是按值传递参数（值拷贝），如果想通过引用传递参数，则需要传递指针（或使用`slice`和`map`等引用结构类型。可以在变量前面加`&`符号取得这个变量的地址,在变量前面加`*`符号则可以取得这个变量的值。在`Go`中方法默认被定义为指针类型而不是值类型（不过方法也可以定义为值类型），通常可以将一个指针赋值给一个变量，如：\n```golang\nclient := &http.Client{}\nresp, err := client.Get(\"http://gobootcamp.com\")\n```\n## 可变性\n在`Go`中，只有常量在初始化之后是不可改变的。但注意在`Go`函数中参数默认按值传递，在函数体内修改传入的参数值，并不会改变函数外这个参数的值，如：\n```golang\npackage main\nimport \"fmt\"\n\ntype Artist struct {\n\t\tName, Genre string\n\t\tSongs       int\n}\n\nfunc newRelease(a Artist) int {\n\t\ta.Songs++\n\t\treturn a.Songs\n}\n\nfunc main() {\n\t\tme := Artist{Name: \"Matt\", Genre: \"Electro\", Songs: 42}\n\t\tfmt.Printf(\"%s released their %dth song\\n\", me.Name, newRelease(me))\n\t\tfmt.Printf(\"%s has a total of %d songs\", me.Name, me.Songs)\n}\n```\nresults:\n```bash\nMatt released their 43th song\nMatt has a total of 42 songs\n```\n上面的结果并没有真正修改`me`变量中的值，是因为上述形参是通过值传递，如果要达到成功修改，则需要借助指针对`me`变量进行引用传递，如：\n```golang\npackage main\n\nimport \"fmt\"\n\ntype Artist struct {\n\t\tName, Genre string\n\t\tSongs       int\n}\n\nfunc newRelease(a *Artist) int {\n\t\ta.Songs++\n\t\treturn a.Songs\n}\n\nfunc main() {\n\t\tme := &Artist{Name: \"Matt\", Genre: \"Electro\", Songs: 42}\n\t\tfmt.Printf(\"%s released their %dth song\\n\", me.Name, newRelease(me))\n\t\tfmt.Printf(\"%s has a total of %d songs\", me.Name, me.Songs)\n}\n```\n上面两个版本中唯一对不同是第一个版本是值传递，只修改了拷贝不影响变量原值，而第二个版本是引用传递，修改的是同一地址上的内容，所以修改成功。\n\n** 《GO BOOTCAMP》第二章翻译完成，原著第二章出处：[Chapter 2 The Basics](http://www.golangbootcamp.com/book/basics) **\n","source":"_posts/go-basics.md","raw":"---\ntitle: \"[译]GO BOOTCAMP 第二章：基本概念实战\"\ndate: 2016-01-16 16:54:06\ncategories: go-bootcamp\ntags: [golang]\ndescription:\n---\n\n## 前言\n如果已经有一定的编程基础，那你只需花几个小时就能学会`Go`编程，因此`Go`也常被认为是一门“简单易用”的编程语言。Go语言被设计得尽量简洁，它的整个语言规范也一样。在写第一个`Go`应用之前，我们先来学习`Go`的一些基础概念。\n<!--more-->\n\n## 变量及类型推断\n用`var`关键字声明一个变量列表，其中变量的数据类型Type放在变量名的后面，如:\n```golang\nvar(\n\tname string\n\tage int\n\tlocation string\t\n)\n```\n或着将相同类型的变量写在一行并用逗号隔开,\n```golang\nvar(\n\tname, location string\n\tage int\t\n)\n```\n也可以一个一个的声明变量, \n```golang\nvar name string\nvar age int \nvar location string\n```\n也可在`var`关键字声明的变量列表中初始化变量，\n```golang\nvar(\n\tname string = \"Prince Oberyn\"\n\tage int = 32\n\tlocation string = \"Dorne\"\t\n)\n```\n也可以向下面这样声明初始化变量,\n```golang\nvar (\n\tname, location, age = \"Prince Oberyn\", \"Dorne\", 32\n)\n```\n在函数内部可以直接用短赋值符号`:=`来隐式的声明初始化变量，但是这种短赋值符号只能用于声明局部变量，即只能在函数体内使用,如:\n```golang\nfunc main() {\n\tname, location := \"Prince Oberyn\", \"Dorne\"\n\tage := 32\n\tfmt.Printf(\"%s (%d) of %s\", name, age, location)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch02/short_assign_case.go)\n在`Go`语言中，一个变量可以是任意类型，甚至可以将一个函数赋值给一个变量,如:\n```golang\nfunc main() {\n\taction := func() {\n\t\t//doing something\n\t}\n\taction()\n}\n```\n**注意:** 短赋值符号`:=`只能用来隐式初始化局部变量，不能在函数体外部使用。\n\n## 常量\n在`Go`语言中，用`const`关键字声明常量。常量只能是字符，字符串，布尔值或数值。常量初始化可以通过上下文推断它的类型，但是不能使用短赋值符号`:=`对常量进行声明初始化操作，如:\n```golang\nconst Pi = 3.14\nconst (\n\t\tStatusOK                   = 200\n\t\tStatusCreated              = 201\n\t\tStatusAccepted             = 202\n\t\tStatusNonAuthoritativeInfo = 203\n\t\tStatusNoContent            = 204\n\t\tStatusResetContent         = 205\n\t\tStatusPartialContent       = 206\n)\n```\n```golang\npackage main\n\nimport \"fmt\"\n\nconst (\n\tPi    = 3.14\n\tTruth = false\n\tBig   = 1 << 100\n\tSmall = Big >> 99\n)\n\nfunc main() {\n\tconst Greeting = \"ハローワールド\"\n\tfmt.Println(Greeting)\n\tfmt.Println(Pi)\n\tfmt.Println(Truth)\n}\n```\n[示例代码](https://github.com/researchlab/go-bootcamp/blob/master/ch02/constant_declared.go)\n\n## 打印常量和变量\n你可以灵活的使用`fmt`包提供的`print`和`println`函数打印一个常量或变量的值,如:\n```golang\nfunc main() {\n\tcylonModel := 6\n\tfmt.Println(cylonModel)\n}\n```\n可用`fmt.Println`换行打印变量，如果要按指定的输出格式打印一个或多个值变量时可以用`fmt.Printf`函数,如:\n```golang\nfunc main() {\n\tname := \"Caprica-Six\"\n\taka := fmt.Sprintf(\"Number %d\", 6)\n\tfmt.Printf(\"%s is also known as %s\",name, aka)\n}\n```\n## 包和引入\n每个`Go`程序都是由`packages`组成的，并且以`main`包为程序的运行入口，如:\n```golang\npackage main\nfunc main() {\n\tprint(\"Hello,World!\\n\")\n}\n```\n如果写一个可执行程序（相对于库）,那需要定义一个`main` 包的`go`文件，`main`包中的`main`函数就是执行程序的入口。按惯例，包名是相同的导入路径的最后一个元素。例如，引入路径`math/rand`，是指引入`math/`路径下的`rand`包。\n引入包示例:\n```golang\nimport \"fmt\"\nimport \"math/rand\"\n```\n或着引入一个包组:\n```golang\nimport(\n\t\"fmt\"\n\t\"math/rand\"\t\n)\n```\n通常，非标准库包使用一个`web url`作为命名空间，如我将`Rails 4`中使用的一些用于加密的代码和逻辑移植到`Go`中，然后将代码包托管到`github`的`repository`上，如:[http://github.com/mattetti/goRailsYourself]()\n 那现在可以通过下面的方式来引入提交的这个加密包`crypto package`:\n ```golang\nimport \"github.com/mattetti/goRailsYourself/crypto\"\n```\n\n## 代码位置\n上面的代码片段只是简单的告诉编译器可以在**github.com/mattetti/goRailsYourself/crypto**路径下获得`crypto`这个包，但并不意味着编译器会自动去`github`仓库中把这个代码拉下来，那到哪里去找到这个`crypto`代码包呢？\n你需要自己去把代码拉下来，最简单的方法是使用`Go`提供的`go get`命令,\n```bash\n$ go get github.com/mattetti/goRailsYourself/crypto\n```\n当安装`Go`时，我们需要设置`GOPATH`环境变量, 这个是用来指明二进制执行程序，库文件和你自己代码的存放位置的。执行`go get`命令，它会把相应的包文件下载到`GOPATH`指定到路径下。\n```bash\n$ ls $GOPATH\nbin\tpkg\tsrc\n```\n`bin`文件夹中包括`Go`编译生成到二进制执行文件，你需要将`bin`文件夹路径添加到你的系统路径中。\n`pkg`文件夹存放编译生成的对应编译版本的所有库文件使得编译器在不需要重新编译的情况下可以重新链接它们。\n最后，`src`文件夹中按引入路径存放着所有`Go`源码,如：\n```bash\n$ ls $GOPATH/src\nbitbucket.org\tcode.google.com\tgithub.com\tlaunchpad.net\n```\n```bash\n$ ls $GOPATH/src/github.com/mattetti\ngoblin\t\t\tgoRailsYourself\t\tjet\n```\n当新建一个项目时，在`src`文件夹中推荐按照包引入路径来放置源码文件(如: **github.com/<your username>/<project name>**)\n\n## 导入名字\n导入一个包后，就可以通过名字来引用导入包中的内容（即在包外可以访问到它到变量，方法及函数等）,在`Go`中，如果名字首字母大写则这个名字，则这个名字可导入的，可以被导入到其它包中使用，即公有的。如`Foo`和`FOO`都是可导入的,而`foo`则不是可导入的，来看两者的不同:\n```golang\nfunc main() {\n    fmt.Println(math.pi)\n}\n```\n和\n```golang\nfunc main() {\n\tfmt.Println(math.Pi)\n}\n```\n`Pi`是可以导入的，可以在包外被调用，是公有的，而`pi`则不可以，编译报错提示：\n```bash\ncannot refer to unexported name math.pi\n```\n\n## 函数形参名,返回值，被命名的返回值\n一个函数可以有零个或多个形参，也可以有多个返回值。在形参列表中类型放在形参变量的后面，如:\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n\t    return x + y\n}\n\nfunc main() {\n\t    fmt.Println(add(42, 13))\n}\n```\n在下面的示例中，可以将多个类型相同的形参一起声明，如`x int, y int`可以写成`x, y int`，\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc add(x, y int) int {\n\t    return x + y\n}\n\nfunc main() {\n\t    fmt.Println(add(42, 13))\n}\n```\n下面示例中，`location`函数返回两个`string`类型值。\n```golang\nfunc location(city string) (string, string) {\n\t\tvar region string\n\t\tvar continent string\n\n\t\tswitch city {\n\t\tcase \"Los Angeles\", \"LA\", \"Santa Monica\":\n\t\t\tregion, continent = \"California\", \"North America\"\n\t\tcase \"New York\", \"NYC\":\n\t\t\tregion, continent = \"New York\", \"North America\"\n\t\tdefault:\n\t\t\tregion, continent = \"Unknown\", \"Unknown\"\n\t\t}\n\t\t\treturn region, continent\n}\n\nfunc main() {\n\t\tregion, continent := location(\"Santa Monica\")\n\t\tfmt.Printf(\"Matt lives in %s, %s\", region, continent)\n}\n```\n在`Go`语言中，函数可以返回多个值，如果返回参数被命名了，则返回语句可以不需要显示返回相应的返回参数，如：\n```golang\nfunc location(name, city string) (name, continent string) {\n\tswitch city {\n\t\tcase \"New York\", \"LA\", \"Chicago\":\n\t\t\tcontinent = \"North America\"\n\t\tdefault:\n\t\t\tcontinent = \"Unknown\"\n\t\t}\n\t\treturn\n}\n\nfunc main() {\n\t\tname, continent := location(\"Matt\", \"LA\")\n\t\tfmt.Printf(\"%s lives in %s\", name, continent)\n}\n```\n但是个人推荐，无论返回参数是否被命名了，在返回语句中都显示加上被返回的参数名称\n\n## 指针\n在`Go`语言中有指针，但是没有指针运算。结构字段都可以通过一个结构指针进行访问。`Go`中指针就像透明的一样，可以用指针直接调用字段和方法。不过`Go`默认是按值传递参数（值拷贝），如果想通过引用传递参数，则需要传递指针（或使用`slice`和`map`等引用结构类型。可以在变量前面加`&`符号取得这个变量的地址,在变量前面加`*`符号则可以取得这个变量的值。在`Go`中方法默认被定义为指针类型而不是值类型（不过方法也可以定义为值类型），通常可以将一个指针赋值给一个变量，如：\n```golang\nclient := &http.Client{}\nresp, err := client.Get(\"http://gobootcamp.com\")\n```\n## 可变性\n在`Go`中，只有常量在初始化之后是不可改变的。但注意在`Go`函数中参数默认按值传递，在函数体内修改传入的参数值，并不会改变函数外这个参数的值，如：\n```golang\npackage main\nimport \"fmt\"\n\ntype Artist struct {\n\t\tName, Genre string\n\t\tSongs       int\n}\n\nfunc newRelease(a Artist) int {\n\t\ta.Songs++\n\t\treturn a.Songs\n}\n\nfunc main() {\n\t\tme := Artist{Name: \"Matt\", Genre: \"Electro\", Songs: 42}\n\t\tfmt.Printf(\"%s released their %dth song\\n\", me.Name, newRelease(me))\n\t\tfmt.Printf(\"%s has a total of %d songs\", me.Name, me.Songs)\n}\n```\nresults:\n```bash\nMatt released their 43th song\nMatt has a total of 42 songs\n```\n上面的结果并没有真正修改`me`变量中的值，是因为上述形参是通过值传递，如果要达到成功修改，则需要借助指针对`me`变量进行引用传递，如：\n```golang\npackage main\n\nimport \"fmt\"\n\ntype Artist struct {\n\t\tName, Genre string\n\t\tSongs       int\n}\n\nfunc newRelease(a *Artist) int {\n\t\ta.Songs++\n\t\treturn a.Songs\n}\n\nfunc main() {\n\t\tme := &Artist{Name: \"Matt\", Genre: \"Electro\", Songs: 42}\n\t\tfmt.Printf(\"%s released their %dth song\\n\", me.Name, newRelease(me))\n\t\tfmt.Printf(\"%s has a total of %d songs\", me.Name, me.Songs)\n}\n```\n上面两个版本中唯一对不同是第一个版本是值传递，只修改了拷贝不影响变量原值，而第二个版本是引用传递，修改的是同一地址上的内容，所以修改成功。\n\n** 《GO BOOTCAMP》第二章翻译完成，原著第二章出处：[Chapter 2 The Basics](http://www.golangbootcamp.com/book/basics) **\n","slug":"go-basics","published":1,"updated":"2016-03-21T16:45:45.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim71fs0q001ek2pve3suix1n"}],"PostAsset":[],"PostCategory":[{"post_id":"cim71frzh0001k2pvz3gfa025","category_id":"cim71frzn0002k2pvays17ske","_id":"cim71frzq0005k2pvc5ds0erj"},{"post_id":"cim71frzu0008k2pvovwbo96w","category_id":"cim71frzn0002k2pvays17ske","_id":"cim71frzw0009k2pvxonjkkqu"},{"post_id":"cim71frzy000dk2pvo0t33ifh","category_id":"cim71frzz000ek2pvzzxw794o","_id":"cim71frzz000hk2pvklvbyznz"},{"post_id":"cim71fs02000kk2pvd8f12wtl","category_id":"cim71fs03000lk2pv7rmi5tze","_id":"cim71fs05000ok2pv05jr4ap3"},{"post_id":"cim71fs06000qk2pvq6yoim7q","category_id":"cim71fs07000rk2pv5le8x8ko","_id":"cim71fs07000tk2pvkf6tyjg4"},{"post_id":"cim71fs09000uk2pvwbkvt8s3","category_id":"cim71fs03000lk2pv7rmi5tze","_id":"cim71fs0a000vk2pvbjihonud"},{"post_id":"cim71fs0d000xk2pvfifovpll","category_id":"cim71fs03000lk2pv7rmi5tze","_id":"cim71fs0e000yk2pv0gxkqp4w"},{"post_id":"cim71fs0g0012k2pv9ka1oaph","category_id":"cim71fs03000lk2pv7rmi5tze","_id":"cim71fs0i0013k2pv039kkvgc"},{"post_id":"cim71fs0l0017k2pvutynsmxd","category_id":"cim71fs03000lk2pv7rmi5tze","_id":"cim71fs0m0018k2pvb0ogrpyl"},{"post_id":"cim71fs0n001bk2pvo3g9yt5b","category_id":"cim71fs07000rk2pv5le8x8ko","_id":"cim71fs0o001ck2pv0a5ief2z"},{"post_id":"cim71fs0q001ek2pve3suix1n","category_id":"cim71fs07000rk2pv5le8x8ko","_id":"cim71fs0r001fk2pvtr926cqn"}],"PostTag":[{"post_id":"cim71frzh0001k2pvz3gfa025","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71frzr0006k2pvbuv0dq50"},{"post_id":"cim71frzh0001k2pvz3gfa025","tag_id":"cim71frzp0004k2pvociezj7c","_id":"cim71frzr0007k2pvevlycg2l"},{"post_id":"cim71frzu0008k2pvovwbo96w","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71frzw000bk2pv3jj7fiho"},{"post_id":"cim71frzu0008k2pvovwbo96w","tag_id":"cim71frzw000ak2pv9xybr83g","_id":"cim71frzx000ck2pvkrwq05qc"},{"post_id":"cim71frzy000dk2pvo0t33ifh","tag_id":"cim71frzz000fk2pvwmm249kw","_id":"cim71fs00000ik2pvhsnvx9uj"},{"post_id":"cim71frzy000dk2pvo0t33ifh","tag_id":"cim71frzz000gk2pvssqnzjcs","_id":"cim71fs00000jk2pvgkl6yasc"},{"post_id":"cim71fs02000kk2pvd8f12wtl","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs05000nk2pvqq2bbdaa"},{"post_id":"cim71fs02000kk2pvd8f12wtl","tag_id":"cim71fs04000mk2pv8nycq23j","_id":"cim71fs05000pk2pvyhx5l9ho"},{"post_id":"cim71fs06000qk2pvq6yoim7q","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs07000sk2pvrcj6whip"},{"post_id":"cim71fs09000uk2pvwbkvt8s3","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs0a000wk2pvp09kkfsf"},{"post_id":"cim71fs0d000xk2pvfifovpll","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs0f0010k2pvumrro304"},{"post_id":"cim71fs0d000xk2pvfifovpll","tag_id":"cim71fs0e000zk2pv6tzqddj3","_id":"cim71fs0f0011k2pvv9c6noy0"},{"post_id":"cim71fs0g0012k2pv9ka1oaph","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs0j0015k2pvvpm8cxwl"},{"post_id":"cim71fs0g0012k2pv9ka1oaph","tag_id":"cim71fs0i0014k2pv4rhlouby","_id":"cim71fs0j0016k2pvp6fhbbe7"},{"post_id":"cim71fs0l0017k2pvutynsmxd","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs0m0019k2pvjb3xjdct"},{"post_id":"cim71fs0l0017k2pvutynsmxd","tag_id":"cim71fs0i0014k2pv4rhlouby","_id":"cim71fs0m001ak2pvk87l0nue"},{"post_id":"cim71fs0n001bk2pvo3g9yt5b","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs0o001dk2pv8uvrcsa6"},{"post_id":"cim71fs0q001ek2pve3suix1n","tag_id":"cim71frzn0003k2pv5jm52vuc","_id":"cim71fs0r001gk2pv7vegqh6t"}],"Tag":[{"name":"golang","_id":"cim71frzn0003k2pv5jm52vuc"},{"name":"singleton","_id":"cim71frzp0004k2pvociezj7c"},{"name":"observer","_id":"cim71frzw000ak2pv9xybr83g"},{"name":"Hexo","_id":"cim71frzz000fk2pvwmm249kw"},{"name":"Blog","_id":"cim71frzz000gk2pvssqnzjcs"},{"name":"xorm","_id":"cim71fs04000mk2pv8nycq23j"},{"name":"reflect","_id":"cim71fs0e000zk2pv6tzqddj3"},{"name":"concurrency","_id":"cim71fs0i0014k2pv4rhlouby"}]}}